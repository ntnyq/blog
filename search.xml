<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Tarojs开发微信小程序]]></title>
    <url>%2Fdevelop-weapp-with-tarojs%2F</url>
    <content type="text"><![CDATA[Taro 是由京东 02Team 推出的一款基于 React 语法的多端开发框架。这里记录一下我使用 Tarojs 开发微信小程序的踩坑记录和查阅资料学到的一些小技巧。 快速开始12345// 安装$ yarn global add taro-cli// 创建项目$ taro init &lt;project_name&gt; 经过一系列的交互问答后，即可成功创建项目并且会自动下载项目相关依赖。 12345678// 进入项目$ cd &lt;project_name&gt;// 小程序开发环境$ yarn dev:weapp// 打包小程序$ yarn build:weapp 默认情况下，小程序可使用的源码将生成在项目根目录下的 dist 目录，使用微信开发者工具打开此目录即可。 详细安装过程与截图可参考 Taro官方文档-快速开始 项目目录12345678910111213141516.├── config # 配置├── dist # 生产环境代码└── src ├── assets # 静态资源 │ └── images ├── components # 全局组件 │ └── Select ├── pages # 页面 ├── services # 接口封装 ├── store # 状态管理 │ ├── actions │ ├── constants │ └── reducers └── styles # 全局样式 └── core # scss变量，mixin 配置Webpack Alias修改 config/index.js 文件 的 alias 即可。 123456789101112131415const &#123; resolve &#125; = require('path')const config = &#123; alias: &#123; '@actions': resolve(__dirname, '..', 'src/store/actions'), '@constants': resolve(__dirname, '..', 'src/store/constants'), '@reducers': resolve(__dirname, '..', 'src/store/reducers'), '@store': resolve(__dirname, '..', 'src/store'), '@assets': resolve(__dirname, '..', 'src/assets'), '@config': resolve(__dirname, '..', 'src/config'), '@components': resolve(__dirname, '..', 'src/components'), '@styles': resolve(__dirname, '..', 'src/styles'), '@utils': resolve(__dirname, '..', 'src/utils') &#125;&#125; 参考-官方文档-alias 全局SCSS变量混入修改 config/index.js 文件的 plugins.sass.resource 即可。 12345678910const &#123; resolve &#125; = require('path')const config = &#123; plugins: &#123; sass: &#123; // 在此文件中导入全局变量和mixins resource: resolve(__dirname, '..', 'src/styles/core/style.scss') &#125; &#125;&#125; 参考-官方文档-plugins.sass SCSS中导入样式修改 config/index.js 文件的 plugins.sass.projectDirectory 与 plugins.sass.importer 即可。 1234567891011121314151617181920212223const &#123; resolve &#125; = require('path')const sassImporter = function (url) &#123; if (url[0] === '~' &amp;&amp; url[1] !== '/') &#123; return &#123; file: resolve(__dirname, '..', 'node_modules', url.substr(1)) &#125; &#125; const reg = /^@styles\/(.*)/ return &#123; file: reg.test(url) ? resolve(__dirname, '..', 'src/styles', url.match(reg)[1]) : url &#125;&#125;const config = &#123; plugins: &#123; sass: &#123; projectDirectory: resolve(__dirname, '..'), importer: sassImporter &#125; &#125;&#125; 全局变量注入默认情况下，Taro 提供了开发和构建两种环境。 在这两种环境下，和通用配置文件中，都可以根据需要去修改，注入一些全局变量(如接口请求地址等。) 如有需要更多的环境，可引入 cross-env 库，在 config/dev.js 和 config/prod.js 中根据某个约定的环境变量去为全局注入某些常量。 关闭默认的ES6模块化导入导出Taro 默认情况下，要求用户以 ES6 规范的 import 和 export default 导入导出数据。 在很多情景下，都为用户造成了不变。比如同个文件要导出多个对象的情况下或者工具函数库中。 可通过配置 EsLint 关闭此检查。 12345678910111213141516171819202122232425&#123; &quot;extends&quot;: [ &quot;taro&quot; ], &quot;rules&quot;: &#123; &quot;no-unused-vars&quot;: [ &quot;error&quot;, &#123; &quot;varsIgnorePattern&quot;: &quot;Taro&quot; &#125; ], &quot;react/jsx-filename-extension&quot;: [ 1, &#123; &quot;extensions&quot;: [ &quot;.js&quot;, &quot;.jsx&quot;, &quot;.tsx&quot; ] &#125; ], &quot;import/prefer-default-export&quot;: &quot;off&quot; &#125;, &quot;parser&quot;: &quot;babel-eslint&quot;&#125; 接口请求封装 下面代码中的 API_HOST 为全局注入的常量。关闭了 EsLint 对它的检查。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import Taro from '@tarojs/taro'import HTTPS_STATUS from '@config/http-status'/* eslint-disable-next-line no-undef */export const apiHost = API_HOSTconst api = &#123; baseOptions (params, method = 'POST') &#123; const &#123; url, data, contentType = 'application/x-www-form-urlencoded' &#125; = params const options = &#123; url: url.includes('http') ? url : `$&#123;apiHost&#125;$&#123;url&#125;`, data, method, header: &#123; 'content-type': contentType &#125; &#125; return Taro.request(options) .then(res =&gt; &#123; const &#123; statusCode, errMsg &#125; = res if (statusCode === 200) &#123; const resData = res.data const &#123; code, msg &#125; = resData if (code === HTTPS_STATUS.SUCCESS) &#123; return resData.data &#125; else &#123; Taro.showToast(&#123; title: msg || '接口返回数据出错', icon: 'none' &#125;) return Promise.reject(&#123; message: msg, ...res &#125;) &#125; &#125; else &#123; Taro.showToast(&#123; title: errMsg || '小程序数据请求成功，但状态码非200', icon: 'none' &#125;) return Promise.reject(&#123; message: errMsg, ...res &#125;) &#125; &#125;) .catch(err =&gt; &#123; const message = '小程序数据请求失败' Taro.showToast(&#123; title: err &amp;&amp; err.errorMsg || message, icon: 'none' &#125;) return Promise.reject(&#123; message, ...err &#125;) &#125;) &#125;, get (url, data = &#123;&#125;) &#123; const option = &#123; url, data &#125; return this.baseOptions(option, 'GET') &#125;, post (url, data = &#123;&#125;, contentType) &#123; const option = &#123; url, data, contentType &#125; return this.baseOptions(option) &#125;, put (url, data = &#123;&#125;) &#123; const option = &#123; url, data &#125; return this.baseOptions(option, 'PUT') &#125;, delete (url, data = &#123;&#125;) &#123; const option = &#123; url, data &#125; return this.baseOptions(option, 'DELETE') &#125;&#125;export default api 相关资料 Taro官网 Taro官方仓库 Awesome-Taro]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPVue中的页面转发]]></title>
    <url>%2Fpage-forward-in-mpvue%2F</url>
    <content type="text"><![CDATA[MPVue 框架中小程序小程序页面和 web-view 跳转页面的转发功能实现。 基础小程序转发分享功能，依赖于 onShareAppMessage API。 从官方文档看，它使用方法如下： 1234567891011121314Page(&#123; onShareAppMessage (res) &#123; const &#123; webViewUrl &#125; = res const title = '我的自定义题' const path = `/pages/page_name?a=123` const imageUrl = 'https://image.url' return &#123; title, path, imageUrl &#125; &#125;&#125;) 当点击页面内的转发按钮或右上角的转发菜单时，该函数会被调用，读取相关的配置，返回一个对象作为分享内容的配置，参数如下： title 转发时显示的标题 默认为小程序名称 path 转发路径 默认为当前页的path 必须是以/开头的完整路径 imageUrl 自定义分享图片，支持PNG和JPG格式，显示图片长宽比为5:4 默认使用当前页面截图 该回调函数可接收1个参数，可以从该参数中读取 web-view 页面的url。 原生小程序web-view转发原理：web-view 的 src 属性设置为动态的。在页面载入时获取分享出去的 path，读取上面的 options 字段，类似 URL 的 search 字段，获取需要的参数。再拼接至当前小程序页面的地址后，重置 web-view 的 src 值。 wxml123&lt;view class="container"&gt; &lt;web-view src="&#123;&#123; webSrc &#125;&#125;"&gt;&lt;/web-view&gt;&lt;/view&gt; js1234567891011121314151617181920212223242526272829303132Page(&#123; data: &#123; webSrc: 'https://ntnyq.com' &#125;, onShareAppMessage (res) &#123; const return_url = res.webViewUrl const path = `/pages/index/index?return_url=$&#123;encodeURIComponent(return_url)&#125;` return &#123; path, success (res) &#123; wx.showToast(&#123; title: '转发成功', icon: 'success', duration: 200 &#125;) &#125; &#125; &#125;, onLoad () &#123; const pages = getCurrentPages() const currentPage = pages.slice(-1)[0] const webSrc = decodeURIComponent( currentPage.options.return_url || 'https://ntnyq.com' ) this.setData(&#123; webSrc &#125;) &#125;&#125;) MPVue中转发MPVue中转发基本和原生小程序一致。 web-view页面中有如下差异： 小程序通过 getCurrentPages 获取应用的页面栈。再获取当前页面和当前页面的查询参数。而MPVue中则使用 this.$root.$mp.query 获取查询参数对象。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;web-view :src=&quot;webSrc&quot;&gt;&lt;/web-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; config: &#123; navigationBarTitleText: &apos;导航栏标题&apos; &#125;, data () &#123; return &#123; webSrc: &apos;https://ntnyq.com&apos; &#125; &#125;, onShareAppMessage (res) &#123; const returnUrl = res.webViewUrl const path = `/pages/tab/paper?return_url=$&#123;encodeURIComponent(returnUrl)&#125;` return &#123; path, success (res) &#123; wx.showToast(&#123; title: &apos;转发成功&apos;, icon: &apos;success&apos;, duration: 200 &#125;) &#125; &#125; &#125;, onLoad () &#123; const options = this.$root.$mp.query const webSrc = decodeURIComponent( options.return_url || &apos;https://ntnyq.com&apos; ) this.webSrc = webSrc &#125;&#125;&lt;/script&gt; 展望早上看了下 Taro 的介绍，打算将小程序技术栈，转至 Taro了，还可以顺便学学 React。 参考资料 官方文档-getCurrentPages 官方文档-onShareAppMessage]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel常用模块说明]]></title>
    <url>%2Fbabel-mostly-used-modules%2F</url>
    <content type="text"><![CDATA[@babel/preset-envpreset 的实质是特定 plugins 的集合。(目前30个左右。) preset-env 不包含 stage-x 提案，所以无法进行对其转译工作。 1234567891011module.exports = &#123; presets: [ [ &apos;@babel/preset-env&apos;, &#123; modules: false, useBuiltIns: &apos;entry&apos; // false, entry, usage &#125; ] ]&#125; @babel/polyfill让新版浏览器 API 可以在老版本浏览器上得到支持。 比如新的数据类型，实例方法 等。 非模块化环境下使用： 1&lt;script src=&quot;@babel/polyfill/dist/polyfill.js&quot;&gt;&lt;/script @babel/runtime@babel/runtime 源码依赖并直接导出了 regenerator-runtime。 需配合 @babel/plugin-transform-runtime 使用。 作用： 将编译过程中使用到的某些辅助函数，复用起来，在转译后的结果头部引入。 例： 若不使用，多个文件内都包含 class 声明，则编译后，每个文件的 class 声明都会生成一个对应的 _classCallCheck 函数，同个文件内则通用一个 _classCallCheck 函数。 假设我们使用 optimization.splitChunks 做了代码分割，做了如下配置： 12345678910111213141516optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; test: /node_modules/, name: 'vendors', chunks: 'initial', priority: 10, enforce: true &#125; &#125; &#125;, runtimeChunk: &#123; name: 'manifest' &#125;&#125; 将所有的来自 node_modules 目录下的代码，全部打包入 vendors 文件内。 如果我们使用了 @babel/-plugin-transform-runtime ，这时 _classCallCheck 将不会再被打包入 main.js 而是会被打包入 vendors.js 内。其他模块，再对它进行复用。 @babel/-plugin-transform-runtime若使用了插件，未下载 @babel/runtime 则编译时会报错，找不到需要的模块。 默认配置： 12345678910111213module.exports = &#123; plugins: [ [ '@babel/plugin-transform-runtime'， &#123; corejs: false, // true, false, 2 helpers: true, // helper函数，如classCallCheck typeof等 regenerator: true, // 不污染全局变量 useESModules: false &#125; ] ]&#125; @babel/register让非 EsModule 环境支持使用 import 和 export 等关键字进行模块导入导出。 12// main.jsrequire('@babel/register') 扩展阅读一口（很长的）气了解 babel]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncFunction学习笔记]]></title>
    <url>%2Fasync-note%2F</url>
    <content type="text"><![CDATA[异步解决方案 AsyncFunction 学习笔记。 webpack未使用到的变量和函数，不会出现到编译后的文件里。(tree shaking) Babel 关于babel如何编译async函数的记录 只有@babel/preset-env编译成功，会将async函数编译为Promise，但同时会报错regeneratorRuntime is undefined， 函数无法运行。 再含有@babel/plugin-transfrom-runtime编译失败，会提示缺少@babel/runtime/helpers/asyncToGenerator和@babel/runtime/regenerator。 再含有@babel/runtime此依赖需要安装为项目依赖。 1$ yarn add @babel/runtime 编译成功，且函数运行成功。 @babel/polyfill的使用安装1$ yarn add @babel/polyfill 全部引入可以直接在项目入口导入，或者在webpack的entry中。 12345// webpack.config.jsmodule.exports = &#123; entry: ['@babel/polyfill', `$&#123;__dirname&#125;/src/main.js`]&#125; 非webpack全部引入在js文件顶部使用require或者import引入 12345678// main.jsimport &apos;@babel/polyfill&apos;// or require(&apos;@babel/polyfill&apos;)// other code 配置.babelrc，将@babel/preset-nev的useBuiltIns字段设置为entry 1234567891011121314// .babelrc.jsmodule.exports = &#123; presets: [ ['@babel/preset-env', &#123; targets: &#123; node: true, // config your env esModules: true &#125; modules: 'auto', useBuiltIns: 'entry' &#125;] ]&#125; 按需引入无需引入@babel/polyfill，但仍需安装 12345678910// .babelrc.jsmodule.exports = &#123; presets: [ ['@babel/preset-env', &#123; modules: false, useBuiltIns: 'usage' &#125;] ]&#125; Async async function声明用于定义一个返回AsyncFunction对象的异步函数。 异步函数指通过事件循环异步执行的函数，它会通过一个隐式的Promise返回其结果。 这个异步函数的语法和结构像是标准的同步函数。 async/await可用于简化多个promise异步调用的操作。 基础用法123456789101112131415161718192021222324252627282930313233343536function resolveAfter2Seconds () &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('resolved!') &#125;, 2e3); &#125;)&#125;async function asyncCall () &#123; console.log('Calling start') const result = await resolveAfter2Seconds() console.log(result) console.log('Calling end') // 以下2种操作会被catch捕获 // throw new Error('async throw error') // console.log(notExistVar) return 'This string returned by async function'&#125;asyncCall() .then(str =&gt; &#123; console.log(str) &#125;) .catch(err =&gt; &#123; consoe.log(err) &#125;)/*output-&gt; Calling start2s later-&gt; resolved!-&gt; Calling end-&gt; This string returned by async function*/ 使用async function声明来定义一个AsyncFunction。 使用await关键字来处理异步函数，将会使此AsyncFunction暂停执行，等待Promise的结果出来，再恢复AsyncFunction的执行。 AsyncFunction中使用return关键字返回的值，会被隐式的Promise进行resolve。 AsyncFunction中使用throw关键字抛出的错误或者调用该函数时内部的错误，会被隐式的Promise进行reject。 await关键字只能在AsyncFunction内部使用，否则会报错SyntaxError Promise VS Async/AwaitMDN示例 AsyncFunction改写Promise链1234567891011121314151617181920212223function getProcessedData (url) &#123; return donwloadData(url) .then(v =&gt; &#123; return processDataInWorker(v) &#125;) .catch(err =&gt; &#123; console.log(err) return downloadFallbackData(url) &#125;)&#125;async function getProcessedData (url) &#123; let v try &#123; v = await donwloadData(url) &#125; catch (err) &#123; console.log(err) v = await downloadFallbackData(url) &#125; return processDataInWorker(v)&#125; 浏览器兼容性MDN - BCD Can I Use 非IE浏览器/QQ浏览器 其他高版本浏览器 需要babel来提供回退到 Promise + Promise Polyfill 参考资料MDN - async function]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度总结]]></title>
    <url>%2Fthe-end-of-2018%2F</url>
    <content type="text"><![CDATA[现在是2018年12月31日11点，内耗掉整个白天回忆思考后，拖延到现在终于打开了电脑，开始对今年做一个总结。 关于这样的记录，上年我就有写了一篇。往后我仍然会坚持下去。 2018回顾2018年总的说来，还算过得去，有苦有甜吧。简单的时间线如下： 2018/03 购买了我的第一台 Macbook Pro。 2018/07 买的房子在延迟交房近1年后终于领到了钥匙。 2018/08 购买了一台Switch游戏机。 2018/10 租住了两年的房子要拆迁了，搬到现在租的房子里。 2018/11 第二次去北京出差，总计21天。 2019展望在接下来的2019年，希望能够达成以下几个目标： 搬到装修后的新房内，打理好房子。 学会做饭，达到能满足自己的口味的地步。 购买一台 3Dio 人头麦，玩玩儿ASMR。 抽出假期，去国内某个城市旅游一周。 找时间做前端相关的教程视频上传至B站。 Github上开源至少一个可以称之为项目的小项目。 更加深入地折腾技术，加深自己的技术积累，为常见开发任务总结解决方案。 搭建自己的个人网站（不仅仅是博客）。 给家人买点东西，随便什么，只要是有用的。 改掉可以改掉的一些坏习惯。 结束&lt;/2018&gt;&lt;2019&gt; 2018再见，2019你好。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入框自动填充样式问题解决。]]></title>
    <url>%2Fhack-input-autocomplete-style%2F</url>
    <content type="text"><![CDATA[如何 Hack Chrome 浏览器对表单自动填充时候的淡黄色背景。 在 Web 开发中，我们经常会遇到一个问题，浏览器会在记住密码时自动填充登录表单，同时输入框会增加淡黄色的背景。如下图所示： 在对样式要求不严苛的情况下，这样淡黄色的背景色是可以忍受的。 但是在对样式有严格定制的情况下，或者产品，设计要求下，或者这个淡黄色与系统主题颜色及其不搭配时候，自定义这个样式就非常有必要了。 样式覆盖首先，我们想到的解决方案，应该是 样式覆盖。通过浏览器的 Inspect 功能，可以从 Element -&gt; Styles 面板查看到，在输入框被自动填充时，它会增加如下样式： 12345input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: rgb(250, 255, 189) !important; background-image: none !important; color: rgb(0, 0, 0) !important;&#125; 在CSS增加样式覆盖后，虽然后引入权值更高，但是并不能覆盖浏览器默认的样式。 表单类型修改 设置 input 的 autocomplete 属性值为 new-password 可以避免表单被自动填充。 1&lt;input type="text" autocomplete="new-password" /&gt; Hack修改 一些奇思妙想，但是有奇效的方法。 纯色背景输入框 使用阴影遮盖淡黄色背景 1234input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset; -webkit-text-fill-color: #333;&#125; 透明背景输入框 此hack方法让我惊为天人，过渡5000秒 1234:-webkit-autofill &#123; -webkit-text-fill-color: #fff !important; transition: background-color 5000s ease-in-out 0s;&#125; 参考资料Chrome 自动填充的表单是淡黄色的背景，有方法自定义吗]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中的数据管理。]]></title>
    <url>%2Fdata-manage-in-vue-project%2F</url>
    <content type="text"><![CDATA[浅谈Vue项目中如何进行数据管理，以及Vuex的基本用法。 背景最近连续3个项目都在使用 Vue 框架进行开发，踩了不少坑，阅读了很多资料，也学到了很多技巧。 昨晚在写 Demo 的时候，发现自己最近项目中使用 Vuex 的方式有些错误。所以特地深入研究了一番，顺便写下这篇文章做个记录。 踩坑上个项目的数据管理方案为：将整个项目的所有页面按功能点划分为几大模块(根据目录)，再将每个模块映射到 Vuex 的modules，并且通过modules内使用namespced来导出模块。具体如下： vuex入口伪代码如下： 12345678910111213// src/store/index.jsimport Vue from 'vue'import Vuex from 'vuex'import modules from './modules'Vue.use(Vuex)const store = new Vuex.Store(&#123; modules&#125;)export default store 123456789// src/store/modules/index.jsimport userState from './user-state'import appState from './app-state'// 将所有modules整合成一个对象导出export dafault &#123; userState, appState&#125; 12345678910111213141516171819202122232425262728293031323334// src/store/modules/user-state.jsimport * as Api from '@/services/user' // apiimport types from '@/store/mutation-types' // mutation-types 使用了keyMirrorimport &#123; mapMutations, mapActions &#125; from '@/store/helpers' // 辅助函数const state = &#123; user: &#123;&#125; &#125;const conf = [ &#123; name: 'login', mutation: types['LOGIN'], service: Api.login, success (state, &#123; res &#125;) &#123; state.user = res.data.user &#125; &#125;]const actions = &#123; ...mapActions(conf) // 辅助函数生成actions 调用api 并且根据结果提交对应mutation&#125;const mutations = &#123; ...mapMutations(conf) // 辅助函数 生成mutations 分为调用、成功和失败，若不传回调，则为noop&#125;export default &#123; namespaced: true, // 启用命名空间 state, actions, mutations&#125; 页面使用数据和调用方法页面通过mapState辅助函数，导入对应modules中的数据state，通过调用mapActions辅助函数导出的方法来进行数据请求。伪代码如下： 12345678910111213141516171819202122232425262728&lt;script&gt;import &#123; mapState, mapActions &#125; from &apos;vuex&apos; // 导出vuex辅助函数const NAMESPACE = &apos;namedState&apos; // 设置命名空间 对应vuex modules 的 keyexport default &#123; computed: &#123; // 导出命名空间下的数据 ...mapState(NAMESPACE, [ &apos;stateKey&apos; ]) &#125;, methods: &#123; fetchData () &#123; // 调用方法 this.actionKey(params) .then(res =&gt; &#123; // do something &#125;) &#125;, // 导出命名空间下的方法 ...mapActions(NAMESPACE, [ &apos;actionKey&apos; ]) &#125;, mounted () &#123; this.fetchData() &#125;&#125; &lt;/script&gt; 缺陷从数据流动上来说，是完全按照 Vue 规范的数据单向流动进行的。业务上是完全可以跑通的，并且不会出现Bug。 但是会导致 Vuex 缓存的数据过多，页面占用内容增大，每个页面created后就一直会维持一份自己的数据。进入页面后，若数据返回较慢，则会出现一次数据更新时候的闪动，用户体验不好。（对于这个问题，当时的解决方案是增加清空数据的actions，并且在页面组件的beforeDestroy钩子函数中调用） 同时也增加了项目架构的复杂性，理解数据的流程更加困难，并且进行了很大一部分完全没有必要的编码。 针对这个问题，我早先和提供代码的人沟通过，他说是把数据缓存在 Vuex 中，并且把数据请求也封装进去，是为了方便埋点，做日志。精确记录用户都做了哪些数据请求，成功和失败的各种记录。 正确使用Vuex 配合 Vuejs Devtools，更容易理解Vuex。 先从语义上理解以下几个词： store 存储 state 状态 dispatch 调度 action 行为 mutation 转变 commit 提交 使用规范正确使用 Vuex，需要遵循这几个原则： 正确理解 Vuex 和 组件之间数据的单向流动 使用dispatch来调用定义好的action，在组件中可以通过this.$store.dispatch访问到。 使用action来提交mutation，action可以同时提交多个mutation，并且可以包含异步操作来修改mutation。 使用mutation来更新state，mutation只能同步地修改state。 需要使用基于state而衍生的数据时候，可以定义一个getter，类似于组件中的computed。 Vue组织结构Vuex 的组织是一个类似树状的结构，如下伪代码所示： 12345678910111213141516171819export default new Vuex.Store(&#123; state: &#123;&#125;, actions: &#123;&#125;, mutations: &#123;&#125;, getters: &#123;&#125;, modules: &#123; foo: &#123; state: &#123;&#125;, actions: &#123;&#125;, mutations: &#123;&#125; &#125;, bar: &#123; state: &#123;&#125;, actions: &#123;&#125;, mutations: &#123;&#125; &#125;, // more modules &#125;&#125;); 辅助函数 命名空间模式 指，vuex 中的 某个module，设置了namespaced： true来导出。 mapState 在组件中使用可以导出状态数据。需要在computed字段使用。在状态树根部定义的属性可以通过state.key来进行访问，而在 module 中定义的的状态，则需要通过state.module.key来实现访问。 mapGetters 在组件中使用可以导出状态数据。需要在computed字段使用。在 getters 不多的情况下，建议只在 状态树 根部 定义 getters，并且抽离出单独的文件来进行维护。 mapActions 在组件中使用可以导出方法，需要在methods字段使用。普通的 module 和 状态树 根部定义的方法，都可以直接通过 mapActions 函数访问到。但是命名空间模式的方法导入，需要第一个参数传命名空间名，如...mapActions(NAMESPACE, [&#39;foo&#39;])，或者通过...mapActions([&#39;NAMESPACE/foo&#39;])的方式来进行导出。 mapMutations 不建议做导出，因为官方推荐使用 action 来 commit 提交 mutations。并且不建议在组件中直接修改 state。 使用辅助函数导出数据，方法等有两种形式，一种保留本身的key命名，一种根据需要进行自定义修改，前者语法简单，后者更为灵活。伪代码如下： 12345678910111213141516import &#123; mapState, mapGettters, maoActions, mapMutations &#125; from 'vuex'// ...computed: &#123; ...mapState(['foo', 'bar']), // 数组参数 使用状态的相同key值来实现导出 mapGetters也有此语法 ...mapGetters(&#123; // 对象参数 使用可自定义的key来接收函数返回的状态值 可导出modules中的数据 mapState也有此语法 abc: state =&gt; state.foo, xyz: state =&gt; state.moduleA.xyz &#125;)&#125;methods: &#123; ...mapActions(['foo', 'bar']), // 数组参数 导出方法 可以通过this调用 mutations不建议做导出 ...mapActions('appState', ['abc', 'xyz']) // 导出命名空间模式的方法，state和getters有类似写法&#125;// ... 状态切分首先，需要明确的一点是，你也许并不需要 Vuex？ 比如你没有或者只有很少的数据需要在组件间共享，那么也可以你可以采用 cookie，sessionStorage，localstorage或者 EventBus 等多种实现方式。 如果你是在构建一个大的应用，有多种状态需要管理，或者你需要考虑到系统后续的可扩展性，希望早期就使用这种更成熟的解决方案，那么 Vuex 将是你很好的选择。 那么，如何进行状态数据的切分呢？ 首先我会考虑需要进行状态管理数据的复杂程度，几个数据并且不存在大的命名冲突的，就不使用模块化的方案，全部使用在根部的state, actions, mutations, getters。 如果页面属于UI上比较一致，组件的功能点上也不好做区分，需要在命名问题上下功夫的，那么建议将其切割成多个模块，保留语义性。或者页面的actions, mutations逻辑复杂，考虑到代码的可读性，建议使用模块化切分成多个文件，便于单独地去修改维护。 组件内使用状态的使用，使用上述方法导入后，类似data属性，都会被 vue observe 到，同时被挂载在了组件实例上，通过this.foo的方法即可使用。 方法的使用，使用mapActions方法导入后，可以直接使用this来进行调用。或者在组件中使用this.$store.dispatch(&#39;action_name&#39;, payload)来进行调用。 Vuex数据流示例总体，单项数据流程过程是，页面内的 dispatch 或者 action 调用，可传入需要的参数，再通过 commit 提交 mutation，再在 mutation 中同步修改 state，单向数据流动的 state 又更细到组件内，触发组件重新渲染。 123456789101112131415const state = &#123; total: 0&#125;const actions = &#123; add (&#123; commit &#125;, num) &#123; // commit为结构出来的方法 也可以结构dispatch出来调用别的action commit(&apos;ADD&apos;, num) // 或者同时触发多个 mutations &#125;&#125;const mutations = &#123; ADD (state, num) [ state.total += num ]&#125; 相关资料Vuex官方文档 Vuex DemoDEMO源码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中使用Mockjs]]></title>
    <url>%2Fmock-data-for-vue-project%2F</url>
    <content type="text"><![CDATA[如何在Vue项目中使用Mockjs。 背景开发过程中，我们经常会遇到后端接口提供不及时，无数据测试无法提前进行测试拖长项目工期，或者需要写无服务的静态页面展现数据DEMO的囧境。没有供展现的数据，手写数据费时且太死板，缺乏灵魂，常遇到需求简单修改，就要给一个列表都加上字段，实在是非常糟糕的开发体验。 针对这一开发痛点，有人开发出了一款名为Mockjs的模拟数据神器。它用法简单，方便扩展，支持种类丰富的随机数据，足以满足日常开发需求。并且对开发无侵入，不需要对系统代码进行修改，通过拦截Ajax请求，返回模拟数据以供开发测试使用。 这里主要谈一下如何在Vue项目中组织和使用mockjs进行数据模拟。 安装使用包管理器，将mockjs安装到项目中 1yarn add mockjs 使用在src目录下，创建index.js文件，作为mock各个模块的导出点，供src/main.js使用。在src/mock/modules目录下，创建table.js规则，模拟表格数据，供mock使用。 123456789101112// src/mock/index.jsimport &#123; mockjs &#125; from ‘mockjs’import TableApi from ‘./modules/table.js’const &#123; mock &#125; = mockjs // Mock函数// 使用拦截规则拦截命中的请求mock(/\api\/getTableData/, ‘get’, TableApi.getTableData)export default mockjs 12345678910111213141516171819202122// table.jsimport &#123; Random &#125; from ‘mockjs’ // 导出随机函数const code = 200 // 状态码 项目同一export default = &#123; getTableData () &#123; let data = [] Array.apply(null, &#123; length: 10 &#125;).forEach(_ =&gt; &#123; data.push(&#123; name: Random.cname(), // 随机汉语名 title: Random.csentence(8, 16), // 随机中文字符串 date: Random.date() // 随机日期 &#125;) &#125;) return &#123; code, data &#125; &#125;&#125; 12345// src/main.jsimport ‘./mock’ // 手动引入 不需要时需要注释代码或者删除process.env.NODE_ENV === ‘development’ &amp;&amp; require(‘./mock’) // 打包时忽略 ApiMockjs API 文档 内含各种内置的API，和使用方法示例。主要包括以下几类： 基础数据类型 (Basic) 日期时间 (Date) 占位图片 (Image) 颜色 (Color) 文本 (Text) 姓名 (Name) 网络相关 (Web) 地址 (Address) 工具函数 (Helper) 等等 并且它易于扩展，可接受请求参数，根据参数定制数据。 注意 Mockjs依赖中保存着大量用于伪造假数据的静态数据，引入的时候打包得到的文件体积会明显增大，这是正常的。 Mockjs模拟数据后，会将命中配置规则(正则表达式)的请求拦截，这时候在浏览器的Network面板是无法看到数据返回的，可以通过打印数据的方式观察。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Mockjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element-UI库定制样式]]></title>
    <url>%2Fglobal-custome-element-ui-style%2F</url>
    <content type="text"><![CDATA[探索如何全局修改Element-UI库的样式。 默认 默认样式下，Element-UI的主题色为鲜艳的蓝色，在没有定制样式的情况下使用还是不错的。 默认情况下，我们执行yarn add element-ui会得到一个同名的依赖，其样式文件存在于element-ui/lib/theme-chalk目录下。 所以不管我们是将组件库全局引入，或者按需引入，都需要指定使用的CSS位于这里。 具体配置方式请查看官方文档-快速开始。 修改局部样式在使用到这个局部样式的组件文件中以高权值覆盖的形式来修改，若此样式在多个地方被使用，则可以通过给组件添加类的方式，再到通用的样式文件中修改覆盖。 修改主题颜色编写一个保存自定义样式的文件，例如src/element-variables.scss，在其中以变量的形式来覆盖element-ui中的变量。最后再在main.js中导入这个文件。 1234567891011// element-variables.scss@charset "utf-8";/* 改变主题色变量 */$--color-primary: indigo;/* 改变 icon 字体路径变量，必需 */$--font-path: '~element-ui/lib/theme-chalk/fonts';@import "~element-ui/packages/theme-chalk/src/index"; # 引入样式文件 注意这里是package index是所有样式scss文件的集合。这里通过传入变量，实现样式重置。 1import '@/element-variables.scss'; 修改部分样式修改全部样式 建议下载使用官方提供的CLI工具。 1234567891011121314151617# 安装后获得et命令$ sudo yarn global add element-theme# 查看参数配置$ et -hUsage: et [options]Options: -V, --version output the version number -i --init [filePath] init variables file -w --watch watch variable changes then build -o --out [outPath] output path -m --minimize compressed file -c --config [filePath] variables file -b --browsers &lt;items&gt; set browsers -h, --help output usage information 需要用到的命令: et 修改配置后打包，生成主题文件夹 et -i 生成element-variables.scss文件，包括所有需要用到的变量。 使用过程下载element-theme-chalk为开发依赖。 1$ yarn add element-theme-chalk -D 使用et -i生成element-variables.scss文件，修改需要修改的变量后保存，执行et。 就会看到在根目录下生成了一个theme文件夹。 然后可以将theme/index.css在main.js来导入定制后全部的Element-UI库样式，或者在babel配置文件中，指定babel-plugin-component的styleLibrary为~theme来供组件按需使用的样式导入。 参考资料官方文档-自定义主题]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面事件和锚点问题]]></title>
    <url>%2Fpage-events-and-anchor%2F</url>
    <content type="text"><![CDATA[公司最近安排的一个小工作，解决两个页面上的小问题。问题1，带hash的链接跳转至目标页面后会发生抖动；问题2，IOS Safari浏览器回退后tab页效果失效。 情景描述 详细阐述问题。 问题1假设有2个页面，一个新闻列表页面，一个是将列表中的所有新闻聚合在一起的一个新闻详情页面。 新闻列表点击通过链接跳转至详情页，同时通过hash来定位跳转后的位置。伪代码如下： 1234567&lt;!-- page1 --&gt;&lt;a href="page2.html#foo"&gt;foo&lt;/a&gt;&lt;a href="page2.html#bar"&gt;bar&lt;/a&gt;&lt;!-- page2 --&gt; &lt;a name="foo"&gt;foo&lt;/a&gt;&lt;a name="bar"&gt;bar&lt;/a&gt; 实际情境是详情页新闻特别多，上百条，是通过服务器渲染的数据。但是在跳转至详情页后，会发生页面先展示最顶端，然后再定位至应该定位的位置的情况。 起初我以为是因为内容太多，导致解析速度降低。 我写了简单的demo，生成了10000个链接。实际使用在跳转定位时候并没有发生抖动的问题。只是有可能因为DOM节点太多引起浏览器崩溃 - -！。 顺便搜索了一下资料，学习了些关于hash的知识，整理如下： URL中的#字符代表页面上的位置，是指定位置标识符，取id的意思。 #可以定位到2种位置，1是有对应name属性的位置，2是有对应id属性的位置。使用name属性只能使用a标签。 #符号只供浏览器定位使用，在和服务器的HTTP交互中，hash字段内容并不会被发送。 改变#符号后的内容不会引起浏览器页面的重载，只会让页面跳转至对应的位置。 改变#符号后的内容会改变浏览器的历史记录。会在history API中新增内容，并且可以使用浏览器的回退按钮进行回退操作。（不包括IE6和IE7） Vue Router的hash模式就是基于这一特性的。 通过window.location.hash可以读取hash值，IE8+存在hashchange事件可检测此变动。 谷歌默认不抓取#部分的内容，但是可以使用#!将其后面的内容转成查询字符串_escaped_fragment_的值 。 在页面按下F5后，即使url后面跟随有锚点，页面不会重新进行定位。这被称为锚点失效问题。 问题2问题2描述很简单，就是简单的浏览器发生回退后tab效果失效了，但是页面简单地发生滚动就会重新生效。 感觉是页面暂时处于后台了，在一个未被激活的状态，所以它的事件失效了。 查询了一下页面隐藏显示切换的API，有两种事件pageshow/pagehide和visibilitychange。 并且同时知道了如果a标签上面有target=_blank属性，点击后用新的标签页打开页面后，是不会有history记录的，也就是这时浏览器的回退是无效的。只有在同个页面内的跳转才会被history API记录。 而visibilitychange事件监听的是这种标签处于前后台切换的事件。 pageshow和pagehide则可以监听到浏览器的前进和回退，这种历史记录的事件。 两种事件的绑定方式也存在不同，方法如下： 12345// 绑定在document上document.addEventListener('visibilitychange', e =&gt; &#123;&#125;, !1);// 绑定在window上window.addEventListener('pageshow', e =&gt; &#123;&#125;, !1); 兼容性pageshow事件的兼容性为IE11+，详见： CanIUse-pageshow visibilitychange事件的兼容性为IE10+，详见： CanIUse-visibilitychange 参考资料阮一峰-URL的井号 MDN-pageshow MDN-visibilitychange]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Events</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的Iframe标签]]></title>
    <url>%2Fiframe-tricks%2F</url>
    <content type="text"><![CDATA[参考资料iframe, 我们来谈一谈 MDN-iframe 知乎-iframe 有什么好处，有什么坏处？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是如何使用SCSS的]]></title>
    <url>%2Fhow-i-use-scss%2F</url>
    <content type="text"><![CDATA[最近开始从原先使用Less作为CSS预处理器切换到SCSS了。写这篇博文记录一下我学习使用SCSS的过程。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决lazyMan问题]]></title>
    <url>%2Flazyman-answer%2F</url>
    <content type="text"><![CDATA[尝试解决了一下著名的LazyMan问题，虽然可能代码还不够优雅，不过总算是独立做出来了。 问题描述1234567891011121314151617181920212223242526272829// 实现一个LazyMan，可以按照以下方式调用:LazyMan("Hank")// 输出:Hi! This is Hank!LazyMan("Hank").sleep(10).eat("dinner")// 输出:Hi! This is Hank!// 等待10秒..Wake up after 10Eat dinner~LazyMan("Hank").eat("dinner").eat("supper")// 输出:Hi This is Hank!Eat dinner~Eat supper~LazyMan("Hank").sleepFirst(5).eat("supper")// 等待5秒后输出：Wake up after 5Hi This is Hank!Eat supper 我的答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var lazyMan = function (name) &#123; var _this = this; if (_this instanceof lazyMan) &#123; _this.tasks = []; _this.greet(name); setTimeout(function () &#123; _this.run(); &#125;); return _this; &#125; else &#123; return new lazyMan(name); &#125;&#125;;lazyMan.fn = lazyMan.prototype;lazyMan.fn.run = function () &#123; var _this = this, tasks = _this.tasks; if (tasks.length) &#123; var task = tasks.shift(); setTimeout(function () &#123; console.log(task.str); _this.run(); &#125;, task.time * 1000 || 0); &#125;&#125;;lazyMan.fn.greet = function (name) &#123; var _this = this; _this.tasks.push(&#123; str: 'Hi, this is ' + name &#125;); return _this;&#125;;lazyMan.fn.sleep = function (num) &#123; var _this = this; _this.tasks.push(&#123; str: 'Wake up after ' + num, time: num &#125;); return _this;&#125;;lazyMan.fn.eat = function (meal) &#123; var _this = this; _this.tasks.push(&#123; str: 'Eat ' + meal &#125;); return _this;&#125;;lazyMan.fn.sleepFirst = function (num) &#123; var _this = this; _this.tasks.unshift(&#123; str: 'Wake up after ' + num, time: num &#125;); return _this;&#125;;// testlazyMan('Ntnyq').sleep(3).eat('lunch').sleepFirst(5); 总结首先，要实现方法的链式调用，简单来通过面向对象(基于原型)的实现，就是把方法绑定到原型上，再每次调用原型上的方法后把实例(this)又返回。 那么从含义上理解，sleep，eat，sleepFirst都是lazyMan的方法，而调用它传入的参数则是一条属性，但同时它也需要函数去返回。 再者，需要依次将所有的方法加入到事件执行的数组中，再开始执行这些方法，同时还要将名字也打印出来。另外，加入事件的顺序和最终事件执行的顺序是不同的，有的事件需要延后执行，有的需要最早执行(优先级)，但总体执行事件是异步的过程，加入事件是同步的。每执行一个事件后，要接着执行下一个事件。 那么，我们需要的逻辑如下： 使用安全的类创建一个对象，并且传入属性名字，同时生成一个保存任务的数组。并同时加入一个say Hello的事件。再开始异步地去调用触发这些任务的方法。 依照链式顺序执行所有函数，将需要执行输出的文字和时间做为参数放入事件栈中。默认时间为0(其实setTimeout函数因为异步的关系，执行间隔最少也需要几毫秒)，并且在特性的条件下(sleepFirst)将任务unshift入数组。 链式的方法全部进入数组，异步的方法调用触发，依次从任务数组里拿出任务并执行。 大神实现lazyman问题-前端网老姚]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Worker学习笔记]]></title>
    <url>%2Fweb-worker-note%2F</url>
    <content type="text"><![CDATA[Web worker的存在，为JavaScript提供了多线程的运行环境，允许主线程创建worker线程。 此文档主要介绍的是Dedicated Worker 背景JavaScript语言设计之初采用的是单线程的模型。所有的任务都是在一个线程上通过回调来进行调度的。前面的任务没做完，后面的任务就只能等着。随着计算机算力的增强，尤其是多核CPU的出现，单线程限制了计算机算力的发挥。 作用Web worker的存在，为JavaScript提供了多线程的运行环境，允许主线程创建worker线程，并将一些任务分配给后者。在主线程运行的同时，worker线程在后台运行，二者互不干扰。等到Worker线程完成运算后，再将运算结果返回给主线程。 优势：计算密集型或者高延迟的任务由Worker来进行，不会给主线程(负责UI与交互)造成负担(阻塞或者拖慢)，增强用户体验。 缺点：Worker线程一旦创建成果，就会始终运行，不会被主线程的交互打断。这样有利于随时相应主线程的通信，但是也会浪费一定的资源，不应被过度使用。而且，一旦使用完毕，就应该尽快关闭它。 特点 同源限制 分配给Worker线程执行的脚本文件，必须与主线程的脚本同源。 DOM限制 Worker线程所在的全局对象，与主线程不同，无法读取主线程所在网页上的DOM对象。也无法使用window，document，parent这些对象。但是Worker线程可以使用Navigator和Location对象。 通信联系 Worker线程与主线程不在同一个上下文环境，它们之间不能直接通信，必须通过消息来完成。 脚本显示 Worker线程不能执行alert()和confirm()方法，但可以使用XMLHTTPRequest对象来完成Ajax请求。 文件限制 Worker线程无法读取本地文件，也就是说它无法打开本机的文件系统(file://)，它加载的脚本，必须来自于网络。 用法主线程创建主线程中采用Worker构造函数来新建Worker进程，它接收一个参数，就是脚本文件(且只能加载js脚本，否则报错)，即是Worker线程即将执行的任务。这个文件必须来自网络。如果加载不成功，它会静默失败。 1var worker = new Worker('worker.js'); 第二个参数是可选项，用于配置，比如name属性可以用来自定义worker的名字，可在worker内使用self.name访问到。 发送消息然后主线程调用worker.postMessage()方法给Worker进程发送消息。 12345worker.postMessage('Hello world');worker.postMessage(&#123; method: 'echo', args: ['work']&#125;); worker可以接收包括二进制在内的各种数据类型的消息内容。 接收消息主线程可以通过worker.onmessage()来指定监听函数，接收Worker线程发送回来的消息。 123456789worker.onmessage = function (event) &#123; console.log('Received message ' + event.data); doSomething();&#125;;function doSomething () &#123; // 执行任务 worker.postMessage('Work done!');&#125; Worker线程发送给主线程的数据被保存在事件对象event的data字段上。 关闭WorkerWorker线程任务完成后，主线程就可以把它关掉。 1worker.terminate(); 错误监听123456789worker.onerror(function (err) &#123; console.log([ 'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message ].join(''));&#125;);worker.addEventListner('error', function (evt) &#123; // doSomething&#125;, !1); Worker线程 Worker的内部可以再新建worker 消息处理Worker线程内部需要有一个事件监听函数，来监听message事件。 123self.addEventListener('message', function (e) &#123; self.postMessage('You said ' + e.data);&#125;, !1); 代码中self代表Worker线程自身，即子线程的全局对象。也可以写作this或者省略。 也可以直接使用self.onmessage来指定事件监听函数。 根据主线程发来的数据的不同，Worker线程可以执行不同的任务来调用不同的方法： 1234567891011121314self.addEventListener('message', function (e) &#123; var data = e.data; switch (data.cmd) &#123; case 'start': self.postMessage('WORKER SATRTED' + data.msg); break; case 'stop': self.postMessage('WORKER STOPED' + data.msg); self.close(); // Terminates worker break; default: self.postMessage('Unknown CMD' + data.msg); &#125;&#125;, !1); self.close()用于在Worker线程内关闭自身。 加载脚本Worker线程内部如果要加载其他脚本，有一个专门的方法importScripts。 12345// 加载单个脚本importScripts('worker1.js');// 加载多个脚本importScripts('worker1.js', 'worker2.js'); 错误监听在Worker线程内部可以监听error事件，来捕获其内发生的错误。 同页面的Worker通常情况下，我们会将Worker线程的代码写入一个单独的JavaScript文件中，但是我们也可以载入和主线程在同一个网页的代码。 123456789&lt;!DOCTYPE html&gt; &lt;body&gt; &lt;script id="worker" type="app/worker"&gt; addEventListener('message', function () &#123; postMessage('some message'); &#125;, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意需要将Script标签的type值设置为浏览器无法识别的一个值。 再读取这段脚本，用Worker来处理。 先将嵌入网页的脚本代码，转换成一个二进制对象，然后为这个二进制对象生成了URL，再让Worker加载这个URL。 1234567var blob = new Blob([document.querySelector('#worker').textContent]);var url = window.URL.createObjectURL(blob);var worker = new Worker(url);worker.onmessage = function (e) &#123; // e.data === 'some message'&#125;; 参考资料Web Worker 使用教程]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门之镜像]]></title>
    <url>%2Fdocker-image%2F</url>
    <content type="text"><![CDATA[Docker从入门到实践，第二小节，学习Docker三大组件之一镜像的基本操作。 简介镜像(Images)是Docker中极为重要的一个组件，它是虚拟化容器运行所依赖的基础。 我们需要熟悉Docker镜像再以下环境下的使用： 从仓库获取镜像 管理本地主机上的镜像 发布镜像到仓库 同时，我们需要了解镜像实现的基本原理。 获取镜像获取镜像需要使用docker pull命令。 我们在学习Docker时，可以使用docker [command_name] -h命令来查看命令的简单介绍文档。 Docker pull命令格式如下： 1$ docker pull &lt;...args&gt; &lt;docker registry 地址&gt;[:port/]repo_name&lt;:tag_name&gt; Docker registry地址代表配置的docker仓库的地址，配置过程可参考上一篇博客。默认的仓库地址是Docker Hub。 repo_name代表仓库名。格式为username/software，对于Docker hub来说，如果未指定用户名，那么默认将从用户名为library的用户名下下载软件。 例如： 1$ docker pull ubuntu:16.04 管理本机镜像]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的Docker入门]]></title>
    <url>%2Fdocker-abc%2F</url>
    <content type="text"><![CDATA[Mac系统下的Docker从安装到简单实践。 为什么选择Docker？Docker🐳是一款使用Go语言开发的基于容器的虚拟化环境管理软件，它是当前最为流行的Linux容器解决方案。 Docker可以将程序和程序的配置依赖等文件打包到一个文件内，运行这个文件，会生成一个虚拟容器，程序将会在这个虚拟容器中执行。 通过Docker，用户可以方便地创建和使用容器，将自己的应用程序放到容器中运行，容器还可以进行版本控制、复制、修改、分享等操作。 与传统的虚拟化方式相比，Docker的兴起和流行得益于它如下的优势： 更高效地利用系统资源 更快速的启动时间 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护和扩展 它非常适合开发，运维，测试，架构师等人员进行学习。 Mac OS安装Docker 以后可能我写博客，安装软件都只会记录Mac上的安装途径了，毕竟Mac更适合搞开发。(Linux也是) 命令行安装使用Homebrew cask来安装Docker。 确保已经安装了Homebrew cask。 1$ brew cask install docker 官网下载安装包Docker for Mac 戳上面的链接即可下载Docker for Mac，需要Mac OS版本为10.10.3以上。 下载到.dmg文件后双击打开，再将可爱的Docker 小鲸鱼拖动到Application图标里即安装成功。 其余系统安装Docker 请登录Docker官网进行下载安装。 注册Docker ID安装成功打开应用，即可在Mac右上角生成一个小鲸鱼🐳图标，点击需要使用Docker ID登录，点击注册地址即可跳转至官方注册界面。注意填写好邮箱地址，需要进入邮箱确认注册后账号才可使用。 安装成功测试可使用以下的命令来测试是否Docker已被成功安装。 12345678➜ ~ docker --versionDocker version 18.03.1-ce, build 9ee9f40➜ ~ docker-compose --versiondocker-compose version 1.21.1, build 5a3f1a3➜ ~ docker-machine --versiondocker-machine version 0.14.0, build 89b8332 安装正确，会返回当前的版本号。 配置镜像加速服务因为某些不可抗力因素，在国内直接从Docker Hub上拉取镜像的速度非常缓慢，所以为了方便使用，建议根据需求配置使用国内的镜像加速服务。 Mac OS系统可以通过以下几个步骤来设置使用镜像： 任务栏点击小鲸鱼图标🐳 选择Preference…选项 选择Daemon选项 选择Registry mirrors 在列表中输入https://registry.docker-cn.com 点击Apply &amp; Start按钮 三大概念学习Docker要理解以下3个概念。 镜像 Image 容器 Container 仓库 Registry Docker命令基本都是针对这三者进行各种操作，操作镜像、操作容器或者是操作仓库。 简单实践官方hello-world镜像下载使用docker pull命令下载镜像。 1234567$ docker pull hello-worldUsing default tag: latestlatest: Pulling from library/hello-world9bb5a5d4561a: Pull completeDigest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77Status: Downloaded newer image for hello-world:latest 默认从官方仓库下载镜像的latest版本，默认用户名为library。 运行使用docker run命令生成容器并运行。 12345678910111213141516171819202122➜ ~ docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ Nginx镜像简单实践拉取官方nginx镜像并启动12345678910➜ ~ docker run -d -p 80:80 --name webserver nginxUnable to find image 'nginx:latest' locallylatest: Pulling from library/nginxf2aa67a397c4: Pull complete3c091c23e29d: Pull complete4a99993b8636: Pull completeDigest: sha256:0fb320e2a1b1620b4905facb3447e3d84ad36da0b2c8aa8fe3a5a81d1187b884Status: Downloaded newer image for nginx:latest2ebaa72c4fd442b1ffe249010b3231326fe17271c2eb5f10442221c4c82ae2dd -d参数代表后台运行容器，-p用于指定端口映射，--name用于设置容器别名。 浏览器检测是否运行成功打开浏览器输入访问localhost，如果看到Nginx服务器的欢迎页，则运行成功。 停用服务及删除 运行操作将镜像运行生成容器。 123$ docker stop/kill webserver$ docker rm webserver 上述操作，可以使用容器名进行操作，也可以使用容器id。 参考资料Docker — 从入门到实践]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch API学习笔记]]></title>
    <url>%2Ffetch-api%2F</url>
    <content type="text"><![CDATA[Fetch API是新一代用于进行HTTP请求的JavaScript接口。它提供了一个全局的fetch()方法，该方法使用简单，可用于跨网络异步获取资源。 对比与XMLHTTPRequest对象提供的数据请求相比，fetch API使用方式更加简单，API更易理解且方便被其它技术使用。 与$.ajax()相比： 当接收到一个代表错误的HTTP状态码时，fetch()返回的Promise不会被标记为reject，即使HTTP响应的状态码为404或者500。相反，它会将Promise的状态标记为resolve(但是会将resolve返回的ok属性设置为false)，仅当网络故障或者请求被阻止时，才会调用reject回调方法。 默认情况下，fetch()不会从服务端发送或者接收任何cookies，如果站点依赖于用于session，则会导致为经认证的请求。(要发送cookies，必须设置credentials选项)。 请求fetch请求的使用非常简单。例如： 1234567891011121314fetch('https://api.github.com/search/repositories?q=javascript&amp;sort=stars') .then(res =&gt; res.json()) .then(data =&gt; &#123; console.log(data); &#125;);fetch('https://api.github.com/search/repositories', &#123; q: 'javascript', sort: 'stars'&#125;) .then(res =&gt; res.json()) .then(data =&gt; &#123; console.log(data); &#125;); Fetch()方法会返回一个Promise实例。 将上面的例子粘贴到Chrome浏览器控制台运行，就可以看到请求的结果。 该例子通过一个参数来指定fetch()的路径，然后返回一个包含响应结果的Promise对象。 当然HTTP请求默认返回的格式并不是真正的Json。我们在已知返回格式的情况下，可以使用json()方法，将返回结果转换为对象格式。 其余支持的格式： arrayBuffer() blob() json() text() formData() 上述方法同样会返回一个被解析的Promise对象和数据。 特性检测 检测当前环境是否支持fetch API，可以通过检测Window对象上是否有Headers，Request，Response或者fetch。 例如： 12345if (this.fetch) &#123; // Fetch request is supported&#125; else &#123; // Oops, it seems you need XMLHTTPRequest&#125; Polyfill要在不支持的浏览器中使用Fetch，可以使用Fetch Polyfill。 浏览器兼容性**** 非IE浏览器 参考资料MDN-Fectch API]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是如何使用Sublime的]]></title>
    <url>%2Fmy-sublime-config%2F</url>
    <content type="text"><![CDATA[我的个人Sublime插件配置，编辑器美化和踩坑记录等。 不定期持续更新，方便设备后重装环境，与再踩坑。 SublimeSublime是一款简洁轻量的代码编辑器。它有着丰富易用的插件可以根据自身的开发需求进行订制扩展。 在我尝试了Atom，VSCode，WebStorm后，我确认它----Sublime是我最喜欢的一款编辑器。 版本 我当前使用的版本是Version 3.1.1 Build 3176。 插件我个人从事Web前端开发工作，目前使用的插件有： 以下用无关和相关来区分，插件是否大程度针对前端开发工作。 无关Package Control必备插件，方便搜索，快捷安装其余插件的基础。 安装方法：1. 使用快捷键`Ctrl + \``或者点击菜单`View - Show Console`打开控制台。 2. 复制粘贴下面的安装代码到控制台。 3. 回车，等待安装完成。1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 使用方法使用Ctrl + Shift + P打开命令面板，输入Package Control就可以看到下面列表内补全的各种与Package Control相关的功能。 如： Install Package 打开搜索下载插件功能 List Packages 列出已安装插件 Remove Packages 移除插件 Upgrade Package 升级插件 Disable Package 暂时停用插件功能 … 相关链接Package Control官网 Package Control Github仓库 A File Icon使用Package Control下载即可。 给编辑器侧栏的文件目录树添加图标。 效果入下图： AutoFileName引用文件名路径及文件名自动补全插件。 方便在比如CSS，JS中用相对路径，沿着目录树引用文件。 EditorConfig格式化编辑器配置插件，适合团队开发统一代码风格等。 在各种编辑器上都有相关的插件实现。 我的常用配置： 12345678910# .editorconfig 文件名root = true # 不再向上寻找.editorconfig文件[*] # 对所有文件生效charset = utf-8 # 使用utf-8字符集indent_style = space # 使用空格做代码缩进indent_size = 2 # 空格个数为2个end_of_line = lf # 使用UNIX的lf换行符insert_final_newline = true # 在文件最后插入一个空行trim_trailing_whitespace = true # 移除代码行末无用的空格 Sidebar Enhencement侧栏功能增强插件。 可根据需求配置侧栏功能，让侧栏更加强大。 如下图： 相关踩坑字体渲染混乱，文字竖直方向不对齐。效果如下图所示： 经过查询发现是默认的编辑器设置font-face为空，需要给其设定一个字体。 在看了大家的推荐后，我选择了Consolas-with-Yahei。同时支持等宽的代码常用字体Consolas和微软雅黑。 从Github下载后，双击打开字体，再点击安装等待安装完成即可。 再在编辑器设置里设置font-face字段为Consolas-with-Yahei。 OK，大功告成！ 看看新的渲染效果，比先前看起来舒服多了。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中的Vuejs项目开发实践]]></title>
    <url>%2Fthinking-in-vuejs-project%2F</url>
    <content type="text"><![CDATA[记录一下对最近正在做的Vuejs框架的项目的思考、实践过程中踩的坑和学习到的东西。 背景上周起，公司开启了一个新的项目。 将早先使用传统的基于jQuery的多页面架构的一个演示系统利用Vuejs框架以SPA的架构来进行重构（重写？）。 整个系统利用jQuery实现时大概有近30个页面，不过页面主要以数据展现为主，只有少部分页面才有着交互功能。 因为公司目前从事前端工作的就我一个人，所以这个项目暂定由我一个人来完成前端方面的工作。 后端API方面，因为系统使用的是第三方提供的数据API，所以只是由公司的PHP和JAVA后端同事对三方API进行封装和简单加工，比如排序、过滤、适配数据格式和计算出前端能直接展现的数据，方便我这边调用。 项目上面，别人先提供了一个早先完成了一小部分的项目模板，可以复用一部分通用组件和项目架构，不过同时也限制了一些项目依赖的版本。 毕竟我并没有过使用Vue进行工作中的项目开发的经验，提供的模板也在一定程度上给我提供了一个项目架构，否则的话我只能去Github上面Down一个来参考着开发了。 不过在实际使用中，我也根据自己的需求和社区推荐的最佳实践来对早先的项目模板进行了重构，来适应自己的开发习惯。 工期暂定为65天左右（不包括周末），目前已经过去了一周。 我个人对本次Vuejs框架的项目是十分期待的，毕竟先前的工作没有做过这方面的，想积累一些使用框架和UI库来进行开发的经验。 之前的工作样式方面都以手写样式为主。 毕竟只有简单利用开发过个人小项目的经验----先前使用Vuejs框架简单实现过知乎日报，可想而知本次开发过程中会遇到很多坑点，所以我决定将本次开发经历详细地记录到此篇博文里。 顺便最近利用下班时间一直在看一本书&lt;&lt;Vue.js前端开发快速入门与专业应用&gt;&gt;，希望能对开发过程有所帮助。 技术栈关于技术栈这方面，并没有什么规定，Vuejs全家桶是少不了的。 项目使用Vue-cli的Webpack模板进行创建，所有项目打包工具也自然而然地使用了Webpack。 因为有先前实现过几个页面的Demo，封装的一部分组件是基于Element-UI的，而且Element-UI也是Vuejs实现后端系统大家都在使用的UI库，所以UI库仍然使用Element-UI。 代码风格检查使用了ESLint，它也是Vuejs官方推荐的代码风格检查工具，而且它是完全可配置的。代码风格的规定继承了Standard规范（Vue-cli创建项目时可选），然后再根据自身代码风格对部分规则进行了覆盖和重写。 数据请求方面，早先的Demo使用了whatwg-fetch模块来直接封装Common-Query API，因为我使用的是后端二次封装后的API，所以将数据请求使用的模块改为了Vuejs官方推荐的Axios并且引入了qs模块来发送POST请求。 动画方面虽然页面以数据展示为主，设计的动画也并不多，不过为了增强用户体验，仍然引入了动画库Animate.css。 时间格式化方面使用了Moment模块。 接口返回的数据处理方面，根据需求来按需引入lodash模块。 CSS预处理器方面，因为提供的组件使用了Sass，所以我这边也仍然使用它。 以上各种模块的对应版本如下表： 模块名 版本号 vue v2.5.2 vue-router v2.6.0 vuex v2.3.1 axios v0.18.0 element-ui v1.4.13 animate.css v3.6.1 lodash v4.17.10 moment v2.22.1 qs v6.5.2 项目创建项目使用Yarn来进行依赖包的下载和管理，使用Vue-cli进行项目创建。 使用Vue-cli创建项目，使用vue-router，使用eslint，不使用单元测试和端对端测试。 打开./config/index.js，修改autoOpenBrowser为true，修改notifyOnErrors为false（这个功能太烦人了。） 运行项目 1$ yarn dev 项目目录虽然有先前实现过部分页面的Demo，不过整个项目仍然是我从零开始创建的，毕竟自己走一遍流程，会更加熟悉项目的结构。 项目文件目录如下： 1234567891011121314151617181920212223242526272829project│ ├─build # Vuejs的webpack打包运行脚本│ ├─config # Vuejs的webpack打包配置脚本│ ├─node_modules # 项目依赖 npm包│ └─src # 项目主要源码| ├─assets # 项目图标，页面背景图等资源。| ├─components # 封装的可复用的功能性组件 根据业务对Element-UI进行二次封装。| ├─constants # 项目配置文件，常量，方便修改。如项目名，系统页面目录，i18n多语言支持等。| ├─pages # 以页面为结构切分的vue组件 对应不同的路由。| ├─router # 路由文件| ├─services # API服务封装| ├─store # 状态管理| ├─utils # 通用方法封装| ├─App.vue # 项目根组件| ├─main.js # Webpack打包入口文件，连接其他文件| └─style.scss # App.vue的样式文件，可以用style标签写入App.vue。|│ ├─static # 项目用到的静态资源 不常迭代的三方资源 │ ├─theme # Element-UI官方下载的组件自定义主题样式css文件│ ├─.babelrc # Babel转译工具配置│ ├─.editorconfig # 编辑器规范配置│ ├─.eslintignore # 不进行ESLint检查的文件和目录配置│ ├─.eslintrcjs # ESLint检查规则配置│ ├─.gitignore # 不使用Git追踪的文件配置│ ├─element-variables.css # Element-UI变量│ ├─index.html # 单页应用的模板HTML文件│ ├─package.json # Node项目的包管理等信息│ ├─README.md # 项目说明文件│ └─yarn.lock # Yarn包管理生成的包版本文件 配置ESLint因为提供的Demo和组件的代码风格和我有很大的不同，而接下来的开发周期很可能只会是我一个人参与，所以我根据自己的代码风格重新配置了ESLint。 忽略对提供文件的代码检查在./eslintignore文件中添加src/components/*忽略对所有提供组件的代码风格检查。 根据需要配置新的检查规则新的代码风格检查规则如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243// https://eslint.org/docs/user-guide/configuringmodule.exports = &#123; root: true, // 不再向上搜索配置文件 parserOptions: &#123; parser: 'babel-eslint' &#125;, env: &#123; browser: true, // 代码运行在浏览器端 &#125;, extends: [ // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules. 'plugin:vue/essential', // 继承Vue推荐代码风格 // https://github.com/standard/standard/blob/master/docs/RULES-en.md 'standard' // 继承standard代码风格 ], // required to lint *.vue files plugins: [ 'vue' ], // add your custom rules here rules: &#123; 'generator-star-spacing': 0, // allow async-await 'semi': [2, 'always'], // 必须使用分号，且正确使用 'semi-spacing': 0, // 强制分号之前和之后使用一致的空格 'one-var': [2, &#123; // 变量连续声明 var: 'always', let: 'always', const: 'never' &#125;], 'indent': [2, 2, &#123; VariableDeclarator: 2/*, // 多行变量连续声明变量名缩进对齐 MemberExpression: 2*/ &#125;], 'padded-blocks': [0, 'always'], // 关闭块作用域填充空行 'comma-dangle': [2, 'never'], // 禁止对象后出现无用的逗号 'no-multi-spaces': 2, // 禁止使用多个空格 'no-void': 0, // 关闭禁用Void // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off' // 无调试信息 &#125;&#125;; 配置Babel为了优化打包后体积，我们采取按需加载Element-UI的方式(需要使用babel-plugin-component插件)，所以需要在.babelrc文件中进行相关的配置。 最终配置文件如下所示： 123456789101112131415161718192021&#123; "presets": [ ["env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125; &#125;], "stage-2" ], "plugins": [ "transform-vue-jsx", "transform-runtime", ["component", [ &#123; "libraryName": "element-ui", "styleLibraryName": "~theme" &#125; ]] ]&#125; 引入Babel-polifillVuejs中的.babelrc中引用了babel-plugin-transform-runtime这个插件来帮助转译ES6方法。虽然这个插件已经足以在大多情况下，满足我们转译ES版本的需求。但同时，它仍然存在着2个问题： 异步加载组件的时候，会产生polyfill的代码冗余 不支持对全局函数和实例方法的polyfill 它无法转译例如Promise，Set，Map这样的ES6新引入的全局函数，尤其是不支持转译Promise，对代码兼容性有很大的影响。 同时，它不支持大多数组、字符串、对象等ES6新添加的实例方法。 替换步骤如下: 卸载依赖babel-plugin-transform-runtime 修改.babelrc文件，删除transform-runtime 在入口文件最前面(main.js)用代码import &#39;babel-polyfill&#39;来引入 踩坑记录无法修改UI库组件样式.vue文件中的style标签如果被设置了scoped属性，那么最终会在编译生成的css上加上一个哈希值，那么这个新的选择器就无法选择到Ui库的样式。 所以要覆盖UI库的样式，就不能给组件加scoped属性。这时候我们可以使用BEM命名法来防止样式冲突。 给元素绑定行内样式使用v-bind:style如下形式来绑定行内样式： 1&lt;foo-bar :style="&#123; width: value &#125;" /&gt; 如果有多条样式，建议以对象的方式传入 异步更新组件内容无法触发视图更新原因，组件在异步更新之前已经渲染，这时候父子组件间还没有通过props来进行传值。然后在created mounted 的生命周期函数内，会使用默认值来进行渲染。 解决方法： 在需要异步更新的组件上增加v-if属性，通过在异步操作结束后更新标志位的方式来触发组件更新。 使用watch功能，监听props传入的数据，手动更新，覆盖当前data返回的数据，触发视图更新。 路由访问组件内访问当前路由使用this.$route。 组件内调用路由的方法使用this.$router。 渲染样式完全不同的列表在v-for内部使用template内置组件，在上面使用v-if，v-else等逻辑，来进行条件渲染。 当组件挂载到DOM上时候，template标签会自动移除。 123456789101112131415161718192021&lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot; :class=&quot;&#123; item1: item.type === 1, item2: item.type === 2, item3: item.type !== 1 &amp;&amp; item.type !== 2 &#125;&quot; &gt; &lt;template v-if=&quot;item.type === 1&quot;&gt; &lt;section&gt;1&lt;/section&gt; &lt;/template&gt; &lt;template v-else-if=&quot;item.type === 2&quot;&gt; &lt;section&gt;2&lt;/section&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;section&gt;3&lt;/section&gt; &lt;/template&gt; &lt;/li&gt;&lt;/ul&gt; UI库组件绑定的事件无法触发。原因： Vue2.0开始，为自定义组件绑定原生事件必须使用.native修饰符。 1&lt;my-component @click.native=&quot;handleClick&quot;&gt;Click Me&lt;/my-component&gt; Element-ui-FAQ 打包后样式丢失开发时候使用了-webkit-box-orient: vertical;来控制文本多行溢出隐藏。 但是经过webpack打包后部署到线上发现该条样式丢失了，查询资料后发现是被autoprefixer移除了。 解决方式1：在该条样式前后分别加上/*! autoprefixer: off */和/*! autoprefixer: on */来跳过对该条样式的处理，但在开发过程中，却会报一堆警告。 解决方式2： 编辑package.json文件内的browserlist字段，在其中添加Safari 6，打包后即可正常。 Axios的POST请求无法发送数据。因为axios会对post的参数进行处理，所以根据查询到的资料，使用了qs库。 但是今天重新装了一遍依赖后，axios的请求不再发送数据，反而注释掉了有关qs库的使用后正常了。 可能原因：先前我的yarn.lock文件保存到所有包的仓库都是yarn的官方仓库下载的，前两天我将仓库默认地址切换到了淘宝的地址，所以应该lock文件也无法保证下载的依赖是完全相同的了。 使用Element-UI封装的地域联动选择插件无法绑定初始值。项目中，有个配置页面，支持2种操作。 创建一条配置，默认地域选择为全部。 更新某条配置，需要绑定先前设置的地域配置。 在开发种选择了使用Element-UI的Select组件进行封装，来实现地域选择的二级联动效果。 使用HTTP请求，读取地域数据(Json)。再迭代数据，获取到所有的省份，绑定给省级区域下拉列表，再根据省级区域的选择结果读取对应的市级地域数据，渲染出市级区域下拉列表供用户选择。 但在更新值的时候，发现一次请求得到的地域信息值，无法同时将省级区域和市级区域绑定到二级地域联动选择上。 思考：个人觉得可行的办法是，在初次未进行选择的时候，市级区域，默认可供选择的区域数据为所有的市级区域。(数据量过大) 最终商量后，解决方案修改为使用Element-UI的Cascade插件来实现二级地域联动效果。这个组件本身便是支持级联选择的，同时可以给组件绑定默认值。 前端返回需要图片，后端数据返回无图片。首次在Vue项目中遇到这样的问题。 从设计的角度来说，列表内的新闻项都应该有新闻相关图片，但是三方API有时候并不能提供图片，新闻项的图片字段为null。 那么，首先想到的解决方案就是，在图片加载失败的时候，选择展现默认图片，并将其地址赋值给图片的src属性，再将这个错误事件清除掉，避免多次触发。实现如下： 1&lt;img :src="images.jpg" onerror="this.src='path_to_the_pic/pic.jpg'; this.onerror=null;" /&gt; 但在实际应用中，发现如何设置图片地址是个问题。 因为vue项目在经过webpack打包后，会将相关静态文件打包到static目录下，并且给文件加上哈希值。 经过查询资料后，知道了应该让webpack处理这个图片，那么打包后的引用关系就能正常。 实现方法就是:onerror=&quot;this.src=&#39; &quot; + require(&#39;@/assets/default.png&#39;) + &quot;&#39;&quot;，使用require方法引入图片。 但是默认图片仍然无法正常展示。 开始，我怀疑是因为单双引号的问题，导致内联js代码无法正常执行。 后来，经过多次替换括号类型等，发现并不能实际解决问题。 仔细研究良久后恍然大悟，因为使用v-bind给图片绑定src属性，但是绑定的内容为null，所以图片根本不会发起资源请求，那么也便不存在失败一说，继而无法触发onerror事件。 解决：在项目的Store文件夹下的modules中，寻找对应的JS模块。 将图片通过webpack处理，获取处理后的图片引用地址。 使用map方法，改变actions里，判断新闻项的图片字段是否为空，若为空将其修改为默认的图片链接。 vm.$nextTick使用将回调延迟到下次DOM更新循环完成之后执行，在修改数据后立即使用它，然后等待DOM更新。 与全局的Vue.nextTick不同的是，它的回调函数的this自动绑定为调用它的组件实例。 应用场景 在Vue的created生命周期中进行DOM操作，一定要放到vm.$nextTick的回调中。因为此时DOM可能尚未渲染。而mounted生命周期函数中DOM已经挂载，就不存在此问题。 在数据变化后要执行某个操作，而这个操作需要使用随数据改变而改变的DOM时，这个操作需要放入vm.$nextTick的回调函数中。 123456const _this = this;_this.$nextTick(() =&gt; &#123; // do something &#125;); 路由按需加载将路由按需加载可以减少首屏体积，提升首屏加载效率，增强用户体验。 12345678// 普通的加载方式import vHome from './v-home';// 老版本Api webpack按需加载 已不建议使用const vHome = r =&gt; require.ensure([], () =&gt; r(require('./v-home')));// 动态import组件const Foo = () =&gt; import('./Foo.vue'); 多行文本框内容间插入符号且维持光标位置实现方式，见下面的DEMO。 Vue多行文本框插入内容保留光标位置DEMO 未完待续]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不止是RGB，学习HSL颜色]]></title>
    <url>%2Fhsl-color-abc%2F</url>
    <content type="text"><![CDATA[除了RGB外，颜色也可以使用 hsl() 函数符被定义为色相-饱和度-明度（Hue-saturation-lightness）模式。 背景日常写样式代码时，常用的颜色表示方式有以下几种： 颜色关键字颜色关键字表示法通过英文单词来表示对应颜色，这些颜色通过关键词定义便于记忆和快速使用。 但是这些颜色大多为不带透明度的颜色（关键字transparent除外，它代表的颜色是rgba(0, 0, 0, 0)）。 例如： 关键字 对应颜色 black #000 white #fff red #f00 yellow #ff0 blue #00f pink #ffc0cb indigo #cb0082 grey #808080 green #008000 tranparent rgba(0, 0, 0, 0) 详细CSS颜色值列表 十六进制表示法十六进制表示法的基本语法是#XXXXXX，其中X代表一个0-F的数字(16进制)。 它也不支持颜色透明度的设定(在CSS里)。 如果在CSS中使用时，十六进制中a-f大小写都可以支持。 不过最佳实践建议适用小写字母来表示颜色。并且如果颜色格式为#aabbcc建议缩写为#abc。 RGB与RGBA表示法RGB与RGBA是CSS里定义好的用于表示颜色的内置函数，后者相比于前者多了一个用于表示透明度的参数。 R-G-B分别表示Red，Green，Blue。这三位的取值范围都为0-255或者0%-100%，100%与255表示的意义相同，都为FF。有两点需要注意： 不能接受小数作为参数。 整数与百分数的形式不可混用。 Alpha透明度值的取值范围为0-1，可以设置这个范围内的任意小数，并且在小数以0开始的时候可以省略0。 如rgba(255, 0, 0, .35)。 HSL与HSLA表示法HSL和HSLA是CSS定义的另外2种表示颜色的内置函数，后者比前者多的仍然是用于表示透明度的参数，且取值范围同上。 HSL分别代表Hue（色相），Saturation（饱和度），Lightness（明度）。分别代表的意义: 色相 表示颜色在色环上的角度。用一个无单位的整数来表示。并且0=360=red，其它颜色在色环上均匀分布。所以green=120，blue=240。 饱和度 表示颜色的饱和程度。 用一个百分数来表示。100%代表满饱和度，0%代表一种灰度。一般颜色设置为满饱和度。 明度 表示颜色的明亮程度。 用一个百分数来表示。 100%代表白色，0%代表一种黑色。50%的明度是一般的(常见颜色的明度)。 所以常用的颜色用HSL表示法为hsl(0, 100%, 50%)（表示红色，#f00）。而减小明度，表示深色，增大明度表示浅色。如： 12color: hsl(0, 100%, 25%); /* 深红 */color: hsl(0, 100%, 75%); /* 浅红 */ 优点： HSL颜色表示法在同种颜色间调整是线性可控的，比如我要将深绿色调整为浅绿色，只需要对应地调整其明度就可以。在一些特殊的场景里，这种颜色的表示方法更方便使用。 举例： 你是色盲吗小游戏，需要生成随机颜色的对应的颜色相近但是不同的颜色。 动画里的颜色调整。 兼容性IE9+ 详情见Can I Use 参考文档MDN-颜色]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webpack打包你的代码]]></title>
    <url>%2Fbundle-your-codes-via-webpack%2F</url>
    <content type="text"><![CDATA[Webpack是目前最流行的代码打包工具，大部分命令行打包工具都有借鉴Webpack的设计思想，三大框架都选用Webpack作为推荐的打包工具，大量开源项目也使用它来进行打包，所以学会如何使用它很有必要。 背景本篇博文是承接先前的一篇博文webpack入门学习-基础篇的入门到进阶层次的文章。文章的核心还是关于如何配置和使用Webpack。并未涵盖Webpack的大部分高级特性。 目前 Webpack的最新版本为v4.7.0。 不过从4.x.x版本开始，为了改善大型项目Webpack配置困难的痛点，Webpack开始走部分技术推崇的约定大于配置的路线，而现有的比如Vue之类项目脚手架的webpack工具，仍然依赖的是3.x.x的版本。 所以本篇文章使用的webpack版本为3.6.0。 下载可以通过如下的方式来下载Webpack作为项目开发依赖： 开发依赖的包的信息，会保存在package.json文件的devDependencies字段里。 12345# NPM$ npm install webpack@^3.6.0 --save--dev # npm i webpack@^3.6.0 -D# Yarn$ yarn add webpack@^3.6.0 --dev 查看当前Webpack依赖版本 1234$ .\node_modules\.bin\webpack -v# Output3.6.0 # 正确输出了版本 Webpack Github Repo Webpack Github仓库 Webpack Official Website Webpack官方网站 使用 Webpack需要通过命令行工具(Shell)来进行使用。 查看webpack命令行参数可以看到webpack支持的参数十分丰富，具体参数用法可以参考官方文档。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143$ .\node_modules\.bim\webpack --help# 输出结果Hash: 91e97ca469d808640ddbVersion: webpack 3.6.0Time: 52ms Asset Size Chunks Chunk Namesbundle.js 2.57 kB 0 [emitted] main [0] ./src/js/main.js 101 bytes &#123;0&#125; [built]PS C:\Users\M S I\Desktop\webpack-demo&gt; .\node_modules\.bin\webpackNo configuration file found and no output filename configured via CLI option.A configuration file could be named 'webpack.config.js' in the current directory.Use --help to display the CLI options.PS C:\Users\M S I\Desktop\webpack-demo&gt; .\node_modules\.bin\webpack --helpwebpack 3.6.0Usage: https://webpack.js.org/api/cli/Usage without config file: webpack &lt;entry&gt; [&lt;entry&gt;] &lt;output&gt;Usage with config file: webpackConfig options: --config Path to the config file [string] [default: webpack.config.js or webpackfile.js] --config-name Name of the config to use [string] --env Environment passed to the config, when it is a functionBasic options: --context The root directory for resolving entry point and stats [string] [default: The current directory] --entry The entry point [string] --watch, -w Watch the filesystem for changes [boolean] --debug Switch loaders to debug mode [boolean] --devtool Enable devtool for better debugging experience (Example: --devtool eval-cheap-module-source-map) [string] -d shortcut for --debug --devtool eval-cheap-module-source-map --output-pathinfo [boolean] -p shortcut for --optimize-minimize --define process.env.NODE_ENV="production" [boolean] --progress Print compilation progress in percentage [boolean]Module options: --module-bind Bind an extension to a loader [string] --module-bind-post [string] --module-bind-pre [string]Output options: --output-path The output path for compilation assets [string] [default: The current directory] --output-filename The output filename of the bundle [string] [default: [name].js] --output-chunk-filename The output filename for additional chunks [string] [default: filename with [id] instead of [name] or [id] prefixed] --output-source-map-filename The output filename for the SourceMap [string] --output-public-path The public path for the assets [string] --output-jsonp-function The name of the jsonp function used for chunk loading [string] --output-pathinfo Include a comment with the request for every dependency (require, import, etc.) [boolean] --output-library Expose the exports of the entry point as library [string] --output-library-target The type for exposing the exports of the entry point as library [string]Advanced options: --records-input-path Path to the records file (reading) [string] --records-output-path Path to the records file (writing) [string] --records-path Path to the records file [string] --define Define any free var in the bundle [string] --target The targeted execution environment [string] --cache Enable in memory caching [boolean] [default: It's enabled by default when watching] --watch-stdin, --stdin Exit the process when stdin is closed [boolean] --watch-aggregate-timeout Timeout for gathering changes while watching --watch-poll The polling interval for watching (also enable polling) [string] --hot Enables Hot Module Replacement [boolean] --prefetch Prefetch this request (Example: --prefetch ./file.js) [string] --provide Provide these modules as free vars in all modules (Example: --provide jQuery=jquery) [string] --labeled-modules Enables labeled modules [boolean] --plugin Load this plugin [string] --bail Abort the compilation on first error [boolean] [default: null] --profile Profile the compilation and include information in stats [boolean] [default: null]Resolving options: --resolve-alias Setup a module alias for resolving (Example: jquery-plugin=jquery.plugin) [string] --resolve-extensions Setup extensions that should be used to resolve modules (Example: --resolve-extensions .es6,.js) [array] --resolve-loader-alias Setup a loader alias for resolving [string]Optimizing options: --optimize-max-chunks Try to keep the chunk count below a limit --optimize-min-chunk-size Try to keep the chunk size above a limit --optimize-minimize Minimize javascript and switches loaders to minimizing [boolean]Stats options: --color, --colors Enables/Disables colors on the console [boolean] [default: (supports-color)] --sort-modules-by Sorts the modules list by property in module [string] --sort-chunks-by Sorts the chunks list by property in chunk [string] --sort-assets-by Sorts the assets list by property in asset [string] --hide-modules Hides info about modules [boolean] --display-exclude Exclude modules in the output [string] --display-modules Display even excluded modules in the output [boolean] --display-max-modules Sets the maximum number of visible modules in output [number] --display-chunks Display chunks in the output [boolean] --display-entrypoints Display entry points in the output [boolean] --display-origins Display origins of chunks in the output [boolean] --display-cached Display also cached modules in the output [boolean] --display-cached-assets Display also cached assets in the output [boolean] --display-reasons Display reasons about module inclusion in the output [boolean] --display-depth Display distance from entry point for each module [boolean] --display-used-exports Display information about used exports in modules (Tree Shaking) [boolean] --display-provided-exports Display information about exports provided from modules [boolean] --display-optimization-bailout Display information about why optimization bailed out for modules [boolean] --display-error-details Display details about errors [boolean] --display Select display preset (verbose, detailed, normal, minimal, errors-only, none) [string] --verbose Show more details [boolean]Options: --help, -h Show help [boolean] --version, -v Show version number [boolean] --json, -j Prints the result as JSON. [boolean] 打包生成信息每次打包结束后，命令行就会输出如下信息： 123456Hash: 91e97ca469d808640ddb # 此次打包文件(main.js)的哈希值Version: webpack 3.6.0 # 当前webpack的版本Time: 53ms # 打包耗时 Asset Size Chunks Chunk Namesbundle.js 2.57 kB 0 [emitted] main # 打包生成文件名 大小等 [0] ./src/js/main.js 101 bytes &#123;0&#125; [built] # 打包生成的文件目录 及打包成功提示 每次执行打包命令时，如果文件未发生变化，那么打包文件的哈希值是不变的。 命令行工具使用简单打包单个文件1$ .\node_modules\.bin\webpack .\src\js\main.js ./dist/bundle.js 执行程序 .\node_modules.bin\webpack 因为是在命令行执行所以需要加上路径 入口文件 指定一个入口文件，作为要打包的所有资源的注入点。 生成文件 打包生成的最终文件，内部已经实现模块化，可为1个或者多个。 命令行监控文件并打包此种打包模式可以通过在打包命令后添加--watch来实现，避免每次修改源文件后都需要手动执行打包命令。 通过此种方式运行命令后，命令行程序不会主动退出，每次修改源码后，命令行会显示新的打包结果相关信息。 1$ .\node_modules\.bin\webpack .\src\js\main.js ./dist/bundle.js --watch NPM Scripts使用 NPM Scripts是Nodejs为NPM提供的可以运行自定义脚本的一个配置字段。 package.json关键部分如下： 123456&#123; "scripts": &#123; "build": "webpack src/js/main.js dist/bundle.js", "watch": "webpack src/js/main.js dist/bundle.js --watch" &#125;&#125; 要在watch的时候复用build的命令，可以这样实现npm run build -- --watch 项目中使用项目中使用推荐通过编写webpack.config.js的方式与NPM Scripts结合使用。 Webpack会自动尝试加载项目根目录下的webpack.config.js文件，并导入其内配置好的所有配置，来执行打包。 当然我们可以通过--config参数来提供一个别的名字的配置文件。 接下来就记录一下如何进行简单且常用的webpack配置。 配置Webpack 在项目根目录下创建webapck.config.js文件。 webpack.config.js文件需要通过Commonjs规范导出一个JavaScript对象，这个对象将成为webpack的打包配置。 添加环境变量通常情况下，我们需要将开发过程的环境分为： 开发环境 生产环境 测试环境 在不同的环境中，我们通常会对代码的打包有不同的需求。比如在开发调试过程中，未压缩过的代码可读性更好（当然现在有sourceMap）。但是我们会希望开发过程中项目打包时间比较快，我们可能并不需要执行部分工作。而且，可能以上3个环境，我们都会有不止一个。所以，我们希望环境是可以配置的。 实际应用中，我们可以通过在执行打包命令的时候以传入环境变量参数的方式来区分环境。 比如，在开发环境中，我们可以将表示环境的参数设置为development，生产环境设置为production，测试环境设置为test。 因为操作系统的原因，我们需要通过不同的方式来传入参数，比如Mac OS或者Linux中通过NODE_ENV=env_name来实现，而在windows中，则需要通过set NODE_ENV=env_name来实现。 这个差异可以通过cross-env包来消除。 这个对象主要包括了如下字段： Entry文件打包的入口，所有的文件都要直接或间接地在这里产生依赖，才能被webpack程序运行时识别到。 配置示例： 123module.exports = &#123; entry: './path_to_file/entry_name.js'&#125;; 上面的配置会被webpack转化成如下的形式： 12345module.exports = &#123; entry: &#123; main: './path_to_file/entry_name.js' &#125;&#125;; 最终生成的文件名[chunkName]为main 通常我们会将entry配置写为如下的形式: 123456module.exports = &#123; entry: &#123; app: './path_to_file/entry_name.js', vendors: ['module1', 'module2', 'module3'] &#125;&#125;; app用来打包页面的主js文件，它可能会随着产品的迭代经常更改。 vendors用来打包项目依赖，dependencies字段中一些可能长期不变的文件。 优点：可以方便利用文件的强制缓存，加快页面的加载速度，提升用户体验。 参数为数组格式的，会将多个文件打包到一起。 OutputOutput用于告知webpack打包后生成文件的目录，注意只能指定一个输出配置。 要使用此配置，最少需要配置2个属性。 提供一个打包后生成的文件名格式。 提供一个文件生成的绝对路径。 使用如下： 12345678const path = require('path');module.exports = &#123; output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist') &#125;&#125;; 因为要使用绝对路径，所以我们需要引入Node内置的path包。 在配置filename的时候我们可以使用一些模板语法，如[name]， [chunkHash]，[hash]，分别代表： name 指定的输入文件名，打包前的文件名 hash 本次打包的hash值 chunkHash 本文件的hash值，使用chunkHash能利用文件打包的缓存。 Devtool此字段用于配置如何生成sourcemap文件。 可配置参数有none，#cheap-module-eval-source-map等。 详细内容与对比请戳 DevServer用于配置webpack-dev-server插件，常用于开发环境中开启本地开发服务器。 依赖于webpack-dev-server包，需要另外下载： 123$ npm install webpack-dev-server -D$ yarn add webpack-dev-server --dev 此字段配置方式如下： 123456789module.exports = &#123; devServer: &#123; contentBase: './dist/', // 服务器启动根目录 inline: true, open: true, // 自动打开浏览器 hot: true, // 热更新模块 noInfo: true // 隐藏 更新文件时的打包信息 只在保存文件和重新打开时展现 &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ESLint进行JavaScript代码检查。]]></title>
    <url>%2Fuse-eslint-linter-js-code%2F</url>
    <content type="text"><![CDATA[本文旨在记录学习配置和使用ESLint这款代码检查工具。 我们都知道，如何与团队其他人高效地进行协作开发是多人团队的一个痛点。 每个人都有独立的编码习惯，虽然团队可以通过制定强制执行的规范来保持大家代码风格的尽量一致。 但是，在实际编码过程中，个人可能会不经意地继续使用着自己的代码风格，而等到发现不一致再解决又未免有点迟。 而ESLint正是为解决这类问题而生的。 ESLint是一款当前应用十分广泛的JavaScript代码检查工具。本文将从零开始，记录如何从下载配置使用ESLint来进行代码检查工作。 下载源码下载 当前Stable版本是4.19.1，alpha版本5.0.0 Github Repo NPM/Yarn12345# npm$ npm install eslint -g# yarn$ yarn global add eslint 检测是否下载成功 1$ eslint -v # v4.19.1 配置ESLint的一大优点就是它所提供的所有代码检查规则都是可配置的。个人或者团队可以根据需要，切合自身的需求来定制属于自己的代码检查规则。 规则配置ESLint的使用需要通过命令行工具(Shell)。 在使用之前，需要先配置好ESLint的代码检查规则Rules，否则直接使用ESLint检查代码会抛出一个如下的错误。 123ESLint couldn&apos;t find a configuration file. To set up a configuration file for this project, please run: eslint --init 如果我们要使用ESLint来检查自己的日常JavaScript代码，而并非在项目中使用的话，可以使用eslint --init命令来在全局生成一个规则配置文件。 eslint --init命令会以命令行选择交互的方式来生成这个规则文件。在输入命令后，会得到如下的结果： 1234? How would you like to configure ESLint? (Use arrow keys)&gt; Answer questions about your style Use a popular style guide Inspect your JavaScript file(s) Answer questions about your style* 通过回答问题来生成规则文件 Use a popular style guide* 使用已经配置好的流行的规则(别人推荐的最佳实践) Inspect your JavaScript file(s)* 检查现有的JavaScript文件来自动生成 选择选项1后，ESLint会询问你一系列问题，来自动生成规则文件。问题如下： Are you using ECMAScript 6 features? (y/N) Are you using ES6 modules? (y/N) Where will your code run? (Press to select, to toggle all, to inverse selection) Browser Node Do you use CommonJS? (y/N) Do you use JSX? (y/N) What style of indentation do you use? (Use arrow keys) Tabs Spaces What quotes do you use for strings? (Use arrow keys) Double Single What line endings do you use? (Use arrow keys) Unix Windows Do you require semicolons? (Y/n) 选择选项2 后，会让你选择一个规则来源，默认提供3个，分别是Google， Airbnb和Standard，再次进行选择后，会让你选择规则文件的格式，格式可以为3种，分别为JavaScript，YAML和JSON。 3种文件格式分别为： 123&#123; "extends": "airbnb-base"&#125; 1extends: google 123module.exports = &#123; "extends": "standard"&#125;; 以上3个规则库的具体规则条目，可以查看对应的下载得到的node_modules文件里文件。 选择选项3后，会以一些交互式的问题开始，问题包含选择1的前面部分，然后可以选择JavaScript文件或者目录来进行代码风格检测，再根据检测的结果来生成配置文件(包含大量规则)。 通过对我自己的代码风格检测，生成了如下文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289module.exports = &#123; "env": &#123; "browser": true &#125;, "extends": "eslint:recommended", "rules": &#123; "accessor-pairs": "error", "array-bracket-newline": "error", "array-bracket-spacing": "error", "array-callback-return": "error", "array-element-newline": "error", "arrow-body-style": "error", "arrow-parens": "error", "arrow-spacing": "error", "block-scoped-var": "error", "block-spacing": "error", "brace-style": [ "error", "1tbs" ], "callback-return": "error", "camelcase": "error", "capitalized-comments": "error", "class-methods-use-this": "error", "comma-dangle": "error", "comma-spacing": [ "error", &#123; "after": true, "before": false &#125; ], "comma-style": [ "error", "last" ], "complexity": "error", "computed-property-spacing": "error", "consistent-return": "error", "consistent-this": "error", "curly": "error", "default-case": "error", "dot-location": [ "error", "property" ], "dot-notation": "error", "eol-last": [ "error", "never" ], "eqeqeq": "error", "for-direction": "error", "func-call-spacing": "error", "func-name-matching": "error", "func-names": [ "error", "never" ], "func-style": [ "error", "expression" ], "function-paren-newline": "error", "generator-star-spacing": "error", "getter-return": "error", "global-require": "error", "guard-for-in": "error", "handle-callback-err": "error", "id-blacklist": "error", "id-length": "error", "id-match": "error", "implicit-arrow-linebreak": "error", "indent": "off", "indent-legacy": "off", "init-declarations": "error", "jsx-quotes": "error", "key-spacing": "error", "keyword-spacing": [ "error", &#123; "after": true, "before": true &#125; ], "line-comment-position": "off", "linebreak-style": [ "error", "windows" ], "lines-around-comment": "error", "lines-around-directive": "error", "lines-between-class-members": "error", "max-depth": "error", "max-len": "off", "max-lines": "error", "max-nested-callbacks": "error", "max-params": "error", "max-statements": "off", "max-statements-per-line": "error", "multiline-comment-style": [ "error", "starred-block" ], "multiline-ternary": "error", "new-cap": "error", "new-parens": "error", "newline-after-var": [ "error", "always" ], "newline-before-return": "error", "newline-per-chained-call": "off", "no-alert": "error", "no-array-constructor": "error", "no-await-in-loop": "error", "no-bitwise": "error", "no-buffer-constructor": "error", "no-caller": "error", "no-catch-shadow": "error", "no-confusing-arrow": "error", "no-continue": "error", "no-div-regex": "error", "no-duplicate-imports": "error", "no-else-return": "error", "no-empty-function": "error", "no-eq-null": "error", "no-eval": "error", "no-extend-native": "error", "no-extra-bind": "error", "no-extra-label": "error", "no-extra-parens": "error", "no-floating-decimal": "error", "no-implicit-globals": "off", "no-implied-eval": "error", "no-inline-comments": "off", "no-inner-declarations": [ "error", "functions" ], "no-invalid-this": "error", "no-iterator": "error", "no-label-var": "error", "no-labels": "error", "no-lone-blocks": "error", "no-lonely-if": "error", "no-loop-func": "error", "no-magic-numbers": "off", "no-mixed-operators": [ "error", &#123; "allowSamePrecedence": true &#125; ], "no-mixed-requires": "error", "no-multi-assign": "error", "no-multi-spaces": "error", "no-multi-str": "error", "no-multiple-empty-lines": "error", "no-native-reassign": "error", "no-negated-condition": "error", "no-negated-in-lhs": "error", "no-nested-ternary": "error", "no-new": "error", "no-new-func": "error", "no-new-object": "error", "no-new-require": "error", "no-new-wrappers": "error", "no-octal-escape": "error", "no-param-reassign": "error", "no-path-concat": "error", "no-plusplus": "off", "no-process-env": "error", "no-process-exit": "error", "no-proto": "error", "no-prototype-builtins": "error", "no-restricted-globals": "error", "no-restricted-imports": "error", "no-restricted-modules": "error", "no-restricted-properties": "error", "no-restricted-syntax": "error", "no-return-assign": "error", "no-return-await": "error", "no-script-url": "error", "no-self-compare": "error", "no-sequences": "error", "no-shadow": "error", "no-shadow-restricted-names": "error", "no-spaced-func": "error", "no-sync": "error", "no-tabs": "error", "no-template-curly-in-string": "error", "no-ternary": "error", "no-throw-literal": "error", "no-trailing-spaces": "error", "no-undef-init": "error", "no-undefined": "error", "no-underscore-dangle": "error", "no-unmodified-loop-condition": "error", "no-unneeded-ternary": "error", "no-unused-expressions": "error", "no-use-before-define": "error", "no-useless-call": "error", "no-useless-computed-key": "error", "no-useless-concat": "error", "no-useless-constructor": "error", "no-useless-rename": "error", "no-useless-return": "error", "no-var": "off", "no-void": "error", "no-warning-comments": "error", "no-whitespace-before-property": "error", "no-with": "error", "nonblock-statement-body-position": "error", "object-curly-newline": "error", "object-curly-spacing": "error", "object-property-newline": "error", "object-shorthand": "off", "one-var": "off", "one-var-declaration-per-line": "error", "operator-assignment": [ "error", "always" ], "operator-linebreak": "error", "padded-blocks": "off", "padding-line-between-statements": "error", "prefer-arrow-callback": "off", "prefer-const": "error", "prefer-destructuring": "error", "prefer-numeric-literals": "error", "prefer-promise-reject-errors": "error", "prefer-reflect": "error", "prefer-rest-params": "error", "prefer-spread": "error", "prefer-template": "off", "quote-props": "off", "quotes": [ "error", "single" ], "radix": "error", "require-await": "error", "require-jsdoc": "error", "rest-spread-spacing": "error", "semi": "error", "semi-spacing": "error", "semi-style": [ "error", "last" ], "sort-imports": "error", "sort-keys": "error", "sort-vars": "off", "space-before-blocks": "error", "space-before-function-paren": "off", "space-in-parens": [ "error", "never" ], "space-infix-ops": "error", "space-unary-ops": "error", "spaced-comment": [ "error", "always" ], "strict": [ "error", "never" ], "switch-colon-spacing": "error", "symbol-description": "error", "template-curly-spacing": "error", "template-tag-spacing": "error", "unicode-bom": [ "error", "never" ], "valid-jsdoc": "error", "vars-on-top": "off", "wrap-iife": "error", "wrap-regex": "error", "yield-star-spacing": "error", "yoda": [ "error", "never" ] &#125;&#125;; 规则释意主要观察上面生成的.eslintrc.js文件的rules部分，它整体是一个json对象。键是规则的名字，值是关于此规则的配置。 关于每条规则名称的具体含义，我们可以通过其中文意思进行理解，或者查看ESLint官方Rules介绍文档。 而配置则都由这些值开始： &quot;off&quot; 或者0 - 代表关闭此条规则，即不做关于此规则的检测。 &quot;warn&quot; 或者 1 - 将此条规则设置为需要进行warning警告的规则，eslint程序的返回码不变。 &quot;error&quot; 或者 2 - 将此条规则设置为需要进行error报错的规则，eslint程序的返回码将变为1。 使用在不指定配置文件的情况下，会默认加载运行命令目录下符合配置文件格式(文件名和扩展名符合)的文件。 简单使用 默认检测结果会输出到命令行工具窗口里。 检测单个文件1$ eslint yourfile.js 检测多个文件1$ eslint foo.js bar.js 检测目录下所有文件这里可以指定格式，因为ESLint不止可以检查js文件。 1$ eslint your_directory/**.js 检测目录1$ eslint directory_name [directory_name2] 复杂使用首先，ESLint命令支持如下参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253eslint [options] file.js [file.js] [dir]Basic configuration: --no-eslintrc Disable use of configuration from .eslintrc.* -c, --config path::String Use this configuration, overriding .eslintrc.* config options if present --env [String] Specify environments --ext [String] Specify JavaScript file extensions - default: .js --global [String] Define global variables --parser String Specify the parser to be used --parser-options Object Specify parser optionsSpecifying rules and plugins: --rulesdir [path::String] Use additional rules from this directory --plugin [String] Specify plugins --rule Object Specify rulesFixing problems: --fix Automatically fix problems --fix-dry-run Automatically fix problems without saving the changes to the file systemIgnoring files: --ignore-path path::String Specify path of ignore file --no-ignore Disable use of ignore files and patterns --ignore-pattern [String] Pattern of files to ignore (in addition to those in .eslintignore)Using stdin: --stdin Lint code provided on &lt;STDIN&gt; - default: false --stdin-filename String Specify filename to process STDIN asHandling warnings: --quiet Report errors only - default: false --max-warnings Int Number of warnings to trigger nonzero exit code - default: -1Output: -o, --output-file path::String Specify file to write report to -f, --format String Use a specific output format - default: stylish --color, --no-color Force enabling/disabling of colorInline configuration comments: --no-inline-config Prevent comments from changing config or rules --report-unused-disable-directives Adds reported errors for unused eslint-disable directivesCaching: --cache Only check changed files - default: false --cache-file path::String Path to the cache file. Deprecated: use --cache-location - default: .eslintcache --cache-location path::String Path to the cache file or directoryMiscellaneous: --init Run config initialization wizard - default: false --debug Output debugging information -h, --help Show help -v, --version Output the version number --print-config path::String Print the configuration for the given file 使用NPM/Yarn命令运行代码检查在package.json文件的scripts添加如下字段： 12345&#123; "scripts": &#123; "lint": "eslint file_or_directory_you_wanna_lint" &#125;&#125; 运行命令 12345# NPMnpm run lint# Yarnyarn lint 文件输出结果可以通过-o, --output-file参数来指定以文件的格式输出，通过-f, --format参数来指定输出的文件格式。 1$ eslint -f compact file.js 项目代码内局部检查跳过可以通过以下注释方式来让ESLint跳过检查。 1234567/*eslint-disable*/ // 以下禁用检查/*eslint-enable*/ // 以下启用检查/*global*/ // 全局/*eslint*//*eslint-env*/ // 局部修改环境变量// eslint-disable-line // 当前行跳过检查// eslint-disable-next-line // 下一行跳过检查 忽略文件可以在配置文件同级别下创建.eslintignore文件来进行忽略代码检查文件的配置，例： 12node_modules/***/vendor/*.js 常见问题ESLint找不到配置的插件原因：如果使用全局的ESLint来检查代码，那么配置的插件也必须再全局下载。如果在项目内使用ESLint，那么ESLint和对应的插件都必须存在于package.json文件的devDependencies里作为依赖，并且需要正确被下载。 参考资料ESLint 官方Docs]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CSS滤镜处理图片]]></title>
    <url>%2Fcss-filter%2F</url>
    <content type="text"><![CDATA[学习使用CSS滤镜处理图片。 简介CSS滤镜(filter)属性提供一系列用于制作图形特效的过滤器，比如模糊，锐化，元素变色，调整灰度等。这些过滤器可用于简单调整图片，比如背景和边界的渲染。 CSS标准内置了一些已经实现了预定义效果的函数。比如： blur brightness contrast drop-shadow grayscale hue-rotate invert opacity saturate sepia 这些过滤器的使用基本语法如下： 1filter: &lt;filter_funtion&gt; | none | inherit | unset | initial; none表示不应用过滤器。 除特殊说明外，如过滤器函数接收的参数可以为百分比外，那么它也能接收对应小数参数。 可以同时对图片使用多个过滤器，仅需要用空格将过滤器函数隔开即可。 预览在线DEMO 过滤器简单介绍内置的过滤器。 Blur高斯模糊滤镜，用于给图像加高斯模糊效果。参数格式为CSS长度值，不接受百分比值和小数为单位。 参数越大越模糊，设置的参数足够大时，图片在视觉效果上消失。默认值为0。 例: 1filter: blur(5px); /* 参数为像素值 表示图像模糊半径 */ Brightness明暗度滤镜，用于设置图像的明暗度。参数为小数或者对应的百分比值。 参数越小图像越黑，到1或者100%时，图像无变化，大于1时候，图像会更亮。默认值为1。 例： 1filter: brightness(.4); /* 参数为小数或百分比 表示图像明暗度 */ Contrast对比度滤镜，用于设置图像的对比度。参数为小数或者对应的百分比值。 参数为0时，图像全黑，参数为1时，图像不变。可接受100%以上的参数，意为使用更低的对比度。 例： 1filter: contrast(.5); /* 参数为小数或百分比 表示图像对比度 */ 与明暗度对比，当设置0至1范围内参数时，明暗度变现为图像会变黑，对比度会让图形整体显得灰色。当设置值特别大(比如500%)时，加明暗度滤镜的图像会大部分偏向白色的像素点不可见，而加对比度滤镜的图像会出现变色。 Drop-shadow阴影效果滤镜，用于为图像设置阴影效果。参数与CSS3box-shadow属性类似，但是无法设置inset关键字。 阴影规则类似于box-shadow属性。 例： 1filter: drop-shadow(offset-x offset-y blur-radius spread-radius color); 参数解释: offset-x，offset-y 必选参数 阴影偏移值 CSS长度值 可为负数和0 spread-radius 可选参数 扩展半径 默认为0 可正可负 正值增大阴影 负值减少 blur-raidus 可选参数 模糊半径 值越大越模糊 默认为0 不允许负值 color 可选参数 阴影颜色 CSS颜色值 给图片添加阴影滤镜会让图片有立体感。 Grayscale灰度滤镜，用于将图像转换成灰度图像。参数为转换的比例。 100%则转换为完全灰度头像，0则不变。默认值为0。 例： 1filter: grayscale(100%); /* 参数为小数或百分比，表示图像灰度比例 */ 设置100%或1后，转为完全灰度图像，即为常说的黑白图片。 Hue-rotate色相旋转滤镜，用于给图片加旋转效果。参数为CSS角度。 0deg和360deg效果相同。默认值为0deg，参数大于360deg后相当于旋转一周。 例： 1filter: hue-rotate(50deg); /* 参数为CSS角度，表示图像色相旋转角度 */ 旋转色相会让图像呈现出怪异的颜色。 Invert反色滤镜，用于给图像设置反色效果，参数为转换比例。 默认为0，100%时候图像完全反转。 例： 1filter: invert(50%); /* 参数为小数或百分比，表示图像反色程度 */ 完全反色效果的人物图片效果显色有点恐怖。 Opacity透明度滤镜，用于设置图像透明效果，参数为透明程度百分比。 默认值为1，设置透明度为0后，图像完全透明，视觉上不可见。 例： 1filter: opacity(.5); /* 参数为小数或百分比，表示图像透明程度 */ Saturate饱和度滤镜，用于设置图像的饱和度。参数值为转换的比例。 默认值为100%，0表示完全不饱和，可超过100%表示更高的饱和度。 例: 1filter: saturate(30%); /* 参数为小数或百分比，表示图像饱和程度 */ 饱和度为0时，图像视觉上表现为完全灰度图像。 Sepia深褐色滤镜，用于将图像转化为深褐色。参数值为转换的比例。 可接收参数值在0至100%之间。默认值为0，表示图像无变化。100%则表示图像完全转化为深褐色。 例： 1filter: sepia(88%); /* 参数为小数或百分比，表示图像转化成深褐色比例 */ 深褐色滤镜会让图片产生出一种复古的沧桑的感觉。 浏览器兼容性非IE浏览器 参考Can I Use 参考资料MDN—CSS filter]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试静态站点生成器Vuepress。]]></title>
    <url>%2Fvuepress-abc%2F</url>
    <content type="text"><![CDATA[4月12日，Vue.js框架的创始人尤雨溪发布了一款新的基于Vue的静态网站生成器。本着跟上技术的潮流的想法和对技术的热爱💕，最近两天我利用休息时间踩坑学习，终于在刚才成功运行项目，生成了预期中的页面，顺便写篇博文来记录一下。 介绍Vuepress是一款基于Vue.js的简洁至上的高性能的静态网站生成器。 它主要拥有以下特性： 开发配置简单，容易上手 支持在Markdown中使用Vue组件 支持使用Vue自定义主题 每个页面运行时都是单页应用 服务端渲染，有利于SEO 使用webpack进行构建打包 目前项目的版本是v0.7.0，仍然处于一个版本快速更迭的时间段。不过我相信，以Vuejs的强大影响力和社区，这个项目很快就会有很多扩展，主题等。 静态站点生成器提到静态站点生成器，目前这样的项目不在少数，尤其是在有了Node后。前端们用静态站点来做一些文档部署类的工作，这种需求下我们根本不需要一个重量的服务器，更不需要数据库。我们只需要把自己写的文档生成预期中的HTML页面即可。 目前比较流行的静态站点生成器，我试用过以下4种。 JekyllJekyll官网 Jekyll是一个简单的静态博客生成器，需要使用Gem来进行安装。 同时，它也是Github默认支持的Github-pages页面的生成工具。 个人觉得，它如果使用的是node进行安装会更受欢迎。 HexoHexo Hexo是一个快速、简单的强力博客框架，它拥有大量主题和相关功能扩展。 我的个人博客就使用了Hexo的next主题。 BTW，Hexo是使用Node进行安装的。 GatsbyGatsby Gatsby是一款基于React.js的静态网站生成项目。 个人比较喜欢一款名叫Casper的Starter。（与别的博客系统的主题有类似，也有区别） 所以构建了一份博客代码放到VPS上去了。 DocsifyDocsify Docsify主要更适合做简单地文档部署工作，虽然主题配色还可以，但是构建后的页面内容仍略显单调。 不过它配置起来也很简单，只需要在初始化的页码里加上可能需要用到且需要修改的即可。 而大多的比如主题文件，构建需求的配置只组要引入文件即可， 踩坑记录首先，跟着官方文档里介绍的做，全局安装vuepress，再创建README.md文件，然后执行vuepress dev命令。 12345$ npm install vuepress -g$ echo "# Hello world" &gt; READMD.md$ vuepress dev . 注意dev后的.表示当前路径。这是我写这篇博文的时候才看出来的，先前我一直输入的是vuepress dev所以根本无法构建成功。 其次另一个问题，全局安装vuepress模块后，再在项目依赖内安装vuepress，启动项目会提示一系列错误，具体见Issue-Module build failed: CssSyntaxError。Issue下面有人提到了全局和项目内的依赖都安装了vuepress会导致构建出错的问题。 在看到这个Issue之前，我在Win、Mac上都做了尝试，分别都使用了NPM和Yarn来安装依赖，都没能解决问题，反而让我感觉到快要怀疑自己的智商了😂😂😂 在不知道如何去解决的情况下，尝试去Github看看Issue，想知道是否有人和我一样，也遇到了这种百思不得其解的问题。很幸运地找到了那条Issue。 所以，周末可以好好折腾一下Vuepress了，试试它的各种配置，和自动化构建部署的流程。 配置 无配置情况下，vuepress会默认打开一个只有顶部标题搜索框和页面主体的页面 而有关于vuepress配置的定制，官方规定全部放置于文档目录下的.vuepress目录内。在.vuepress目录中创建config.js文件，vuepress会自动加载其中的配置。(当然，也可以使用YAML文件等) 该文件需要以Commonjs规范向外导出配置，主要配置项如下： 12345678910111213141516171819202122232425262728module.exports = &#123; title: '程序员不好吃', description: '未来的不可知，是我们前进的原动力', // base: '/vuepress-demo/' themeConfig: &#123; nav: [ &#123; text: 'Home', link: '/' &#125;, &#123; text: 'Guide', link: '/guide/' &#125;, &#123; text: 'External', link: 'https://ntnyq.com' &#125;, &#123; text: 'Languages', items: [ &#123; text: 'Chinese', link: '/language/chinese' &#125;, &#123; text: 'Japanese', link: '/language/japanese' &#125; ] &#125; ], sidebar: [ '/', '/home/' ], repo: 'ntnyq/vuepress-demo', repoLabel: 'Github', editLinks: true, // 默认为 "Edit this page" editLinkText: '帮助我们改善此页面！' &#125;&#125;; 标题Title页面主标题 渲染在页面顶部左侧 并且指向站点根目录。 描述Description页面描述 以meta标签的形式渲染在head标签内部，用于SEO。 base站点路径 用于部署到自定义域名，或者非username.github.io时启用。 主题配置项 主题配置项时基于主题的，vuepress官方提供了一套默认主题。它的可用配置如下： 导航Nav顶部导航 对象数组 每一项的格式 { text: ‘nav_item_name’, link: ‘/your_link/‘ } 若使用items，且为数组，则会将此导航项渲染为下拉列表的格式。 侧栏sidebar侧栏导航 数组格式 填写导航目标的路径。 仓库RepoGithub仓库 点击可以跳转至对应的Github仓库 仓库名RepoLabel点击跳转仓库名称 文本 editeLinks是否展现编辑文档链接 布尔值 editLinkText编辑链接文本 用于提示 默认为Edit this page 更多配置 更多配置请查看官方配置文档 样式覆盖简单样式覆盖需要覆盖默认主题的样式，仅需在.vuepress目录下新建override.styl 文件，再编写stylus文件来覆盖默认样式，如下： 12345// showing default values$accentColor = #3f51b4$textColor = #2c3e50$borderColor = #eaecef$codeBgColor = #282c34 自定义页面类通过自定义页面类可以让某个页面拥有独特的样式，要使用这一特性，需要通过如下的方式 首先，在页面的YAML front matter中声明一个 pageClasss。如下: 123---pageClass: custom-page-class--- 然后就可以对这个页面进行自定义样式了。 12345/* .vuepress/override.styl */.theme-container.custom-page-class &#123; /* 特定页面的 CSS */&#125; 页面自定义布局首先在YAML front matter中指定布局组件。 123---layout: SpecialLayout--- 然后，在.vuepress/components/SpecialLayout.vue中编写对应布局。 自定义主题在.vuepress/theme 文件夹中，创建一个 Layout.vue 文件，使用vuejs的语法进行开发。 站点和页面的元数据可以通过this.$page和this.$site来获取。 结论敲代码要细心。 学会排查错误和寻找可行答案。 努力争取给开源项目做贡献。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React框架入门学习]]></title>
    <url>%2Freact-abc%2F</url>
    <content type="text"><![CDATA[前阵子台湾友人推荐我学习React，刚好我自己最近也在接触Gatsby博客。本着技多不压身的思想，所以我打算Vue和React都学。 简单的React应用需要引入2个库。 React和ReactDOM 如果在浏览器端使用，需要引入browser.js提供jsx语法编译支持，并且script的type属性需要设置为text/babel。 JSXReactDOM要使用JSX语法来进行编写。 JSX语法可以直接在JS里写HTML内容，不需要加任何引号。 JSX语法基本规则：遇到HTML代码块(以&lt;开头)，就以HTML的规则来解析；遇到JavaScript代码块(以{开头)，就用JavaScript规则进行解析。 JSX语法与原生js语法不兼容。但是它可以通过转译变成原生js。 JSX语法允许在模板内插入JavaScript变量，如果这个变量是一个数组，那么会展开这个数组中的所有成员，添加进模板。 ReactDOM有一个render方法，它接收2个参数，要渲染的内容(JSX语法)和被挂载的位置(原生DOM节点)。用于将模板转化为HTML内容，并且插入到指定的DOM节点。 JSX语法支持使用原生js的一些方法。(原生js返回JSX语法)JSX语法使用{}来作为模板语法。 组件React对象拥有一个createClass方法，用于创建组件类。创建出的组件类，可以以HTML元素的形式来使用，使用的时候会自动生成一个组件类的实例。 创建出的组件类必须要有一个render方法，返回一段JSX格式的内容来进行组件类的输出。 组件类的名称必须大写，组件类返回内容只能包含一个顶层标签，否则会报错。 组件内部可以使用this.props对象来获取绑定在组件上的属性。 添加属性时候要注意，class属性必须写作className，for属性必须写作htmlFor。因为class和for是JavaScript中的保留字。 this.props.children是组件类属性的例外，它表示组件的所有子节点。若无子节点，值为undefined，若有一个子节点，其数据类型为object，若有多个子节点，其数据类型为Array。 React提供了一个React.Children方法来处理this.props.children。我们可以使用React.Children.map来遍历子节点，而无需关心this.props.children的数据类型。 组件类的属性可以为任意类型的值，数字，字符串，对象，数组，函数等都可以。 创建组件类的时候，可以通过设置propTypes属性来设置我们对每个props属性期待的值的类型。例如: 12345678const HelloWorld = React.createClass(&#123; propTypes: &#123; foo: React.PropTypes.string.isRequired &#125;, render: function () &#123; return &lt;h1&gt;&#123;this.props.foo&#125;&lt;/h1&gt;; &#125;&#125;); 可以通过getDefaultProps方法来设置组件属性的默认值。 12345678910const HelloWorld = React.createClass(&#123; getDefaultProps: function () &#123; return &#123; foo: &apos;hello world&apos; &#125;; &#125;, render: function () &#123; return &lt;h1&gt;&#123;this.props.foo&#125;&lt;/h1&gt;; &#125;&#125;); 组件DOM并非真实的DOM，而是一种数据结构，叫做虚拟DOM(Virtual DOM)，只有将它插入到HTML文档后，才会变为真正的DOM。所有DOM的变动，都是先发生在虚拟DOM上，然后再将真正发生了变化的部分渲染到真实DOM上，这种算法叫做DOM Diff算法，它可以极大地提高网页地性能表现。 那么如何在React中获取真实DOM呢，这时候我们需要用到ref属性。 12345678910111213var MyComponent = React.createClass(&#123; handleClick: function () &#123; this.refs.myTextInput.focus(); &#125;, render: function () &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 由于ref属性拿到的是真实DOM，所以必须要在虚拟DOM渲染到文档后才能使用这个属性，否则会报错。使用的时候格式为this.refs.refName，绑定事件时候使用模板语法，且onClick要大写。 组件类的getInitialState属性用于设置组件内状态的初始值，它会返回一个对象，包含了组件的所有状态，这些状态值可以通过this.state.stateName来获取。当用户与组件进行了交互或者组件的状态值需要改变时，可以通过setState方法来修改组件的状态值，修改后它会自动调用组件的render方法，重新进行组件渲染。 123456789101112131415161718var LikeButton = React.createClass(&#123; getInitialState: function () &#123; return &#123; liked: false &#125;; &#125;, handleClick: function (e) &#123; this.setState(&#123; liked: !this.state.liked &#125;); &#125;, render: function () &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle &lt;/p&gt; ); &#125;&#125;); props常用于定义那些不会改变的状态，而state常用于定义会变化或者存在交互的状态值。 React中不能通过value直接获取表单的值，而是要通过定义一个onChange回调，通过event.target.value来获取常见表单元素的值。 12345678910111213141516171819var TextInput = React.createClass(&#123; getInitialState: function () &#123; return &#123; value: &apos;hello&apos; &#125;; &#125;, handleChange: function (e) &#123; this.setState(&#123; value: e.target.value &#125;); &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;); 生命周期组件的生命周期分为三个状态： Mounting：已经插入真实DOM Updating：正在被重新渲染 Unmounting：已移出真实DOM React为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did在进入状态之后调用。三种状态共计五种处理函数。 12345componentWillMount()componentDidMount()componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)componentWillUnmount() 此外React还提供了两种特殊状态的处理函数。 12componentWillReceiveProps(object nextProps) // 已加载改组件收到新的参数时调用shouldComponentUpdate(object nextProps, object nextState) // 组件判断是否重新渲染时调用 例子： 1234567891011121314151617181920212223242526var HelloMessage = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1.0 &#125;; &#125;, componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;); 样式React组件样式是一个对象，使用的时候要使用如下写法 1style=&#123;&#123;attrName: attrValue&#125;&#125; // 第一个大括号表示这是js语法 第二个大括号表示样式对象 参考资料 React 入门实例教程]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何开发一个前端js插件]]></title>
    <url>%2Fdevelope-a-javascript-plugins%2F</url>
    <content type="text"><![CDATA[从一个插件源码学习，如何开发出一个JavaScript插件。 最近心得现在是2018年3月12日近0点，突然想写一下博客。 感觉自己最近有些浮躁了，也可能是最近工作有点忙吧，想写的几篇博客，一直没有下手去写。 最近工作最大的感受就是，体会到了面向接口开发的重要性。 因为我们公司基本都是走的面向实现开发的路子，比如前端写一个新闻详情页面，后端传给前端的数据却是新闻编辑们写出来的富文本，HTML标签上都带着行内样式，这时候按着设计图写出来的样式就会被覆盖了。 当然也并不是没有解决的方法，比如可以通过!important来增加样式表样式的权值，达到覆盖行内样式的目的。但是，显然这不符合最佳实践，应尽量避免使用此法。 首先，编辑的内容编辑的格式应该是固定的，以此来确保输出的富文本格式相同，或者不要让编辑来输出富文本。 这才是更好的实践。 当然，我主要想说的是，接口的提供最好是在我编写页面之前的。而不是写完页面后，再取根据滞后的接口再去调整样式。 打算先前打算阅读完Underscore的源码，却没有坚持下来。 不过我并没有打算放弃，只是觉得Underscore的源码还是有点复杂的，我应该从点简单的插件入手，慢慢地去提升。 最近遇到了一个插件headroom.js，Github仓库，这个效果先前在很多公司的官网首页看到过，蛮喜欢的。 所以，打算从这个插件开始吧！ 总览整个插件被包裹在一个自执行函数内，再根据全局对象的不同，以AMD规范，CommonJs规范或全局函数的方式导出插件。 1234567891011121314151617(function (root, factory) &#123; 'use strict'; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD规范 注册为的异步模块 define([], factory); &#125; else if (typeof exports === 'object') &#123; // COMMONJS规范 将插件构造函数挂在到module的exports属性下 module.exports = factory(); &#125; else &#123; // 浏览器环境 将插件构造函数挂到window对象上 root.Headroom = factory(); &#125;&#125;(this, function () &#123;&#125;)); 源码解读开启严格模式优点： 严格模式变量必须先声明再使用 严格模式对象不可有重复的键 严格模式下函数的参数不能重复 严格模式不能显示修改函数的arguments对象 1"use strict" 能力检测将能力检测的结果，全部挂在到features对象上。 12345var features = &#123; bind : !!(function()&#123;&#125;.bind), // 是否支持Function的bind方法 classList : 'classList' in document.documentElement, // 是否支持classList API rAF : !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame) // 是否支持requestAnimationFrame&#125;; 请求动画帧检测请求动画帧API的支持情况，并做兼容处理。 1window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame; 函数去抖工具创建一个去抖工具的构造函数，并且在原型上定义其方法。这个构造函数接收一个回调函数作为参数。 123456function Debouncer (callback) &#123;&#125; // 构造函数Debouncer.prototype = &#123; // 去抖工具原型 constructor: Debouncer, // 维护构造函数指向 api: function () &#123;&#125;&#125;; 工具函数插件内部定义的普通函数，供插件调用。 函数1123function isDOMElement(obj) &#123; return obj &amp;&amp; typeof window !== 'undefined' &amp;&amp; (obj === window || obj.nodeType);&#125; 判断一个对象是否为DOM节点，返回布尔值。 typeof window !== &#39;undefined&#39;确保当前为浏览器环境。 obj === window || obj.nodeType当前对象等于window或者它有nodeType属性。 函数2123function normalizeTolerance (t) &#123; return t === Object(t) ? t : &#123; down : t, up : t &#125;; &#125; 用于格式化tolerance值的函数。 若t是对象，则直接返回，若不是，则以对象的格式返回。 函数312345678910111213141516171819202122232425function extend (object /*, objectN ... */) &#123; if(arguments.length &lt;= 0) &#123; // 无参数报错 throw new Error('Missing arguments in extend function'); &#125; var result = object || &#123;&#125;, // 结果 key, i; for (i = 1; i &lt; arguments.length; i++) &#123; // 迭代参数 var replacement = arguments[i] || &#123;&#125;; for (key in replacement) &#123; // Recurse into object except if the object is a DOM element if(typeof result[key] === 'object' &amp;&amp; ! isDOMElement(result[key])) &#123; result[key] = extend(result[key], replacement[key]); // 递归 &#125; else &#123; result[key] = result[key] || replacement[key]; &#125; &#125; &#125; return result; // 返回最终结果&#125; 合并多个对象的函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis-CI自动部署Hexo博客到Gh-Pages]]></title>
    <url>%2Ftravis-ci-abc%2F</url>
    <content type="text"><![CDATA[将Hexo博客的源码和发布的博文代码存储在同个Github Repo的不同分支里，同时也对博客源码进行了备份。而通过Travis-CI，我们只需要简单地进行配置，就可以实现博客代码push后，博文代码的自动化部署，省略了手动发布的过程。 Travis介绍Travis CI为软件开发领域提供在线的、分布式的持续集成服务。 目前，它只能用于绑定Github上面的项目。 它提供了一个运行环境。当你往Github仓库中Push了新的代码后，仓库的变更就会触发Travis CI的持续集成服务。执行测试，完成构建，再部署到服务器。 Travis接入给项目接入 Travis CI分为以下几个步骤： 登录Travis CI进入Travis CI官网，点击右上角的个人头像，就可以使用Github账号来登录了。 成功登录后，会看到如下界面，你登录账号的所有公开仓库都在列表里。 开启对应仓库将你想要让Travis监听的仓库后面的复选框选择为打开的状态。 比如我给博客开启了自动部署，那么我的ntnyq.github.io这个仓库就是开启状态的。 编写配置文件Travis需要读取项目根目录下的配置文件来决定构建过程需要进行的行为。 这个文件的名字必须是.travis.yml。 仓库Push后，会触发Travis读取这个文件，然后执行文件中定义好的脚本，来执行构建过程。 我博客的.travis.yml文件的内容如下，我在后面是加上了字段的含义。 123456789101112131415161718192021222324252627282930313233# Travis-CI configlanguage: node_js # 指定构建脚本执行环境为nodejsnode_js: stable # 指定node版本为稳定版 也可以指定版本号# Cache dir configcache: # 缓存设置的文件或者目录 directories: - node_modules# Install scriptsinstall: # 构建前下载依赖 - npm install# script: # 构建主要要执行的脚本script: - hexo g # After_scriptafter_script: # 构建结束要执行的脚本 - cd ./public - git init - git config user.name "ntnyq" - git config user.email "ntnyq13@gmail.com" - git add . - git commit -m "Update blog" - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:masterbranches: # github上的分支 only: - dev # 我的博客源码保存在了dev分支上env: # 构建中使用到的环境变量 global: - GH_REF: github.com/ntnyq/ntnyq.github.io.git .yml文件使用的是YAML语法，这是一种以数据为中心专门用来编写配置文件的语言，非常强大。 它采用空格缩进，来实现类似JSON的层级关系，并且支持注释功能。 想对YAML的语法有更多了解，推荐阅读YAML 语言教程-阮一峰 上面的配置中使用到了2个环境变量，但是在配置文件里我们只写到了一个。这是因为在git推送代码的时候，需要你的github仓库权限。而出于安全性的考虑，这个用于验证token不方便直接出现在配置文件中，所以GH_TOKEN这个环境变量的内容保存在travis-ci的网站上，如下图所示：]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在一个网页中显示外部页面?]]></title>
    <url>%2Fhow-to-show-external-website-in-another-page%2F</url>
    <content type="text"><![CDATA[如果是你碰到这样的需求，你会如何去解决？ 今天在Segment Fault看到的这个问题。我的第一反应就是使用Iframe来实现。 但是题主明确说明了，需要非Iframe的实现方式。因为iframe会导致内存泄漏。 Iframe会导致内存泄漏？ 我还没有接触过这类问题，正好学习一下。 查了一下资料，发现Iframe已经是一个过时的技术了，已被新的技术所取代。现在更推荐使用Embed标签来进行页面和资源的嵌入，它定义了一个外部应用程序的容器。 而Iframe则存在着以下几个坑点： Iframe相当于打开一个网页，同时会请求嵌入页面资源，但是又无法释放内存。 Iframe会阻塞主页面的onload事件，必须在页面嵌入结束才触发。 Iframe和主页面共享连接池，浏览器对同个域的连接有限制，会影响页面对资源的并行下载。 Iframe在移动端的支持并不好。 Iframe对统计代码不友好。 Iframe的尺寸自适应问题是个坑。 参考: 为什么前端尽量少用iframe？ 实现那么除了Iframe，我们可以如何去实现上述需求呢。 Object标签object 标签 它定义了HTML文档中的嵌入对象。可用于HTML文件和多媒体内容，如音频，视频，小程序，ActiveX，PDF和Flash或其他插件）。 123&lt;object data="http://stackoverflow.com" width="400" height="300" type="text/html"&gt; Alternative Content&lt;/object&gt; Embed标签embed 嵌入标签。它定义了一个外部应用程序的容器，例如一个插件，也可以用于显示一个HTML页面。 1&lt;Embed src="http://stackoverflow.com" width="400" height="300" /&gt; 参考资料How to Show External website inside another page without iFrame?]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门学习-基础篇]]></title>
    <url>%2Fwebpack-abc%2F</url>
    <content type="text"><![CDATA[webpack是目前很流行的打包工具，但是它的高度配置特性可以使得它有替代自动化构建工具的能力，而且vue-cli本身也是集成webpack的，作为vue的学习者了解它是很有必要的。 介绍webpack是一个现代的javascript应用程序的模块打包器。 当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序所需要的每个模块，然后将这些所有的模块打包成少量的bundle，通常只有一个，以方便浏览器去加载。 特性webpack是高度可配置的 首先要理解它的四个概念： 入口(entry) 输出(output) loader 插件(plugins) 入口webpack创建应用程序所有依赖的关系图，图的起点被称为入口起点。入口起点告诉webpack从哪里开始，并根据依赖关系图确定需要打包的内容。可以将应用程序的入口起点看作是根上下文或者app的第一个启动文件。 在webpack中，我们通过使用webpack配置对象中的entry属性来定义入口。 12345// webpack.config.jsmodule.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; 出口将所有需要的资源归拢在一起后，还需要告诉webpack在哪里打包应用程序。webpack的output属性描述了如何处理归拢在一起的代码。 1234567891011// webpack.config.jsconst path = require(&apos;path&apos;); // 引用path模块module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // 只能使用绝对路径 filename: &apos;first_webpack.bundle.js&apos; &#125;&#125;; 通过output.path和output.filename属性，指定了webpack bundle的生成地址和是生成(emit)的文件名。 项目生成(emitted或emit)是贯穿webpack的核心，表示生产或者排放。 loaderwebpack的目标是，让webpack聚焦于项目中的所有资源(assets)，而浏览器不需要关注考虑这些(但是这不以为着所有的资源都必须打包到一起)。 webpack把每个文件(.css, .html, .scss, .jpg, etc)都作为模块来处理。然而webpack自身只理解Javascript。 webpack loader在文件被添加到依赖图中时，将其转换为模块。 在更高层面，webpack中配置loader有两个目标。 识别(identify)出应该被对应的loader进行转换(transform)的那些文件。(test属性) 转换这些文件，从而使其能够被添加到依赖图中(并且最终添加到bundle中)(use属性) 12345678910111213141516171819// webpack.config.jsconst path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ // 使用规则 &#123; test: /.txt$/, // 匹配文件 正则语法 use: &apos;raw-loader&apos; // 使用loader &#125; ] &#125;&#125; 以上配置中，对一个单独的module对象定义了rules属性，里面包含2个必须的属性：test和use。这告诉webpack编译器(compiler)如下信息： webpack编译器，在碰到require或者import语句中被解析为’.txt’后缀的路径时，在对其打包之前，先使用raw-loader处理一下。 注意在webpack中定义loader的时候，要定义在module.rules中，而不是rules。否则webpack会给出严重的警告。 plugins由于loader仅在每个文件的基础上进行转换，而plugins(插件)更常用于(但不限于)在打包的compliation和chunk生命周期执行操作和自定义功能。webpack的插件系统极其强大和可定制化。 想使用一个插件，你只需要require()它，然后把它添加到plugins数组中，多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用new来创建它的一个实例。 123456789101112131415161718192021222324252627// webpack.config.jsconst HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // install via npmconst webpack = require(&apos;webpack&apos;)； // to access built-in pluginsconst path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optmize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos; &#125;) ]&#125; webpack包含了一些内建(built-in)的插件。插件列表 参考资料webpack官方docs 入门Webpack，看这篇就够了]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见2017]]></title>
    <url>%2Fthe-end-of-2017%2F</url>
    <content type="text"><![CDATA[现在是2017年12月31日晚上11点，我独自一个人在租住的房子里写这篇年度总结。 我今年25周岁了，接触前端至今有1年了。 想来也许是命中注定，让我在毕业后找不到工作的迷茫中选择了当时基本一窍不通的前端，然后又一路坚持走到了现在。 2016年7月 大学毕业离校 2016年9月 首份工作 网络客服 2016年12月 辞职 自学前端 2017年5月 开始寻找前端工作 2017年5月25 入职现在的公司 一路走来，经历了很多，也学习了很多。 自己也从早先不喜欢编程的计算机专业毕业生变地了现在想在这条路走地更远的前端菜鸟。 付出的努力，也许只有自己知道吧。 博客学习编程的时候，偶然从B站(Bilibili)看到了UP主刘延栋的视频，再关注了他的微信公众号和网易云音乐电台。 这是一个有意思的人。 如果有谁看到了我的这篇博客，并且你也喜欢技术，你可以关注一下他的微信公众号--软件那些事儿(ruanjiannaxieshier)，听他讲讲软件行业公司和大牛的故事。 当然如果你喜欢看书，你也可以直接去看那些大牛的传记。 我对喜欢看书的人都比较有好感，我觉得一个人能静下心来享受书籍和知识，那么这个人会相对比较理性。 他(刘延栋)今年36岁，从事软件行业十几年了。而选择去做一个电台，则完全是因为爱好，写点东西给以后的自己活着小孩子看。 我觉得蛮有感触的。 我也是一个喜欢回忆的人，所以我也相关给将来的我留下点什么，也许将来的我看到我现在写的这些东西会觉得比较有趣的吧。 至少我现在觉得是比较有趣的。 而把写作的东西留在电脑上或者U盘上都可能会丢掉。 本着不把鸡蛋放在一个篮子的原则，我是要把这些博文放在几个地方的。目前我会定期把一份拷到U盘里，然后电脑上有一份，Github上个我用过Hexo搭建了一个静态博客，也放了一份。 当然我不仅单单只记录了故事，还记录着自己的学习。 因为通过写作和整理思绪来组织知识和加深记忆是个非常有效的途径。 所以我搭建了这个博客，刚好Github Pages服务也是免费的。 因为自己作为一个初学者，感觉自己记录的东西可能没有什么价值和深度，也就并没有对博客进行过什么宣传。 不过写的东西，有的当做一篇文章单独发表到社区了，希望能帮到有需要的人吧，或者是希望得到别人的认同？ 说不清楚。 但是博客我会坚持写下去。 兴趣为什么小标题叫兴趣呢？ 我有一个可能片面的观点，或者是自己的偏执吧。 人应该为兴趣而活，这样才是最快乐的。 以前我的兴趣是什么？ 小说，算一个。 没有看小说的时候呢，整个大学我花费了很多时间在打游戏上，其实那些游戏也没有那么好玩儿。也许我那时的兴趣就是单纯的虚度时间把，我并不觉得这样做有什么不对。 至少我的大学时光，大部分时间都过得很快乐。 而现在，前端和编程成了我的兴趣。 我关注了几个微信公众号(前端大全，奇舞团，程序员那些事儿)，基本每次推送都会认真看一遍。我主要在关注3个社区，一个主要面向前端程序员的前端网，一个是编程问答类社区Segment Fault，还有一个自然是全世界程序员的开源社区Github。 一些工具类库框架的官网也经常要去逛逛，查查文档，搜搜问题，比如MDN和Can I Use。 博客方面看过很多人的博客，主要关注的有2个。TG和阮一峰。别的好多就是只通过搜索看到几篇文章，比如张鑫旭，廖雪峰，Yscoder，月影和国内大公司前端团队的博客等。 书籍方面，因为今年才是前端初学，所以看的前端方面的书并不多，基本以入门为主。主要看了： JavaScript高级程序设计 JavaScript DOM编程基础 You don’t know JS 锋利的jQuery JavaScript设计模式 JavaScript Promise Book CSS揭秘 写给大家看的算法书 微信小程序入门指南 ThreeJs入门指南 相关学科的书或者课外书看过几本，但是没有看完。 图解HTTP 只是为了好玩 Nodejs入门手册 束星北档案：一个天才物理学家的命运 再就是没有什么学习价值的网络小说，以前非常喜欢，现在看的比较少了，基本可以算是厕所文学了(泛指大多网络小说，我看过且非常喜欢的还是我心中的经典)。 2018年，会多看技术类书籍，同时补上大学自己没有好好学习现在却有感兴趣了的课程。 学习我发现在学习这方面，我不是一个意志力很鉴定的人。 并非我不能够坚持去学习，而是我容易被转移注意力去学习别的东西，或者会放下手头在研究的东西转去研究别的。 所以我的博客里以abc结尾的博客蛮多的，abc是我用来表示入门的，基本就是看文档和对着官方Demo实现一遍吧。 这还称不上真正的学习。 想想这一年接触过没有深入去学习的东西有Node，MongoDB，ThreeJS，WebSocket，Mocha，Webpack，Angular等。。。 - -! 但是仍然对前端技术保佑强烈的探究欲望和学习激情，并且认为这样的心理还会继续持续。 不过同时我也折腾了不少东西，记得先前大学的时候，学习编程，搭建环境安装软件都是靠同学。现在自己在Windows上折腾，在Linux上折腾。 搭建前端开发环境，搭建Node环境，搭建PHP的WAMP环境，搭建Ruby on Rails环境。 安装各种开发软件，插件，学习使用。 生命不息，折腾不止。 我觉得喜欢折腾的程度，在很大的程度上决定了技术的成长。 当你看到一个现象的时候，你不仅要问为什么，还要自己尝试去寻找为什么。 就像那个公众号的主人刘延栋说的，妄想通过加群或者电台学会编程，或者想速成都是不可能的。 唯一的途径就是对着优秀的代码，敲啊改啊。 而且作为一个技术人员，或者说作为一个生活在互联网时代的人，基本的文档信息检索能力是必须的。 没有任何人欠你什么，没有人必须回答你的问题，人家帮助你是人家友善，人家也就可以不帮你。 在有余地的时候，永远把求助别人放在后面。 在真的需要别人帮助的时候，求助社区比单独找有两个人要更加高效。 网上的有着丰富的文章和视频教程，足够让你看几十年，你所寻找的问题，大多是别人已经碰到过的。 我也遇到过自己觉得难以解决的问题，比如线条流动效果的实现和页面间实时通信效果的实现。 线条流动效果我知道SVG可以，但是我并不擅长。 页面实时通信我知道的定时器加轮询可以模拟，但是效果不会很理想，而且浪费性能。 我认识一个台湾的朋友，今年36岁，目前在做全栈开发工作。偶尔我会和他聊聊天，我会向他咨询，告诉他我自己的想法，然后问他会如何去解决。我想这不是单独的求助，而是技术上的交流，不过相比只是我的方案很Low而且没有价值罢了。而他给的答案也只会是什么技术可以做，或者给我一个链接。 这样不会耽误别人太多的时间，我觉得挺好的。 聊天中，他也会推荐给我一些技术上的书籍、文章、插件。给我的未来发展方向指指路，比如学习TDD，BDD，Mocha，RxJS等等。 希望在2018年的时间里，慢慢学习研究，将前端之路更好地走下去。 工作入职现在的公司已经7个月多了，我也从一个小小菜鸟变成现在的小菜鸟了吧。 公司的主要业务是做媒体和报业的网站建设，还有就是舆情监控和数据可视化这些方向。 公司有Java后台和PHP后台，而在我入职之前，公司还没有一个前端。前端工作由PHP后端来兼任。UI方面没有设计师。 公司没有完善的编码标准和技术规范。 公司的前后端开发也没有做到完全分离，开发的过程是前端写好页面拿给后端，然后后端再在页面的基础上进行二次开发嵌入数据。 这样的开发模式并不好。 因为需求随时可能会变，客户可能中途要求做更改。那么嵌入了PHP代码的页面前端这边拿回来会因为没有环境的原因无法调试，而后端有不能很好的做好样式的修改。 现在相对还好点，前端团队有2个人了，公司也有招了一个设计师妹子。 我有在考虑一个问题就是，我作为一个前端新人，也没有别的员工的资历老。 当然对前端来说，我肯定比他们更了解。 那么我是否可以建议公司推进技术改革。 我们前端目前的开发技术栈是 Gulp 做自动化构建 使用browser-sync模块进行文件改动监听和浏览器自动刷新 使用less模块将less编写的样式编译为CSS，同时使用gulp-autoprefixer模块为样式添加浏览器私有前缀。 使用Github进行团队规范和公有资源管理，目前规范等在建设中，使用Coding进行项目开发进行的版本控制。 使用Gulp做自动化构建由我引入到团队的，目前团队的规范和资源也在由我进行开发和维护。 新人前端也是我面试招聘来的。 面试了十几个人，有的连个水平垂直居中都写不出来，真是心蛮累的。 现在的这个同学还是比较满意的。 工作了半年多的感受就是： 前端对设计的依赖性很大(尤其是页面的订制化很高，难复用) 客户频繁改需求真的很烦(遭遇过整个项目布局方面全部重写的情况) 沟通能力很必要，可能这也是做技术的人的弱势(群里看到客户提问，去回答，结果闹的不愉快) 工作量和代码量不存在必然联系(技术难点寻求解决方案比做重复的简单工作更有价值) 不要轻易对工时许诺，留下余地，这点可以参考霍夫斯达特定律。 霍夫史达特定律：事情总是要比你预期的花费更长的时间，甚至当你把本定律考虑在内时也一样。——Douglas Hofstadter 公司最近好久在做的是大屏的数据可视化方面的项目，基本是用Echarts来实现数据可视化和定时更新，我觉得在页面内开多个定时器的体验蛮差的。 而本身项目并不存在浏览器兼容问题，我觉得使用WebSocket才是更好的方案，再把逻辑都封装到后端，前端的工作就是接收数据、数据展现和页面效果。 但是我拿到数据后，通常还需要对数据再进行加工处理才能用。而且感觉后端同学对于接口是该用Json还是数组有点没搞明白。 前两天看到了Facebook的GraphQL，不由得感觉，这可真是个好东西啊，由前端决定自己需要的数据，有点CommandQuery的感觉。 不过我们公司能用上吗？ 不过个人还是希望能将公司的技术推进一点。比如目前在做的维护了一个样式重置库，并且要求至少前端都统一使用这个样式重置库。 下一步要实现的是代码风格，命名上的文档和常用Javscript的Utils库的封装。 2018年，希望能多少推进点公司的技术栈，让自己的开发过程也变的轻松开心点。 最后2017再见，2018你好。 1&lt;/2017&gt;&lt;2018&gt;]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门命令大全]]></title>
    <url>%2Fgit-abc%2F</url>
    <content type="text"><![CDATA[版本控制软件有助于合理高效地管理自己开发项目的各个版本，它可以提供便捷回退功能和多人协作开发功能。 Git介绍Git是由Linux系统之父Linus Torvalds为管理Linux内核开发而开发出的一个免费开源的分布式版本控制系统软件。 Git的Github页面 Git官网 下载安装Git可以从Git官网官网免费下载得到，注意选择适合自己操作系统的版本(Windows, Linux MacOS)。 安装过程非常简单，各种常见软件的安装方式即可。 安装结束后，打开Terminal(Windows系统打开cmd.exe, Powershell或者Git Bash)。键入如下命令: 1$ git --version # =&gt; git version 2.14.0 返回版本号即为安装成功。 配置刚开始使用的时候我们需要全局配置用户名和邮箱: 123$ git config --global user.name 'ntnyq'$ git config --global user.email 'me@ntnyq.com' --global参数代表全局进行配置 我们可以通过如下命令来查看当前配置: 123$ git config -l$ git config --list 版本库Git的分布式就体现在它并不单单将版本库保存在服务器上，每个参与项目开发开发的人都可以拥有一个自己的该项目的版本库。 我们可以在自己的版本库里面创建分支，再随着开发进度将分支的内容合并到主分支(master)上，再将主分支推送到服务器上。 我们可以通过2种方式在本地创建版本库。 新建版本库123$ git init # 本地新建版本库$ git clone git_repo_url # 从远程获取版本库 支持多种协议 命令执行后会在根目录下生成一个名为.git的隐藏文件夹来保存仓库的版本信息。 同时Git会自动追踪根目录下所有文件夹及文件夹内所有文件的变化。 可以通过如下命令来查看当前版本库的状态信息: 1$ git status 提交Git仓库管理的文件分为以下3种状态。 Modified 已修改 Git追踪到了文件的修改，触发了版本的变化，必须要对已修改的文件进行操作。(取消修改或者缓存)。 Staged 已缓存 缓存用于提供给开发者一个再次检查的机会，避免将不需要Git追踪的文件提交到版本库。 Commited 已提交 当文件处于已提交的状态时，它就可以Push到远程版本库了。 缓存修改123$ git add file_name # 添加文件至缓冲区$ git add . # 添加所有追踪的修改 提交修改12345$ git commit -m commit_description # 描述信息用于方便查看提交记录$ git commit -am commit_description # 提交当前所有修改$ git commit --amend # 修改上次提交的信息 会进入编辑界面 分支分支的存在是Git的一个亮点。我们可以通过在分支上进行开发，在开发到达某个阶段后，再把分支合并到主分支上。 查看分支12345$ git branch # 查看当前分支$ git branch -a # 查看所有分支 包括远程$ git branch -r # 查看远程分支 创建分支123456$ git branch branch_name # 根据当前版本创建分支$ git checkout -b branch_name # 创建分支并且将当前工作区切换到创建的分支$ git checkout -t origin/branch_name # 拉取远程分支 在本地创建 并跟踪 切换分支1234567$ git checkout - # 切换至上一个分支 用于2个分支间切换$ git checkout branch_name # 切换版本库至指定分支$ git checkout commit_hash # 切换版本库至对应提交的版本$ git checkout tag_name # 切换到对应标签版本 在分支的开发结束后 要记得在分支进行 git commit操作。 合并分支将某分支合并到master分支 需要先切回至主分支 1$ git merge branch_name 合并分支的过程分为4步： 保持工作目录clean git checkout master 切换回主分支 git merge branch_name 合并分支 如果有冲突问题，解决冲突 master push前，在分支上merge master。然后，在master上，merge分支，再push 删除分支确保当前不处于即将要删除的分支上，否则无法进行删除操作。执行如下命令即可删除分支： 1$ git branch -d branch_name 若当前分支存在修改未合并，则需要使用以下命令来强制进行删除： 1$ git branch -D branch_name 创建标签标签常用于标记特殊版本，如可发布的版本等。(可以利用标签名迅速切换到标签对应的版本) 12345$ git tag # 查看当前仓库的标签信息$ git tag tag_name -m tag_description # 给当前版本打标签 并加上描述(可选)$ git tag tag_name -m tag_description commit_hash # 给对应的commit打标签并添加描述 取消所有修改1$ git checkout . 版本库日志查看 在查看提交信息时候可以使用PU和PD来翻页，使用q退出日志查看。 12345$ git log # 显示版本库信息 包括 提交hash 提交人 提交日期 提交描述$ git log --oneline # 简略哈希显示 且只显示提交描述 此查看方式方便版本切换$ git log --graph # 以简单地图形化的形式展示提交记录 远程版本库1234567891011$ git remote # 查看远程主机名 默认远程主机名为origin$ git remote -v # 查看远程主机的网址$ git remote show [host_name] # 查看远程主机详细信息$ git remote add [host_name] [url] # 添加远程主机$ git remote rm [host_name] # 删除远程主机$ git remote rename [old_name] [new_name] # 重命名远程主机 拉取与推送12345678910$ git pull [remote_host] [remote_branch]:[local_branch] # 拉取远程分支 与本地分支合并$ git push [remote_host] [local_branch]:[remote_branch] # 将本地分支推送至远程主机$ git pull [remote_host] # 本地的当前分支自动与对应的origin主机的追踪分支(remote-tracking branch)进行合并。$ git push [remote_host] # 当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略$ git pull # 当前分支自动与唯一一个追踪分支进行合并$ git push # 当前分支只有一个追踪分支，那么主机名都可以省略 git pull拉取时候，如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git push推送时候，如果远程分支不存在，则会被新建。 可选参数 u 进行持续的跟踪操作，下次提交或者拉取代码无需再指定分支和主机。 合并与变基12$ git merge # 用"pull"命令把"origin"分支上的修改拉下来并且和你的修改合并；$ git rebase # 结果看起来就像一个新的"合并的提交"(merge commit) 冲突解决Merge冲突解决Tips: 你可以根据如下步骤解决冲突： 12345678910111213141、git fetch2、git checkout releases/xxx # 注:如本地还未检出过发布分支，请执行 git checkout -b releases/xxx origin/releases/xxx3、git pull4、git merge --no-ff b109eff1348a2fcf9a793deb81f3981d691e453c # 使用版本号合并,将出现的冲突一一解决5、git status 查看冲突，并按命令提示进行修复6、git add xxx git commit xxx7、git push origin releases/xx Rebase冲突解决 git rebase与git merge的另一个区别就是它解决冲突的时候是一个一个解决的，解决步骤如下： 123$ git add -u$ git rebase --continue 退出rebase的过程，恢复先前的代码，可以使用git rebase --abort来退出并回退修改。 帮助文档1$ git cmd_name --help # 打开对应命令的在线网页帮助文档 内有命令的参数详细解释 Git冲突描述在我们合并，拉取代码时候，经常会遇到文件冲突的问题。 打开冲突文件后，通常会看到一系列的=&gt;&gt;&lt;&lt;符号： 1234567891011121314"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;" # 表示冲突代码开始"===========" # 表示冲突文件的不同版本的分界"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;" # 表示冲突代码的结束# 实例&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;name: bar==============name: foo&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 其它123456789$ git fetch [remote_host] [branch_name] # 取回远程主机的分支$ git checkout . # 取消本地所有未提交的修改$ git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。$ git reset --hard HASH #返回到某个节点，不保留修改。$ git reset --soft HASH #返回到某个节点。保留修改 参考资料我所记录的git命令]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Underscore源码阅读[1]]]></title>
    <url>%2Funderscore-source-code-1%2F</url>
    <content type="text"><![CDATA[为了提高自己的JavaScript姿势水平，也是在很多人的推荐下，决定阅读Underscore源码。 结构 阅读的源码版本为v1.8.2 Underscore.js 中文文档 代码分析123(function () &#123; // details here&#125;.call(this)); 整个库被写在一个闭包里面，以免受到别的全局变量的影响。 1var root = this; 创建root变量 保存this对象 在浏览器中使用时为window对象 在服务器为exports对象 1var previousUnderscore = root._; 如果root对象下的_变量有值，那么将其存起来 123var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype; 将以上对象的原型保存到变量中，方便后期进行uglify生成minified版本 1234var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; 创建参考，方便直接使用对象的原型方法 1234var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create; 声明将要用到的ES5原生方法 1var Ctor = function () &#123;&#125;; 可复用的构造函数用来设置原型 12345var _ = function (obj) &#123; if (obj instanceof _) return obj; if (!(this.instanceof _)) return new _(obj); this._wrapped = obj;&#125; 创建_变量来作为underscore对象的引用 12345678if (typeof exports !== 'undefined') &#123; if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; exports = module.exports = _; &#125; exports._ = _;&#125; else &#123; root._ = _;&#125; 在nodejs环境下用module.exports导出underscore对象 同时还向后兼容require()方法，如果是浏览器环境，则将_作为一个全局变量。 1_.VERSION = 'x.x.x' 保存版本信息 参考资料underscore库源码解析]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages个人域名升级为HTTPS]]></title>
    <url>%2Fgh-pages-blog-upgrade-https%2F</url>
    <content type="text"><![CDATA[给你的hexo博客域名加上HTTPS认证。 HTTPS简单讲，HTTPS就是HTTP更加安全的版本。实现原理是在HTTP下加入了SSL层，通过身份认证，来保证数据传输的安全。 而网站升级HTTPS，需要CA(Certificate Authority)机构wosign的颁发的SSL(Secure Sockets Layer 安全套接层)证书。 然而，Github Pages无法上传SSL证书。 CloudFlareCloudFlare是一家CDN提供商，它提供了免费的HTTPS服务(但不是应用SSL证书)。 实现的方式：用户到CDN服务器的连接为HTTPS，而CDN服务器到Github Page服务器的连接为HTTP，就是在CDN服务器那里加上反向代理。 CloudFlare官网 注册注册并登陆CloudFlare，并将自己域名下的Name Server修改为CloudFlare的Name Server。 比如我的域名是在万网购买的。 进入万网域名列表页面，选择要更改NS的域名，点击后面的管理。 在基本管理-&gt;基本信息页面 选择 修改DNS 然后填写CloudFlare的Name Server值。 解析在CloudFlare控制台的DNS面板将域名解析到Github Pages。 Crypto设置在CloudFlare控制台的Crypto面板设置 SSL为Flexible。 Page Rules设置在CloudFlare控制台的Page Rules面板设置路由规则。 利用Always use https设置两条规则，规则链接分别为http://domain.com/*与http://domain.com/(开启https强制跳转)。 大功告成 参考资料Github Pages 个人域名完美支持https]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解WebSocket]]></title>
    <url>%2Fwebsocket-note%2F</url>
    <content type="text"><![CDATA[WebSocket协议是一种基于TCP协议的新型网络协议。它允许服务器推送消息给客户端，实现了浏览器和服务器之间的双工通信。 HTTPHTTP(超文本传输协议)是互联网应用最广泛的网络协议，但是它也有着自己的局限性。HTTP协议是单向，且无状态的。意思就是客户端(浏览器)发起一次HTTP请求，不管服务器能否进行正常的响应，响应结束后，这次通信就会断开。并且服务器不具备有主动向客户端(浏览器)发送消息的能力。 其局限性在面对如下应用场景时就会暴露出来： 服务器端的数据不定时更新，可能间隔很短，也可能间隔很长 实时双工的通信应，如即时聊天 当然，我们可以通过一些轮询的方法，来从功能上实现这个需求。 比如，我们可以设置一个请求间隔非常短的定时器，在需求的间隔下，不停地请求服务端，再根据服务端的相应来进行数据的更新。但是这无疑是很耗费性能的。 如果更新间隔非常长，那么可能我们大部分的请求都是无用的。 所以，我们需要一种能够双向实时通信的网络协议，来补足HTTP协议的局限。 WebSocket协议由此得以出现。 WebSocketWebSocket协议的连接，首先我们需要服务器对WebSocket的支持。我们通过浏览器发送一个WebSocket连接请求，然后服务器做出回应。这个连接的过程通常被称为握手。在握手后，服务器和浏览器之间就建立了一个数据传送通道，可以互相传送消息。 优点在建立了WebSocket连接后，服务器不需要再等待客户端请求数据才能做出相应，服务器可以在数据更新后主动向客户端推送此次更新。 APIHTML5的新特性内包含了一些WebSocket协议的API。 创建对象1var ws = new WebSocket(url, name); url为WebSocket服务器的地址，name为发起握手的协议名称，可选。 发送消息1ws.send(msg); msg为文本消息，字符串格式。其他类型可以通过二进制来发送。 接收消息123ws.onmessage = (function () &#123; // do something&#125;)(); 错误处理123ws.onerror = (function () &#123; // do something&#125;)(); 关闭连接1ws.close(); 兼容性Can I Use]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threejs入门基础。]]></title>
    <url>%2Fthreejs-adc%2F</url>
    <content type="text"><![CDATA[Threejs是一款轻量且易用的Web3d库。它将浏览器支持的WebGlAPI封装成简单易用的接口，方便学习和使用。他可以提供canvas, SVG, CSS3D和WebGl渲染器。 背景我为什么要学习Threejs呢？ 因为目前公司一部分业务做的数据可视化大屏方面，可以参考阿里云的dataV。 基本是主要利用图表做出低交互效果，视觉冲击力强，场景模块化的数据可视化网页。 关于插件的选择这点，我们主要用的是Echarts，毕竟它使用起来简单，只需要自定义配置项和传入数据就会生成好看的图表。 同时外包给我们公司的项目的那个公司的设计师大多时候也会针对先前实现的效果去做设计。 然而越高度封装的插件，也就会暴露一个问题--定制化麻烦。 比如我用Echarts做出来的地图效果，配色方面就一直被对方的设计和产品吐槽，所以我决定要学习写出更炫酷的效果。 恰好大屏也不需要考虑兼容性，本着炫酷的目的，那么自然就要搞3D了。 而且前两周在商讨的新大屏项目，客户的需求就是--做出类似dataV的效果。 上周五才拿到了第一张设计图，动画效果方面比先前增加了不少，不过暂时还没有出现3D效果。 和设计师沟通了一下，以后可以我能做出什么好的效果，给个Demo让他看看，这样也可以针对我的实现去设计，保证了技术上的可行性。 所以开始了我的Threejs踩坑之旅。 WebglMDN的Webgl文档 定义WebGl(Web Graphics Library)是一套封装好的JavaScript接口，在任何兼容的Web浏览器上都可以无需任何插件地渲染可交互的2D和3D图形。WebGl通过引进了一个与OpenGL ES 2.0很相近的API来实现此功能。它可以在HTML5的canvas标签中使用。 兼容性Can I Use - WebGl IE11+ 标准浏览器 需要注意的是它还需要设备GPU支持，所以在一些老版本的硬件可能无法兼容。 另外它并非是W3C的，而是Khronos Group的。 Threejs有句话说当我们吃鸡蛋的时候，并不需要关心它是哪只鸡下的。 同样的虽然有标准提供了原生的API，但是利用原生API去实现功能，锁需要的时间和精力都是巨大的。 幸运的是前人早就帮我们造好了轮子，而Threejs就是大家广泛使用的轮子之一。 下载首先我们要使用Threejs库，那么第一步就是要拿到它的源码了。 Threejs官方Github仓库 目前版本: r88 引入以js脚本的方式引入 1&lt;script src=&quot;./your-path-to/three.min.js&quot;&gt;&lt;/script&gt; 渲染器渲染器(Renderer)是利用canvas元素进行初始化的，它定义了渲染方式和一些渲染参数。它是Threejs的核心API之一。 创建渲染器创建渲染器时，可以传入一个对象进行配置。 1var renderer = new THREE.WebGLRenderer(option); 创建渲染器有2种方式： 初始化的时候设置canvas参数在，传入一个canvas节点 123var renderer = new THREE.WebGLRenderer(&#123; canvas: document.querySelector('canvas')&#125;); 初始化后将DOM节点添加至页面 1document.body.appendChild(renderer.domElement); 常用参数 antialias 抗锯齿优化 默认为false alpha 透明度支持 默认为false 等等 API常用API 设置渲染器的尺寸传入2个参数宽和高。 1renderer.setSize(width, height); 设置渲染器背景色传入一个十六进制数 1renderer.setClearColor(0x000000); 场景场景(Scene)定义了承载物体的容器和观察的视口。它是Threejs的核心API之一。 初始化1var scene = new THREE.Scene(); 几何体，光照等元素必须要加入到场景中才能被渲染。 API1scene.add() 相机相机(Camera)定义了观察的角度位置和方式。它是Threejs的核心API之一。 正交相机正交相机是假定物体处于正交坐标系下，对物体的投影和观察结果。本来平行的线，在正交坐标系中会依然保持平行。但是在景深相机中观测就无法保证。 1var camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far); left right top bottom代表坐标系距离渲染器4条边缘的偏移量。near靠近相机的位置，far远离相机的位置。 景深相机景深相机更加符合人们观察物品的实际情景，同样的尺寸，离得近会显得大，离得远的会显得小。 1var camere = new THREE.PerspectiveCamera(fov, aspect, near, far); fov代表视口张角，aspect代表视口比例(通常设置为渲染器的尺寸宽高比)，near靠近相机的位置，far远离相机的位置。 设置相机坐标1camera.position.set(x, y, z); 设置相机观测目标1camera.lookAt(); 网格网格(Mesh)通过规则的线条或者面来绘制基础的几何体。它是Threejs的核心API之一。 1var mesh = new THREE.Mesh(geometry, material); 初始化一个网格，需要指定2个参数geometry(几何体)和material(材质)。 示例创建一个正方体。 123456var geometry = new THREE.BoxGeometry(size, size, size), material = new THREE.MeshNormalMaterial();var mesh = new THREE.Mesh(geometry, material);scene.add(mesh); 参考资料Threejs Threejs入门指南 - 羡澈]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Three</tag>
        <tag>WebGl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入探究CSS3渐变的那些事儿。]]></title>
    <url>%2Fcss-gradient-guidence%2F</url>
    <content type="text"><![CDATA[渐变的存在可以实现一些简单的背景图形，避免我们使用图片。虽然早先也有学习过，不过在用的时候却经常写错，或者写不出自己心中想要的效果，所以在此深入整理一下API。 渐变简介CSS3渐变(gradient)分为线性渐变(linear-gradient)和径向渐变(radial-gradient)两种。 线性渐变线性渐变代表渐变是线性的，也就是方向是一个单一的向量。 兼容写法因为浏览器内核的不同，我们需要使用浏览器厂商前缀的兼容写法： 1234background: linear-gradient([&lt;point&gt; || &lt;angle&gt;] ? &lt;stop&gt;, &lt;stop&gt;[, &lt;stop&gt;]*); // 标准写法background: -webkit-linear-gradient([&lt;point&gt; || &lt;angle&gt;] ? &lt;stop&gt;, &lt;stop&gt;[, &lt;stop&gt;]*);background: -moz-linear-gradient([&lt;point&gt; || &lt;angle&gt;] ? &lt;stop&gt;, &lt;stop&gt;[, &lt;stop&gt;]*);background: -o-linear-gradient([&lt;point&gt; || &lt;angle&gt;] ? &lt;stop&gt;, &lt;stop&gt;[, &lt;stop&gt;]*); 参数解析参数： angle 是角度 单位为deg point 代表线性渐变的方向 可用关键字包括left, right, top, bottom, to left, to right, to bottom, to top等，也可以是例如to left top代表从左上到右下，to可省略。 stop参数代表color [&lt;length&gt; || &lt;percentage&gt;] 即颜色 + 长度或者百分比 color 渐变的起止颜色 length 长度来指定渐变的起止位置 不可用负数 此参数可选 没有的话按颜色数量平均分配 percentage 用百分比来指定渐变的起止位置 此参数可选 兼容性CSS3渐变浏览器兼容性：IE10+ 例子1234background: linear-gradient(left,red,orange,yellow,green,blue,indigo,violet);background: -webkit-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet);background: -moz-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet);background: -o-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); 角度写法角度写法可以理解为一个以最高点为0度位置的圆。角度代表的方向就是从圆心到顺时针方向所指向的圆周上的一点，这两点连线的方向。所以0度代表的渐变是从下往上的，90度代表的渐变是从左向右的。 重复的线性渐变重复的线性渐变创建方法如下： 1234background: -webkit-repeating-linear-gradient(red, yellow 10%, green 15%);background: -o-repeating-linear-gradient(red, yellow 10%, green 15%);background: -moz-repeating-linear-gradient(red, yellow 10%, green 15%);background: repeating-linear-gradient(red, yellow 10%, green 15%); 径向渐变径向渐变是从中心上圆周发散的渐变形式。 创建一个径向渐变，至少需要定义2种颜色。同时，需要指定渐变的中心，形状(圆形或者椭圆)、大小。默认情况下，渐变的中心是center(就是中心点)，渐变的形状是ellipse(椭圆形)，渐变的大小是farthest-corner(最远的角落)。 语法：1background: radial-gradient([&lt;position&gt; || &lt;angle&gt;,]? [&lt;shape&gt;] [&lt;size&gt;,]? &lt;color-stop&gt;, &lt;color-stop&gt;[, &lt;color-stop&gt;]*); 参数解析 position 定义径向渐变的圆心位置 默认center 可选top、left、bottom、right、center、&lt;length&gt;、&lt;percentage&gt; shape 定义渐变形状 2个可选值circle和ellipse size 定义渐变结束形状的大小 可选值 closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边； losest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角； farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边； farthest-corner：指定径向渐变的半径长度为从圆心到离圆心最远的角； stop 与线性渐变相同 例子1234background: -webkit-radial-gradient(white, green, orange);background: -o-radial-gradient(white, green, orange);background: -moz-radial-gradient(white, green, orange);background: radial-gradient(white, green, orange); 重复的径向渐变1234background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%);background: -o-repeating-radial-gradient(red, yellow 10%, green 15%);background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%);background: repeating-radial-gradient(red, yellow 10%, green 15%); 参考资料css3 Gradient渐变||TG的博客 Demo待续…]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>渐变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装Nodejs环境]]></title>
    <url>%2Fubuntu-install-nodejs-guidence%2F</url>
    <content type="text"><![CDATA[打算将开发的主环境迁移到Linux系统上，所以空闲时间开始慢慢折腾了。 目前的进度是在Virtualbox上面安装了Ubuntu 16.0.4系统，安装了中文输入法，Sublime Text编辑器以及相关开发插件，安装了Nodejs环境。 所以这里记录一下遇到的一些问题和解决方案。 复制粘贴虚拟机和主机之间的复制粘贴问题。 问题情境我想将Sublime的配置导入Linux环境下，用了比较蠢的复制粘贴的方式。但是发现竟然不起作用。即使我将虚拟机的 设备 =&gt; 共享粘贴板 =&gt; 双向 已经勾选。 解决方法VirtualBox =&gt; 存储 =&gt; 控制器：SATA 勾选 使用主机输入输出(I/0)缓存 再点击 ubuntu.vdi 勾选 固态驱动器 参考资料百度经验 - VirtualBox主机与虚拟机不能复制粘贴的解决办法 安装Nodejs以下操作都在Terminal环境中执行。 下载安装包1wget https://nodejs.org/dist/v8.9.1/node-v8.9.1-linux-x64.tar.xz 解压解压node-v8.9.1-linux-x64.tar.xz文件获得node-v8.9.1-linux-x64.tar文件 解压node-v8.9.1-linux-x64.tar文件获得node-v8.9.1-linux-x64文件夹 123xz -d node-v8.9.1-linux-x64.tar.xztar xvf node-v8.9.1-linux-x64.tar 移动目录将node-v8.9.1-linux-x64文件夹移动到/opt目录下并且命名为node文件夹 1sudo mv node-v8.9.1-linux-x64 /opt/node 建立链接需要建立node和npm的链接，这样就可以在全局环境适用node和npm命令了。 12sudo ln -s /opt/node/bin/node /usr/local/bin/nodesudo ln -s /opt/node/bin/npm /usr/local/bin/npm 检查版本12node -v // =&gt; v8.9.1npm -v // =&gt; 5.5.1 全局安装模块失效情境描述通过sudo cnpm install express-generator -g下载的模块，然后在Terminal输入express提示找不到命令 问题原因未正确设置Node的环境变量，导致下载的全局包无法被找到。 方案1 建立链接 到/usr/local/bin/module_name 方案2 配置全局变量 配置全局变量使用vim编辑器打开/etc/profile 在文档最后加入 1export $PATH=PATH:/opt/node/bin 再修改当前用户的配置文件~/.profile，同样的操作 再执行source .profile刷新配置文件 参考资料nodejs在linux安装、环境变量配置]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试芒果数据库mongodb。]]></title>
    <url>%2Fmongodb-abc%2F</url>
    <content type="text"><![CDATA[最近在学习express+mongodb建站，所以简单学习一下mongodb。 mongodb简介momgodb是一套noSQL形式的数据库管理系统。 与传统的以SQL语言语法为主的关系数据库相比，mongodb摒弃了它们的一些在现代应用开发中使用频度不高的特性，换来的却是执行效率的显著提升。再加上mongodb没有使用传统的表的概念，而是用集合，更方便进行扩展。 而mongodb的文档构建是以json的形式构建的，数据库的操作也是使用的对象方法的形式，方便我们前端程序员的学习和使用。 环境搭建下载搭建mongoDB环境需要安装mongoDB程序。 可以从mongodb官网下载当前稳定版本或者从github上下载github仓库上下载所需版本的二进制文件进行编译。 安装安装过程直接按照官方指引解压安装即可。 配置在软件根目录下创建data文件夹用来保存数据，创建log文件夹来保存运行日志。 在根目录下创建bin目录将相关可执行文件移入。 在根目录下创建mongo.config文件来保存配置信息。 输入以下配置: (具体根据个人配置进行更改) 123port=12345 // 指定mongo服务器端口为12345 默认端口为27017dbpath=D:\mongodb\data // 指定数据存储目录 这里使用了绝对路径 使用相对路径也可logpath=D:\mongodb\log\mongo.log // 指定日志文件命名 注意这里路径后面是文件 启动服务器运行bin目录下的mongod文件，为其指定配置文件为我们配置好的文件。 1mongod -f ../mongo.config // -f --fork指定保护模式 如果没有编写配置文件，也可以这样来启动: 1mongod --fork --logpath &lt;log_file_path&gt; --dbpath &lt;db_folder_path&gt; port &lt;portNum&gt; 当我们在本地成功启动mongo服务器后，可以在浏览器打开localhost:&lt;portNum&gt;进行查看。 12// 看到服务器返回这个字样 说明服务启动成功It looks like you are trying to access MongoDB over HTTP on the native driver port. 连接服务器运行bin目录下的mongo文件，就会连接服务器。 进入mongo的命令行交互界面。 基础命令mongodb基础的常用的命令。效果见上图。 数据库操作查看数据库12// 与mysql相比 这里不需要再末尾输入分号show dbs 切换数据库1use &lt;dbName&gt; // 切换到指定数据库名的数据库 若不存在则创建同名数据库 查看数据库中集合1show collections // 查看当前数据库包含的所有集合 删除某个集合1db.&lt;collectName&gt;.drop() 集合操作新建集合/插入记录1db.&lt;collectName&gt;.insert(&#123;name: &apos;ntnyq&apos;&#125;) // 向指定集合插入一条记录 查看集合1db.&lt;collectName&gt;.find() // 查看指定集合 无参数则返回集合中的所有记录 可以传入对象，返回符合条件的所有集合，如{name: ‘ls’}，返回所有name为ls的记录。 可以追加方法，实现别的功能比如skip, limit, sort等等。 mongodb会自动为存入的记录追加_id属性，作为一个唯一的值来标识一条记录。不过我们也可以手动指定一个_id，前提是不与集合中已有的_id冲突，否则插入失败，且会报错。 修改集合1db.&lt;collecName&gt;.update(&#123;name: &apos;ntnyq&apos;&#125;, &#123;name: &apos;lssham&apos;&#125;) // 指定更新符合条件的记录 这里会筛选，并且更新第一条记录，而且是采用的替换更新的方式。也就是用新的记录完全覆盖原先的记录。 如果我们需求增量更新，那么我们讲第二个参数指定为{$set: {name: ‘lssham’}} 如果我们需要一次修改多条符合要求的数据，可以追加参数false, true ## 踩坑记录记录使用时候踩到的坑。 解决办法不一定适合每个人，不过可以尝试一下。 客户端连接5秒断开可以通过运行mongod.exe正常开启server端，但是运行mongo.exe打开客户端连接服务器时候就会报下面的错误，无法正常进入MongoDB的命令行交互界面。 1# failed to connect to 127.0.0.1:27017 after 5000ms milliseconds, giving up. 解决办法：关闭Windows Defende防火墙，或者设置Mongo服务到防火墙白名单。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML跳转期间传递消息。]]></title>
    <url>%2Fcross-html-deliver-msg%2F</url>
    <content type="text"><![CDATA[最近在做一个小项目，需要再首页点击后，页面跳转，同时利用点击的这个元素的信息生成一个页面。那么就要把这些信息传递到下一个页面。 构思起先我的想法是利用H5的本地存储或者cookie来实现，就是把信息暂存到cookie或者本地存储里面，在另一个页面打开后再去读取这个值。如果读取到了就生成这个页面。 本地存储实现经测试可行 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;页面1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="test2.html" msg="我是本地存储的文本"&gt;&lt;/a&gt; &lt;button id="btn"&gt;测试&lt;/button&gt; &lt;script&gt; window.onload = function () &#123; var btn = document.querySelector('#btn'); var a = document.querySelector('a'); btn.onclick = function () &#123; localStorage.setItem('msg', a.getAttribute('msg')); alert('done!'); &#125;; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;页面2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onload = function () &#123; alert(localStorage.getItem('msg')); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; cookie测试待测试中 查询结果url的search段url的search段实现，可行 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;页面1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="test2.html" msg="我是存在查询段的文本"&gt;&lt;/a&gt; &lt;button id="btn"&gt;测试&lt;/button&gt; &lt;script&gt; window.onload = function () &#123; var btn = document.querySelector('#btn'); var a = document.querySelector('a'); btn.onclick = function () &#123; window.location.href = 'test2.html?msg=' + a.getAttribute('msg'); &#125;; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;页面2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onload = function () &#123; alert(decodeURIComponent(window.location.search).split('=')[1]); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 哈希段将内容存至url的hash段仍然可行 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;页面1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="test2.html" msg="我是存在哈希段中的文本"&gt;&lt;/a&gt; &lt;button id="btn"&gt;测试&lt;/button&gt; &lt;script&gt; window.onload = function () &#123; var btn = document.querySelector('#btn'); var a = document.querySelector('a'); btn.onclick = function () &#123; window.location.href = 'test2.html#msg=' + a.getAttribute('msg'); &#125;; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;页面2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onload = function () &#123; alert(decodeURIComponent(window.location.hash).split('=')[1]); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我做了一个小demo来演示一下， 可以点击在线测试效果。 点我----在线演示DEMO吧！！！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node内置模块fs简单文件操作]]></title>
    <url>%2Fnode-fs-module%2F</url>
    <content type="text"><![CDATA[简单学习一下Node的fs模块，写一些小的脚本，实现一些小功能。 希望能够通过学习，替代一些需要人力去实现的工作。 fs简介fs即文件系统file system的意思。 它是Node内置的原生模块之一，这意味着你不需要通过下载依赖就可以使用它。 只需在要使用它的地方使用如下的方式进行引入即可。 1const fs = require('fs'); 以下代码都默认已经引入了fs模块 Node环境为我们提供了利用JavaScript语法去操作文件的能力，而这种能力是浏览器环境下的javascript所不具有的。 读文件在脚本的同级目录下创建文件hello.txt，内容放上Hello world。 同步文件读取如果不指定读取方式的字符集，那么默认的读取字符集是Buffer类型的数据。 123let data = fs.readFileSync('hello.txt', 'utf-8')console.log(data) // Hello world 异步文件读取 更推荐使用异步方法，因为这不会阻塞程序的执行。 123456fs.readFile('text.txt', 'utf-8', (err, data) =&gt; &#123; if (err) return; console.log(data) // Hello world&#125;); 写文件可选的flag参数： w 写入文件 a 追加文件 r 读取文件 12345fs.writeFile('text2.txt', 'Hello ntnyq', &#123; flag: 'w'&#125;, err =&gt; &#123; if (err) return; console.log('File saved!');&#125;); 创建目录在当前目录下创建名为text的新目录。 若目录已经存在，则提示file already exists的错误。 123456fs.mkdir('text', err =&gt; &#123; if (err) return console.log('Dir maked!');&#125;); 读取目录读取目录下的所有文件，返回读取的目录下包含的所有文件名的数组。 若目标目录为空目录，那么得到的结果会是一个空数组。若目标目录不存在，则会直接报错ENOENT: no such file or directory。 123456fs.readdir('foo/bar', (err, files) =&gt; &#123; if (err) return; console.log(files);&#125;); 获取文件信息利用如下方法可以读取文件信息对象，可以再利用对象的方法来做别的判断。 isFile() 是否为文件 isDirectory() 是否为目录 1234fs.stat('text.txt', (err, stats) =&gt; &#123; console.log(stats); // 文件信息对象 console.log(stats.isFile()); // true&#125;); 创建读取流1let stream = fs.createReadStream('text.txt'); 创建写入流1let stream = fs.createWriteStream('text.txt'); 参考资料node文件批量重命名]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试AngularJS框架]]></title>
    <url>%2Fangular-js-abc%2F</url>
    <content type="text"><![CDATA[因为工作的原因，暂时研究的版本是ng1。有机会的话打算认真研究一下2和4版本的。 指令123456789101112131415161718192021- ng-app 可以在任何节点上使用将其定义为ng应用- ng-model 双向数据绑定 数据展现也是&#123;&#123;&#125;&#125;形式- ng-controller 明确创建一个$scope对象- ng-click 绑定鼠标单击事件- ng-init 初始化变量的值- ng-bind 用于绑定数据到dom- ng-bind-html 输出html 但是要先对数据使用$sec模块的trustAsHtml()方法- ng-repeat 循环数组或者json- ng-show/ng-hide 控制DOM显示隐藏- ng-submit 提交表单- ng-disabled 元素不可用 模块angular.module函数集合应用被启动时候，这些函数就会执行 12// 定义一个名为myApp的模块var app = angular.module('myApp', []); 这个模块可以通过ng-app属性挂载到页面上 Scopes$scope用户把dom元素和controller连接起来 在mvc架构里$scope就是model, 提供一个绑定到dom的执行上下文 它其实是一个javascript对象view和controller都可以访问到它 我们可以在这个对象身上存储数据和运行在view上的函数 每一个ng应用都会有一个顶级的$rootScope，对应着有ng-app指令元素的那个Dom元素。 如果页面上没有明确设定$scope，ng就会把数据绑定到$rootScope上。 在页面绑定了controller的话，需要用app.controller来注册和修改。 除了一个例外，所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。 唯一的例外：有些指令属性可以选择性地创建一个独立的scope，让这个scope不继承它的父scope们。 123456app.controller('ControllerName', ['$scope', function ($scope) &#123; $scope.xx = xxx; $scope.xx = function () &#123; // do something &#125;&#125;]) 数据绑定采用ng-model指令可以把是数据绑定到文本框上也可以使用模板展现语法或者ng-bind来展现数据 对按钮或者超链接，可以使用另一个指令来绑定ng-click ajax使用$http函数来进行数据请求 然后将获取的数据挂到$scope上面需要显示地引用$http模块 如下 12345678910111213141516app.controller('ControllerName', function ($scope, $http) &#123; $http(&#123; url: '', method: '' &#125;).success(function (data, status, headers, config) &#123; // do something $scope.xx = data.xxx &#125;).error(function (data, status, headers, config) &#123; &#125;)&#125;)// 或者app.controller('ControllerName', ['$scope', '$http', function($scope, $http) &#123;&#125;]) 指令属性指定在应用被创建的时候由ng-app的开始被收集 指令属性拥有自己的优先级 ng-model的实现是在这个值上绑定了$watch函数 模板展现语法会对里面的表达式使用$watch函数进行监听 ng-init 应用启动前时运行的函数 可以在程序运行前设置初始变量的值 1&lt;b ng-init="name='ntnyq'"&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/b&gt; ng-click 给按钮或者link绑定点击事件 当事件发生 则执行绑定在$scope的函数或者表达式 ng-show/ng-hide 根据表达式计算后的布尔值来决定所属的DOM的现实或者隐藏 ng-repeat 遍历数据集合中的每个数据元素,再使用模板渲染出来每个使用模板渲染的DOM元素都有自己的scope 表达式 表达式会在scope这个上下文里被执行 所以可以使用$scope中的变量 表达式执行出错 错误不会被抛出 表达式里不允许进行流程控制 表达式可以接收一个或者多个串联起来的过滤器 自定义指令目的 更加模块化 方便管理 使用自己创建的指令 减少复杂性 指令命名使用小驼峰形式 使用指令时候用横线小写形式。 1234567891011121314app.directive('ntNyq', function() &#123; return &#123; restrict: 'A', replace: true, scope: &#123; myUrl: '@', // 绑定策略 myLinkText: '@' &#125;, template: '&lt;a href="&#123;&#123;myUrl&#125;&#125;"&gt;' + '&#123;&#123;myLinkText&#125;&#125;&lt;/a&gt;' &#125;;&#125;)// 使用&lt;div nt-nyq my-url="https://google.com" my-url-text="click me"&gt;&lt;/div&gt; 其中restrict取值有 E，A，C，M。决定指定的使用方式，分别为元素，属性，类，注释。默认为EA，可以一次使用多个。 绑定策略也可以为等号=someAttr 然后在使用指令时候找some-attr属性 ServicesServices都是单例的 每一个应用中，service对象只会被实例化一次($injector) 主要负责提供一个接口把特定函数需要的方法放在一起 比如$http，$window，$route，$location 在AngularJS中我们可以轻松建立自己的services，只需要通过注册service即可，一旦注册，编译器就可以找到并加载他们供程序执行时候随时用 12345678910// 用angular.module API的factory模式创建servicesangular.module('myApp.services', []) .factory('githubServices', function () &#123; var serviceInstance = &#123;&#125;; return serviceInstance; &#125;)// 另外还可以使用內建的$provide service来创建service使用service创建服务 还可以注入已经可用的服务 创建一个service就是简单的返回一个函数，这个函数返回一个对象。这个对象是在创建应用实例的时候创建的 123456789101112131415161718192021222324252627282930313233343536373839// 创建与使用serviceapp.factory('githubService', ['$http', function ($http) &#123; var doRequest = function (username, path) &#123; return $http(&#123; method: 'jsonp', url: 'https://api.github.com/users/' + username + '/' + path + '?callback=JSON_CALLBACK' &#125;); &#125;; return &#123; events: function (username) &#123; return doRequest(username, 'events'); &#125; &#125;;&#125;]);app.controller('ServiceController', ['$scope', 'githubService', function ($scope, githubService) &#123; $scope.$watch('username', function (newUsername) &#123; githubService.events(newUsername).success(function (data, status, headers) &#123; $scope.events = data.data; &#125;); &#125;);&#125;]);// html&lt;div ng-controller="ServiceController"&gt;&lt;label for="username"&gt;Type in a Github username&lt;/label&gt;&lt;input type="text" ng-model="username" placeholder="Enter a Github username" /&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr ng-repeat="(type, value) in events"&gt; &lt;td&gt;&#123;&#123; type &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; value &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; 注意我们要遵守Angular services依赖注入的规范：自定义的service要写在内建的Angular services之后，自定义的service之间是没有先后顺序的 不要在controller中有任何的操控DOM的行为，如果这么做会污染你的controller并留下潜在的隐患 $document內建服务，代表window.document元素的(所有html页面里javascript的根对象)引用 12// 这样使用 相当于document$document[0] 通过注入$rootScope，可以来监听全局的属性 在事件中可以这样来调用局部的方法 1$rootScope.$apply(xxx.xx()) Routing在单页面应用中，Routing功能用来控制视图之间的跳转，决定呈现什么内容给用户。 虽然我们可以在主页面中通过引用不同的模板来实现，但是这样会让代码臃肿凌乱，不方便管理。 通过ng-include指令 可以把很多的模板整合在视图中 不过我们可以通过将视图，打散成小模块，变成layout和template来实现根据特定的URL显示不同的内容 AngularJS通过在$routeProvider($route服务的提供者)上面声明routes来实现上述功能。 实现方案 布局 通过ng-view指令将告诉$routePovider在哪里渲染模板 配置需要的路由信息 $routeProvider提供了两种方法来处理路由 when 方法when接收2个参数 设置$location.path() 也可以直接用’//‘ 参数的配置对象 controller如果在配置对象中设置了controller属性，那这个controller会在route加载的时候实例化，这个属性可以是一个字符串(必须在module中注册过的controller)也可以是controller function Template模板 1template: '&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/div&gt;' 如果我们在配置对象的template属性设置了值，那么模板就会被渲染到DOM中的ng-view处 templateUrl 模板的地址 如果我们在配置对象的templateUrl属性中设置了值，AngularJS将通过XHR来获取该模板并把模板内容渲染到DOM中的ng-view处 值得注意的是：templateUrl属性跟其他AngularJS XHR请求的处理流程是一样的，也就是说，即使用户从这个页面离开，等他再回到这个页面，应用不会再去请求这个模板页面，因为$templateCache已经缓存了这个模板 添加一些路由 $routeProvider还可以处理URL里的传递的参数(比如，/people/42, 假设42是我们要找的people的id号) 只需要简单在字符串前加上 ‘:’,$routeProvider会尝试匹配URL中id并把id作为key在$routeParams服务中使用 otherwise 1234567891011// 路由定义实例angular.module('myApp', []) .config(['$routeProvider', function ($routeProvider) &#123; $routeProvider.when('/', &#123; controller: 'ControllerName', template: '&lt;h2&gt;Lorem ipsum dolor sit.&lt;/h2&gt;' &#125;) .otherwise(&#123; redirectTo: '/' &#125;) &#125;]) 过滤器filter提供了一种格式化数据的方法，Angular也提供给我们了很多内建的过滤器，并且建立自定义过滤器也是相当的简单 在HTML的模板绑定中，我们可以使用竖线 来调用过滤器，比如，我们想让字符串全部大写字符显示 1&#123;&#123; name | uppercase &#125;&#125; 也可以用$filter內建服务来调用过滤器 1$scope.name = $filter(&apos;lowercase&apos;)(&apos;Arial&apos;) 给filter传递参数 在filter后面加冒号 再加上参数 比如 12// 限制数字位数 显示小数的话 加上位数就可以&#123;&#123; 213123.2132 | number: 2 &#125;&#125; 常用过滤器 12345currency 数字转货币123 =&gt; $123.00可以设置参数 来决定货币符号 12345678date默认date: 'mediumDate' Oct 28, 2017常用date: 'medium' Oct 28, 2016 8:15:25 AMdate: 'shortTime' 05:32 AMdate: 'shortDate' 11/23/16date: 'short' 10/29/17 8:25 AM 1234567891011// filter过滤器主要用来过滤一个数组数据并返回一个包含子数组数据的新数组filter参数true： 执行严格的匹配比较（跟’angular.equals(expected,actual)一样）false： 执行大小写敏感的substring匹配Function 执行一个函数并且接受一个元素 前提是返回真$scope.isCapitalized = function(str) &#123; return str[0] == str[0].toUpperCase(); &#125; 123json接收JSON或者JS对象 转化成字符串 1limitTo 限定字符或者数组的长度 参数为整数 12345lowercase 小写uppercase 大写Number 数字 若非数字 会返回空字符串&#123;&#123; 1234567890 | number &#125;&#125; 1,234,567,890 123456orderBy通过给定的表达式对数组进行排序接受2个参数第一个决定排序方式是 创建自定义的过滤器 12345678angular.module('name', []) .filter('filterName', function () &#123; return function (input) &#123; if(input) &#123; return input[0].toUpperCase() + input.slice(1) &#125; &#125;&#125;) 参考资料七步从Angular.JS菜鸟到专家系列文章]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>JS框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常用指令]]></title>
    <url>%2Fvue-directives-guidence%2F</url>
    <content type="text"><![CDATA[vue.js是一个构建数据驱动的 web 界面的渐进式框架。 npm下载安装模块123npm install module-name -save 自动把模块和版本号添加到dependencies部分npm install module-name -save-dve 自动把模块和版本号添加到devdependencies部分至于配置文件区分这俩部分， 是用于区别开发依赖模块和产品依赖模块， 以我见过的情况来看 devDepandencies主要是配置测试框架， 例如jshint、mocha。 123-S, --save: Package will appear in your dependencies.-D, --save-dev: Package will appear in your devDependencies.-O, --save-optional: Package will appear in your optionalDependencies. Vue指令学习展示data中的数据 采用展现的方式双大括号。 指令-循环循环数组1231. &lt;li v-for=&quot;item in items&quot;&gt; 第&#123;&#123; $index &#125;&#125;条:&#123;&#123; item.message &#125;&#125;&lt;/li&gt; // vue 12. - &lt;li v-for=&quot;(item, index) in items&quot;&gt; 第&#123;&#123; index &#125;&#125;条:&#123;&#123; item.message &#125;&#125;&lt;/li&gt; // vue 2 - &lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt; // vue 2 循环对象121. &lt;li v-for=&quot;(key, value) in obj&quot;&gt;&lt;/li&gt;2. &lt;li v-for=&quot;(value, key) in obj&quot;&gt;&lt;/li&gt; // **==注意是相反的==** 循环数字12&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;!-- Vue 1 从0开始，Vue 2从1开始 --&gt; 条件控制123456&lt;!-- 如果ok为false, 不输出在 HTML 中 --&gt;&lt;div v-if=&quot;ok&quot;&gt;Yes&lt;/div&gt;&lt;div v-else&gt;No&lt;/div&gt;&lt;!-- 如果ok为false,只是 display:none 而已 --&gt;&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 事件绑定123456789101112131415&lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;点击&lt;/button&gt;&lt;!-- 简写 --&gt;&lt;button @click=&quot;say(&apos;hi&apos;)&quot;&gt;点击&lt;/button&gt;&lt;!-- 传入 event 对象 --&gt;&lt;button @click=&quot;say(&apos;hi&apos;, $event)&quot;&gt;点击&lt;/button&gt;&lt;!-- 阻止单击事件冒泡 --&gt;&lt;button @click.stop=&quot;doSth&quot;&gt;点击&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @submit.prevent=&quot;doSth&quot;&gt;点击&lt;/button&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 按键修饰符：回车时才会执行 --&gt;&lt;input @keyup.13=&quot;submit&quot;&gt;&lt;!-- 13 为 keycode --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;&lt;!-- 支持的全部按钮为 enter, tab, delete, space, up, down, left, right 字母 --&gt; 表单的双向绑定1234567&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;!-- 自定义选中值。否则 选中为value值，不选为空 --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt; 绑定属性12345678910111213&lt;div v-bind:class=&quot;&#123; &apos;class-a&apos;: isA, &apos;class-b&apos;: isB &#125;&quot;&gt;&lt;/div&gt;&lt;div v-bind:class=&quot;classArr&quot;&gt;&lt;/div&gt; &lt;!-- classArr 是一个数组 --&gt;&lt;!-- 简写 --&gt;&lt;div :class=&quot;&#123; &apos;class-a&apos;: isA, &apos;class-b&apos;: isB &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;img :src=&quot;imgSrc&quot;&gt;&lt;a :href=&quot;baseURL + &apos;/path&apos;&quot;&gt;&lt;!--在 Vue 2 中，**如果属性值是==变量==，必须用绑定属性**的写法。--&gt;// wrong&lt;img src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt; // 不再使用展现的形式// right&lt;img :src=&quot;imgSrc&quot;&gt; 避免闪烁123456[v-cloak] &#123; display: none;&#125;&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 不会显示 的内容，直到编译结束。 单向绑定123&lt;!-- Vue 1 这么写 --&gt;&lt;span&gt;This will never change: &#123;&#123;* msg &#125;&#125;&lt;/span&gt;&lt;!-- Vue 2 ==不支持== --&gt; 输出 HTML1234&lt;!-- Vue 1 这么写 --&gt;&lt;div&gt;&#123;&#123;&#123; raw_html &#125;&#125;&#125;&lt;/div&gt; &lt;!-- &#123;&#123;&#125;&#125; 中的 HTML 内容的会转为纯文本 --&gt;&lt;!-- Vue 2 这么写 --&gt;&lt;div v-html=&quot;raw_html&quot;&gt;&lt;/div&gt; 计算属性可以用展现的方式来展现计算后返回的结果 相当于data里的变量 123456789101112&lt;div id=&quot;demo&quot;&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt;new Vue(&#123; data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;); 自定义指令12345678910111213141516171819Vue.directive(&apos;my-directive&apos;, &#123; bind: function () &#123; // 准备工作 // 例如，添加事件处理器或只需要运行一次的高耗任务 this.el;// 添加指令的元素 this.vm.$get(name)// 获得该指令的上下文 ViewModel this.expression;// 指令的表达式的值 &#125;, update: function (newValue, oldValue) &#123; // 值更新时的工作 // 也会以初始值为参数调用一次 &#125;, unbind: function () &#123; // 清理工作 // 例如，删除 bind() 添加的事件监听器 &#125;&#125;)&lt;div v-my-directive=&quot;someValue&quot;&gt;&lt;/div&gt; #### 监听数据变化 123456789new Vue(&#123; data: &#123; firstName: &apos;Foo&apos; &#125;, watch: &#123; // 是一个类 firstName: function (val, oldVal) &#123; &#125; &#125;&#125;); 自定义过滤器1234567Vue.filter(&apos;wrap&apos;, function (value, begin, end) &#123; return begin + value + end;&#125;);&lt;!-- &apos;hello&apos; =&gt; &apos;before hello after&apos; --&gt;&lt;!-- Vue 2 这么写 --&gt;&lt;span v-text=&quot;message | wrap(&apos;before&apos;, &apos;after&apos;)&quot;&gt;&lt;/span&gt; 生命周期相关的钩子函数1234567// Vue 2new Vue(&#123; created: function()&#123;&#125;, mounted : function()&#123;&#125;,// 相对与 1 中的 ready beforeDestroy: function()&#123;&#125;, destroyed: function()&#123;&#125;&#125;); 过渡效果1234567891011121314&lt;!-- Vue 1 这么写 --&gt;&lt;div v-if=&quot;show&quot; transition=&quot;my-transition&quot;&gt;&lt;/div&gt;&lt;!-- Vue 2 这么写 --&gt;&lt;transition v-bind:name=&quot;my-transition&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt;/* 必需 */.my-transition-transition &#123; transition: all .3s ease;&#125;/* .my-transition-enter 定义进入的开始状态 */.my-transition-enter&#123;&#125;/* .my-transition-leave 定义离开的结束状态 */.my-transition-leave &#123;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单学习jwplayer播放器]]></title>
    <url>%2Fjwplayer-guidence%2F</url>
    <content type="text"><![CDATA[jwplayer播放器jwplayer播放器是一款流行的开源播放器。 支持播放Adobe Flash Player和HTML5浏览器可以处理任何格式，如（FLV文件，H.264标准，MP4功能，VP8的，WEBM，支持MP3，AAC，JPG，PNG和GIF）等。 支持各种流数据播放和播放清单等功能。 同时拥有大量的插件和皮肤，提供丰富的配置项和易用的Javascript API，方便使用和扩展。 开始源码下载github仓库 jwplayer官网 本教程使用的版本是v7.12.3 主文件引入需要引入的2个js文件 12&lt;script src=&quot;./your_path_to_file/jwplayer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./your_path_to_file/jwplayer.controls.js&quot;&gt;&lt;/script&gt; 需要设置lisence才可以使用，否则会提示Error setting up player: Missing license key，设置方式 123&lt;script&gt; jwplayer.key=&quot;bAoNHra71KE/mHvb0sirT4HeWLTAkpiYa1mVsA==&quot;;&lt;/script&gt; 初始化jwplayer播放器可以采用以三种方式来进行初始化 利用div标签初始化1234567// html&lt;div id=&quot;myPlayer&quot;&gt;播放器载入中...&lt;/div&gt; // 内容用于播放器未载入时给用户提示// jsvar myPlayer = jwPlayer(&apos;myPlayer&apos;); 利用video标签初始化1234567// html&lt;video id=&quot;myPlayer&quot; height=&quot;600&quot; width=&quot;400&quot;&gt;&lt;/video&gt;// jsvar myPlayer = jwPlayer(&apos;myPlayer&apos;); 快速初始化在需要初始化的video标签上添加jwplayer类，将初始化用jwplayer播放器来播放视频 1&lt;video class=&quot;jwplayer&quot; src=&quot;./your_path_to_file/video.mp4&quot;&gt;&lt;/video&gt; 成功初始化后我们得到了一个myPlayer对象，我们可以在控制台打印它，简单查看相关的API。 1console.log(myPlayer); 播放文件简单播放利用file参数指定视频文件的路径 123myPlayer.setup(&#123; file: &apos;./your_path_to_file/video.mp4&apos;&#125;) 别的配置项也是通过上面的方法以对象的方式传入。 定制播放配置各种参数来根据需求播放视频文件 我们可以通过myPlayer.getConfig()来查看当前配置和默认配置，再根据需求进行修改定制。 常用配置项 配置项 含义 类型 默认值 可用值 width 播放器宽度 Number 480 数字即可 height 播放器高度 Number 270 数字即可 autostart 是否自动播放 Boolean false true / false volume 初始化音量 Number 90 1-100整数 controls 是否展现控制播放 Boolean true true / false mute 是否初始化静音 Boolean false true / false playbackRateControls 是否展现播放速度控制 Boolean false true / false repeat 是否开启重复播放 Boolean false true / false skin 播放器皮肤设置 String ‘seven’ ‘seven’, ‘six’, ‘beelden’, ‘vapor’, ‘glow’等 列表播放在配置项中添加 12345playlist: [ &#123; duration: 100, title: &apos;视频1&apos;, file: &apos;./your_path_to_file/1.mp4&apos;, image: &apos;./your_path_to_file/1.jpg&apos; &#125;, &#123; duration: 150, title: &apos;视频2&apos;, file: &apos;./your_path_to_file/2.mp4&apos;, image: &apos;./your_path_to_file/2.jpg&apos; &#125;, &#123; duration: 200, title: &apos;视频3&apos;, file: &apos;./your_path_to_file/3.mp4&apos;, image: &apos;./your_path_to_file/3.jpg&apos; &#125;] 参数含义 duration 当前视频播放时间 不代表最终时间 只做预览用 单位秒 会自动格式化为mm:ss格式 title 当前视频名称 字符串 file 当前视频路径 字符串 image 当前视频预览图 替代video标签的poster属性 语言设置播放器本身需要用到语言提示的地方并不多，可通过如下配置进行定制 具体可以通过myPlayer.getConfig()来查看 123456localization: &#123; playlist: &apos;播放列表&apos;, nextUp: &apos;下集&apos;, buffer: &apos;缓冲中...&apos;, pause: &apos;暂停&apos;&#125; APIjwplayer播放器提供的API可以通过打印初始化得到的对象查看 1console.log(myPlayer); 常用API 属性123456789myPlayer.version// 版本与插件信息7.12.3+commercial_v7-12-3.190.commercial.4b867e.jwplayer.7a74dd.freewheel.a63b67.googima.94433c.vast.80361a.analytics.16a0a9.plugin-gapro.7e936b.plugin-related.7adae3.plugin-sharing.586630.vr-plugin.725b2e.hls.js.myPlayer.id// 初始化的dom元素idmyPlayer getter类方法 API 含义 结果类型 getConfig 获取配置参数 Object getControls 是否有播放控制 Boolean getDuration 当前视频总时长 Number getFullscreen 是否全屏 Boolean getMute 是否静音 Boolean getPlaybackRate 获取播放速率 Number getPlaylist 获取播放列表 Array getPosition 获取已播放时长 Number getState 当前播放器状态 String getVolume 获取当前音量 Number isBeforeComplete 是否要完成播放 Boolean isBeforePlay 是否即将播放 Boolean getState获取的播放状态有’buffering’, ‘playing’, ‘pause’, ‘complete’, ‘idle’ setter类方法 API 含义 参数 setup 设置播放器配置 Object pause 暂停播放 null play 开始播放 null stop 停止播放 null next 播放下一视频 null remove 移除播放器对象 null seek 跳转播放进度 Number，代表秒 setMute 设置是否静音 Boolean setFullscreen 设置是否全屏 Boolean setPlaybackRate 设置播放速率 Number，以1位标准速率 setVolume 设置播放音量 Number，取值1-100 事件方法 API 事件 onBeforeComplete 视频播放完毕前触发 onBeforePlay 视频即将播放前触发 onBuffer 视频缓冲中触发 onBufferChange 缓冲状态变化触发 onBufferFull 缓冲完毕触发 onComplete 播放完毕触发 onDisplayClick 播放界面点击触发 onError 播放器出错触发 onFullscreen 切换全屏触发 onIdle 停止播放触发 onMute 静音触发 onPause 暂停触发 onPlay 播放触发 onPlaylistComplete 播放列表播放完成触发 事件方法可以通过传入匿名函数的方式来进行对编辑器初始化，在事件触发的时候会执行该匿名函数 参考资料JWPlayer快速入门指南（中文） 官方API文档]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式收集]]></title>
    <url>%2Fregular-expression-mostly-used%2F</url>
    <content type="text"><![CDATA[以下正则搜集自网络，经过自己测试有效，放在这里方便自己二次使用。如有错误，请指出。以后也可能会更新自己写的正则表达式。 正则表达式校验数字 数字： 1^[0-9]*$ n位的数字： 1^\d&#123;n&#125;$ 至少n位的数字： 1^\d&#123;n,&#125;$ m-n位的数字： 1^\d&#123;m,n&#125;$ 零和非零开头的数字： 1^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字： 1^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 带1-2位小数的正数或负数： 1^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 正数、负数、和小数： 1^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数： 1^[0-9]+(.[0-9]&#123;2&#125;)?$ 有1~3位小数的正实数： 1^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 非零的正整数： 1^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$ 非零的负整数： 1^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 非负整数： 1^\d+$ 或 ^[1-9]\d*|0$ 非正整数： 1^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数： 1^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数： 1^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数： 1^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数： 1^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数： 1^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 校验字符工作常用 Email地址： 1^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名： 1[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? InternetURL： 1[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码： 1/^1[3456789]\d&#123;9&#125;$/ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)： 1^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 国内电话号码(0511-4405222、021-87888822)： 1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 身份证号(15位、18位数字)： 1^\d&#123;15&#125;|\d&#123;18&#125;$ 短身份证号码(数字、字母x结尾)： 1^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： 1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： 1^[a-zA-Z]\w&#123;5,17&#125;$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)： 1^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 日期格式：(YYYY-MM-DD) 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125; 一年的12个月(01～09和1～12)： 1^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)： 1^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件： 1^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式： 1[\u4e00-\u9fa5] 双字节字符： (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 1[^\x00-\xff] 空白行的正则表达式： (可以用来删除空白行) 1\n\s*\r HTML标记的正则表达式： (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 1&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; 首尾空白字符的正则表达式： (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 1^\s*|\s*$或(^\s*)|(\s*$) 腾讯QQ号： (腾讯QQ号从10000开始) 1[1-9][0-9]&#123;4,&#125; 中国邮政编码： (中国邮政编码为6位数字) 1[1-9]\d&#123;5&#125;(?!\d) IP地址：(提取IP地址时有用) 1\d+\.\d+\.\d+\.\d+ 参考资料常用正则表达式大全]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>regexp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试Mockjs与模拟数据]]></title>
    <url>%2Fmockjs-abc%2F</url>
    <content type="text"><![CDATA[Mock.js是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。 简介Mock.js是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。 功能mockjs主要提供了以下模拟功能： 根据数据模板生成模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模板生成模拟数据 下载mockjs官网下载，直接以js文件引入 12// node下载npm install mockjs 其余下载方式这里不做介绍，可以参考官网文档。 语法规则Mock.js 的语法规范包括两部分： 数据模板定义（Data Temaplte Definition，DTD） 数据占位符定义（Data Placeholder Definition，DPD） 数据模板定义 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： 12345// 属性名 name// 生成规则 rule// 属性值 value&apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则 的 含义 需要依赖 属性值 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。 生成规则和示例 属性值是字符串 String ‘name|min-max’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数等于 count。 属性值是数字 Number ‘name|+1’: 100 属性值自动加 1，初始值为 100 ‘name|1-100’: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。 ‘name|1-100.1-10’: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。 12345678910111213&#123; &apos;number1|1-100.1-10&apos;: 1, &apos;number2|123.1-10&apos;: 1, &apos;number3|123.3&apos;: 1, &apos;number4|123.10&apos;: 1.123&#125;// =&gt;&#123; &quot;number1&quot;: 12.92, &quot;number2&quot;: 123.51, &quot;number3&quot;: 123.777, &quot;number4&quot;: 123.1231091814&#125; 属性值是布尔型 Boolean ‘name|1’: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。 ‘name|min-max’: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。 属性值是对象 Object ‘name|min-max’: {} 从属性值 {} 中随机选取 min 到 max 个属性。 ‘name|count’: {} 从属性值 {} 中随机选取 count 个属性。 属性值是数组 Array ‘name|1’: [{}, {} …] 从属性值 [{}, {} …] 中随机选取 1 个元素，作为最终值。 ‘name|min-max’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数为 count。 属性值是数组 Function ‘name’: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 ‘name’ 所在的对象。 数据占位符定义 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为： 12@占位符@占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 1234567891011121314151617&#123; name: &#123; first: &apos;@FIRST&apos;, middle: &apos;@FIRST&apos;, last: &apos;@LAST&apos;, full: &apos;@first @middle @last&apos; &#125;&#125;// =&gt;&#123; &quot;name&quot;: &#123; &quot;first&quot;: &quot;Charles&quot;, &quot;middle&quot;: &quot;Brenda&quot;, &quot;last&quot;: &quot;Lopez&quot;, &quot;full&quot;: &quot;Charles Brenda Lopez&quot; &#125;&#125; Type Method Basics boolean, natural, integer, float, character, string, range, date, time, datetime, now Image image, dataImage Color color Text paragraph, sentence, word, title Name first, last, name Web url, domain, email, ip, tld Address area, region Helpers capitalize, upper, lower, pick, shuffle Miscellaneous guid, id Mock APIs]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>数据</tag>
        <tag>mockjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animate.css简单学习。]]></title>
    <url>%2Fanimate-css-abc%2F</url>
    <content type="text"><![CDATA[H5的时代了，前端不会点动画怎么行。不会设计没关系，animate内置多种动画形式，方便你的使用。 介绍animate.css是一款有趣的跨浏览器动画库，支持多种常见的动画形式，简单易上手，兼容性可以达到IE9+。 使用下载github地址 引入在head元素中，用link标签引入animate.css文件 1&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.css&quot; /&gt; 使用直接使用在你想要让其有动画的元素上加上animated和动画名字2个类，如下所示： 1&lt;div class=&quot;box animated swing&quot; id=&quot;box&quot;&gt;&lt;/div&gt; 默认动画只一次，如果需要无限次可以加上infinite类。 如果需要固定次数或者修改别的动画属性，可以重新定义覆盖掉那些属性： 12345.box &#123; animate-duration: 3s; //动画持续时间 animate-delay: 1s; //动画延迟时间 animate-iteration-count: 4; //动画执行次数&#125; 动态使用12345// jquery$(&apos;#box&apos;).addClass(&apos;animated swing&apos;);// jsdocument.querySelector(&apos;#box&apos;).classList.add(&apos;animated swing&apos;); 动画结束可以通过监听动画结束的回调来在动画结束做别的动作 123$('#box').on('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', funtion () &#123; // doSomething&#125;)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽API简单应用]]></title>
    <url>%2Fh5-drag-api%2F</url>
    <content type="text"><![CDATA[拖拽是网页交互的一种更加友好的方式。H5提供了和利用鼠标事件去实现相比更加简单易用的拖拽API，我们可以通过使用它们为用户提供更优秀体验的应用。 拖拽元素浏览器内默认除了图片以外的元素，基本都是不可拖动的。而如果我们希望任意一个元素可以拖动的话，可以通过给这个元素设置draggable=&quot;true&quot;属性来实现。 例如我们有一个div元素，我们希望它是可拖动的： 1&lt;div class="aim" id="aim" draggable="true"&gt;&lt;/div&gt; 事件 dragstart 在可拖动元素开始被拖动的时候触发 drag 在开始拖动和结束之间连续触发，与鼠标移动无关 dragend 在可拖动元素停止拖动或者放置后触发 放置元素 dragenter 在可拖拽元素一部分进入被放置的元素时候触发 dragover 在进入目标元素和离开目标元素之间连续触发 drop 在目标元素上面释放拖动元素的时候触发 dragleave 在可拖拽元素全部离开被放置的元素时候触发 要想元素能够被放置，必须在dragover事件上阻止默认。 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// html&lt;div class="aim" id="aim" draggable="true"&gt;&lt;/div&gt;&lt;div class="box" id="box"&gt;&lt;/div&gt;// css.aim &#123; width: 120px; height: 30px; border-radius: 3px; margin: 50px auto; background-color: #005aaa;&#125;.box &#123; width: 200px; height: 200px; margin: 100px auto; border: 10px solid #999;&#125;// js// 拖拽目标元素aim.ondragstart = (e) =&gt; &#123; aim.style.backgroundColor = 'yellow'; console.log('dragstart触发');&#125;;aim.ondrag = (e) =&gt; &#123; aim.style.backgroundColor = 'red'; console.log('drag触发');&#125;;aim.ondragend = (e) =&gt; &#123; aim.style.backgroundColor = 'green'; console.log('dragend触发');&#125;;// 放置目标元素box.ondragenter = (e) =&gt; &#123; box.style.borderColor = 'red'; console.log('dragenter触发');&#125;;box.ondragover = (e) =&gt; &#123; box.style.borderColor = 'yellow'; console.log('dragover触发'); e.preventDefault();&#125;;box.ondragleave = (e) =&gt; &#123; box.style.borderColor = 'blue'; console.log('dragleave触发');&#125;;box.ondrop = (e) =&gt; &#123; box.style.borderColor = 'green'; console.log('drop触发');&#125;; 浏览器兼容性关于h5拖拽的兼容性，可以参考Can I Use? 可以看出ie6+就部分兼容了h5原生拖拽API。 而现代的PC端标准浏览器对拖拽API有着很好的兼容性。 而移动端因为本来就是支持多点触控的，所以并不需要浏览器去提供支持。 高级应用 心有多大，应用就有多广泛。 拖动文件上传 购物车等应用 拖动生成页面元素 …]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>h5</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架Mocha简单入门]]></title>
    <url>%2Fmochajs-abc%2F</url>
    <content type="text"><![CDATA[最近和台湾朋友聊天，跟他讲述了一些最近在做的项目中碰到的难点，询问一下他是如何解决此类问题的。 他给我推荐了一些技术，建议我可以了解一些，还说必须要学习单元测试。 所以趁着周末闲暇之际，学习一下Mocha测试框架。 起因咨询的问题主要有如下3个： 如何实现2个不同域名页面的实时通信。用户要求在后台操纵页面点击列表项，前台页面弹出对应项的新闻 页面定时器太多，可能存在使用不当的情况，导致内存溢出，页面崩溃。 工作和开发经验心得。 关于问题一，我咨询他除了用websocket和短时间的定时器去轮询外，是否还有什么更好的方案。 诸如小型的聊天室，百度商桥，商务通类的基于web的即时通信软件，他们是如何实现双向实时通信的。 他给我推荐了一个方案野狗云。 野狗科技(北京)有限公司（简称：野狗）是安全可靠的实时通信云。野狗为企业和开发者提供了可编程的实时数据、音视频通信能力，以及短信服务，可以安全地构建丰富场景化的实时通信业务。 野狗云文档 关于问题二，他给我推荐了Rx.js，一种响应式编程的方案。 Rxjs提供了一种处理异步逻辑，数据流， 事件的方案，不过其学习曲线比Promise还要陡峭。 关于问题三，他告诉我需要学习BDD(行为驱动开发)和TDD(测试驱动开发)，需要在Ng,Vue和React框架里选择一个深入学习，需要能做单元测试，需要了解记忆体易位，设计模式等。 MochaMocha是一款特性丰富的JavaScript测试框架，它可以运行在Node.js环境和浏览器环境中。它可以使得异步测试变得简单有趣。Mocha可以顺序执行测试，输出灵活且精准的报告，同时可以将未捕获的程序异常映射到正确的测试用例上。Mocha托管在Github上。 Mocha的特性 Mocha的Github仓库 下载Mocha可以通过多种方式下载获得 npm下载12345// 全局下载npm install mocha --global // npm i mocha -g// 项目依赖npm install mocha --save-dev // npm i mocha -D Bower下载1bower install mocha CDNCDNjs地址 例子全局安装Mocha1npm install mocha -g 创建项目test1mkdir test 初始化Node项目12// 注意test脚本填写mochanpm init 本地安装Mocha12// 安装为项目依赖npm install mocha -D 根目录创建test.js1touch test.js 编写测试用例1234567891011121314151617181920212223242526// test.jsvar assert = require(&apos;assert&apos;);describe(&apos;Array&apos;, function (argument) &#123; describe(&apos;#indexOf&apos;, function () &#123; it(&apos;should return -1 when the value is not present&apos;, function () &#123; assert.equal(-1, [1, 2, 3].indexOf(4)); &#125;); &#125;);&#125;);describe(&apos;Math&apos;, function () &#123; it(&apos;should test if 3 * 3 = 9&apos;, function () &#123; assert.equal(9, 3 * 3); &#125;); it(&apos;should test if (3 - 4) * 8 = -8&apos;, function () &#123; assert.equal(-8, (3 - 4) * 8); &#125;); it(&apos;should test if 1 + 2 = 2&apos;, function () &#123; assert.equal(2, 1 + 2); &#125;);&#125;); 运行测试1npm test 结果123456789101112131415161718192021Array #indexOf √ should return -1 when the value is not presentMath √ should test if 3 * 3 = 9 √ should test if (3 - 4) * 8 = -8 1) should test if 1 + 2 = 23 passing (27ms)1 failing1) Math should test if 1 + 2 = 2: AssertionError [ERR_ASSERTION]: 2 == 3 + expected - actual -2 +3 讲解因为Mocha本身只是测试框架，所以使用它我们还需要引入断言库，本利中我们引入了Nodejs的内置断言库assert。 我们编写了4个简单的测试用例。用到了Mocha的如下API。 describedescribe表示测试分组，我们可以根据需求进行有序的分组，方便有组织地查看测试结果。分组可以无限深度地嵌套。 1describle(&apos;GroupName&apos;, function () &#123;&#125;) itit表示一个测试用例，我们可以根据自己的测试需求编写测试用例。最终运行测试脚本会返回测试用例是否通过。在terminal中我们可以根据测试用例前面是否有√来判断。如果没有通过，会生成一个未通过测试用例的索引，可以查看下面更详细的关于未通过原因的描述。 1it(&apos;should bla bl abla&apos;, function () &#123;&#125;) 断言断言即给与一个布尔值，真或者假，是或者非等。 Mocha可以很方便地与各种断言库进行集成。 常用断言库有： should.js better-assert expect.js unexpected chai 参考资料Mochajs官方文档]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>Mocha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试velocity动画引擎]]></title>
    <url>%2Fvelocity-js-abc%2F</url>
    <content type="text"><![CDATA[Velocity是一款能够构建出令人难以置信的快速的动画的js动画引擎。它可以依赖jQuery或者独立使用。而且支持颜色动画，变形类动画，循环，缓动，SVG动画和滚动。它是jQuery和CSS过渡的完美结合。 Velocity简介 Velocity是一款有着与jQuery类似的API的动画引擎，例如$.animate()。它可以依赖jQuery或者独立使用。它构建的动画令人难以置信的快。而且支持颜色动画，变形类动画，循环，缓动，SVG动画和滚动。它是jQuery和CSS过渡的完美结合。 Velocity可以向后兼容至IE8和安卓2.3。 Github仓库 常用API简单动画示例1234567891011121314151617// with jQuery(function ($) &#123; // 解决$变量冲突 $(&apos;.box&apos;).velocity(&#123; // 注意小写的v width: &apos;300px&apos;, height: &apos;300px&apos; &#125;, &#123; duration: 3000 // 一帧动画时间 &#125;);&#125;)(jQuery);// without jQueryVelocity(document.querySelector(&apos;.box&apos;), &#123; width: &apos;300px&apos;, height: &apos;300px&apos;&#125;, &#123; duration: 3000&#125;); 组合动画实现示例组合动画实现方案： 给每个动画设置好恰当的delay属性，来维护多个动画间的先后顺序 缺点：手动维护，太过麻烦 在先完成的动画的complete回调里定义第二个动画 缺点：多层嵌套，回调地狱 定义动画队列来实现 回调函数法123456789101112131415161718192021222324252627282930313233// with jQuery(function ($) &#123; $(function () &#123; $(&apos;.box&apos;).velocity(&#123; width: &apos;300px&apos;, height: &apos;300px&apos; &#125;, &#123; duration: 2000, complete: function () &#123; $(&apos;.box&apos;).velocity(&#123; translateY: &apos;300px&apos; &#125;, &#123; duration: 1000 &#125;); &#125; &#125;); &#125;);&#125;)(jQuery);// without jQueryVelocity(document.querySelector(&apos;.box&apos;), &#123; width: &apos;300px&apos;, height: &apos;300px&apos;&#125;, &#123; duration: 1500, complete: function () &#123; Velocity(document.querySelector(&apos;.box&apos;), &#123; translateY: &apos;300px&apos; &#125;, &#123; duration: 1500 &#125;); &#125;&#125;); 动画队列法JQuery写法中通过数组定义了一个动画队列。每一帧动画都是一个对象，由elements，properties，options3个属性组成。其中properties和options又分别是对象，properties是动画的变化属性，options是配置。 定义完毕后用$.Velocity.RunSequence(seqName)方法来依次执行。 12345678910111213141516171819202122232425262728293031323334// with jQuery(function ($) &#123; var animateSeq = [&#123; elements: $(&apos;.box&apos;), properties: &#123; width: &apos;300px&apos;, height: &apos;300px&apos; &#125;, options: &#123; duration: 1000 &#125; &#125;, &#123; elements: $(&apos;.box&apos;), properties: &#123; translateY: &apos;300px&apos; &#125;, options: &#123; duration: 1000 &#125; &#125;, &#123; elements: $(&apos;.box&apos;), properties: &#123; translateX: &apos;300px&apos; &#125;, options: &#123; duration: 1000 &#125; &#125;]; $.Velocity.RunSequence(animateSeq);&#125;)(jQuery);// without jQuery 预定义动画Velocity內建了一系列的常用的动画效果，可以直接进行使用，方便开发。 关于其具体內建动画的效果，可以查看Velocity官网 使用內建动画，需要引入velocity.ui包 1$(&apos;.box&apos;).velocity(&apos;callout.shake&apos;); 自定义动画自定义动画可以帮助我们扩充velocity没有但是我们需要的动画形式，方便我们多次使用。而且名字完全自定义，方便记忆。 定义的时候先指定默认的动画时间，再指定每一帧动画的形式和所占时间的百分比。 最后像內建的动画形式一样调用即可。 1234567891011121314151617181920212223242526272829(function ($) &#123;$.Velocity.RegisterUI(&apos;ntnyq.jump&apos;, &#123; defaultDuration: 2100, calls: [ [&#123; translateX: &apos;200px&apos;, translateY: &apos;300px&apos; &#125;, 0.2], [&#123; scaleX: 1.2, scaleY: 0.9 &#125;, 0.3], [&#123; scaleY: 1.3, scaleX: 1 &#125;, 0.3], [&#123; scaleY: 1, scaleX: 1 &#125;, 0.3] ]&#125;);$(&apos;.box&apos;).on(&apos;mouseover&apos;, function(e) &#123; $(this).velocity(&apos;ntnyq.jump&apos;);&#125;);&#125;)(jQuery);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>animate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串操作火箭炮——正则表达式]]></title>
    <url>%2Fregular-expression-guidence%2F</url>
    <content type="text"><![CDATA[正则表达式是一种描述字符串匹配的模式，我们通过构建正则表达式来匹配满足规则的字符串。正则表达式常用于对字符串进行检测，替换，提取，搜索。 API正则表达式相关API。 正则实例1234567// 构造函数var re = new RegExp(&apos;abc&apos;);// 字面量var re = /abc/; 正则方法正则方法指，正则对象上的方法，即RegExp构造函数生成的实例可以调用的方法。 test方法 检测字符串内是否包含有正则所匹配的字符子串。返回一个布尔值。 12345// re.test(str)var re = /abc/;console.log(re.test(&apos;abc&apos;)); // true 正则相关方法正则相关方法，指可以使用一个正则实例作为参数去调用的方法。 match方法 正则修饰符正则修饰符用于限制或者增强正则表达式的匹配能力。它有如下2种用法： 1234567// 1. 作为参数 传给正则构造函数var re = new RegExp(&apos;abc&apos;, &apos;g&apos;);// 2. 写在正则字面量后var re = /abc/g; 上面的2个正则匹配效果是相同的。 常用的正则修饰符有: g global 代表匹配全局所以的满足匹配模式的字符子串。强调”所有”。 i ignore 代表正则匹配的时候忽略字母的大小写 匹配攻略 正则表达式是匹配模式，要么匹配字符，要么匹配位置。 模糊匹配如果正则只能进行精确匹配，那么它的存在没多大意义。 横向模糊匹配 横向模糊指正则可以匹配的字符串长度可以是不固定的。 实现方式是使用量词，表示可能出现的次数范围。 1234var re = /ab&#123;2,5&#125;c/g, str = &apos;abc abbc abbbc abbbbc&apos;;console.log(str.match(re)); // [&apos;abbc&apos;, &apos;abbbc&apos;, &apos;abbbbc&apos;] 纵向模糊匹配 纵向模糊指一个正则实例匹配的字符串，具体到某一位字符时候，它可以是不确定的，有多中可能。 实现方式是使用字符组，表示可以是组内的任一个。 1234var re = /a[123]b/g, str = &apos;a1b a2b a3b a4b&apos;;console.log(str.match(re)); // [&apos;a1b&apos;, &apos;a2b&apos;, &apos;a3b&apos;] 字符组 范围表示法 如果字符组里面的字符特别多的话，用范围表示法会更方便。 比如[2345678abcdefgUVWXYZ]，可以这么表示[2-8a-gU-Z]。 -是连字符，表示字符范围。 而如果我们要匹配的字符里面包括它，我们可以使用反斜杠来转义，或者避免将其放在2个字符中间。 如要匹配a-z3个字符： 12345var re = /[-az]/;var re = /[az-]/;var re = /[a\-z]/; 排除字符组 纵向匹配有一种情况，就是某位字符不匹配某些字符。这时候我们就可以使用脱字符^。表示求反，排除匹配的字符。 比如/[^abc]/可以匹配除了a，b，c以外的任何单字符。 常用简写 简写是语法提供给我们的一些字符组的符号表示。 123456789101112\d 代表[0-9] 表示一位数字 d是digit\D 代表[^0-9] 表示除数字外任意字符\w 代表[0-9a-zA-Z_] 表示数字、大小写字母和下划线 w是word\W 代表[^0-9a-zA-Z_] 表示非数字，字母和下划线外的一个任意字符。\s 代表[\t\v\n\r\f] 表示空白符 包括空格，水平制表符，竖直制表符，换行符，回车符，插页符 s是space\S 代表非空白符. 代表[^\n\r\u2028\u2029] 通配符，表示几乎任意字符。 换行，回车，行分隔符和段分割符除外。// 匹配任意字符方式 [\d\D] [\w\D] [\s\S] [^]。 量词量词代表对重复次数范围的限制。 简写形式: {m,} 表示至少出现m次 {m} 表示正好出现m次 {m,n} 表示出现m次至n次 m和n都包括 ? 代表出现1次或者0次 等价于{0,1} 代表出现过至少一次 等价于{1,} 代表出现过任意次，可能不出现 等价于{0,} 贪婪匹配和惰性匹配 123456// 贪婪匹配var re = /\d&#123;2,5&#125;/g, str = &apos;123 1234 12345 1234567&apos;;console.log(str.match(re)); // [&apos;123&apos;, &apos;1234&apos;, &apos;12345&apos;, &apos;1234567&apos;] 贪婪匹配指，正则会尽可能多的匹配。比如我们给的范围是2-5，那么它会匹配的长度就是尽量匹配5个字符，如果不能匹配5个，再考虑4个字符。如果有6个满足的字符，它会匹配前5个。 123456// 惰性匹配var re = /\d&#123;2,5&#125;?/g, str = &apos;123 1234 12345 123456&apos;;console.log(str.match(re)); // [&apos;12&apos;, &apos;12&apos;, &apos;34&apos;, &apos;12&apos;, &apos;34&apos;, &apos;12&apos;, &apos;34&apos;, &apos;56&apos;] 惰性匹配模式下，它会尽可能少的匹配，比如我们定义匹配2-5个字符长度，如果匹配到了2个长度字符，它就会停止这次匹配。] 通常我们通过在量词后加问好来实现惰性匹配。 比如: 1&#123;m,n&#125;? &#123;m,&#125;? ?? +? *? 多选分支一个模式可以支持横向模糊或者纵向模糊。而多选分支则可以支持多个子分支支持其一。 实现多选分支，需要用到管道符|。 1234var re = /good|nice/g, str = &apos;good job, nice work&apos;;console.log(str.match(re)); // [&apos;good&apos;, &apos;nice&apos;] 但是需要注意的是比如用/good|goodbye/去匹配goodbye的时候，得到的是good。这是因为多选分支是惰性匹配的，前者匹配到了结果后者就不继续匹配了。要匹配得到goodbye可以使用/goodbye|good/。 参考资料正则表达式系列总结]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做一个无用的微信小程序。]]></title>
    <url>%2Ffirst-try-weapp%2F</url>
    <content type="text"><![CDATA[今天花了半天的时间阅读微信小程序API，然后实现了一个又难看又没有什么用的微信小程序。 微信小程序微信小程序是什么？ 官方的介绍： 微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 个人的看法： 我个人的看法是微信小程序并没有什么前景。小程序与原生APP或者webApp相比，它的优势并没有早先宣传的那么明显，我个人也不认为它可以取代原生应用，即使是在一些它本身占优势的方面。 让我们来看一下官方的介绍，突出的三点是： 小程序是全新的连接用户与服务的方式。 小程序可以在微信内便捷地使用和传播。 小程序具有出色的用户体验。 首先，小程序是全新的连接用户与服务的方式，新旧与否这也并非用户会关注的点，反而用户可能不会去放弃现在使用中的APP去替换成一种新的交互方式。 其次，小程序可以在微信内便捷地被使用和传播。我们不可否认微信的成功和在国内庞大的用户量。但是这足以促成小程序的成功吗？并不会，事实上，应该有相当大的一部分微信用户根本没有听说过小程序吧。而给智能手机下载APP，我相信拥有智能手机的人大部分都有经历过。我想，这是一种根深蒂固的观念，妄图改变，并不在自己的用户量的优势上面，而是需要有翻天覆地的技术革命。 是的，小程序可以通过简单的分享功能来传播，但是小程序的诸多限制，却又不利于扩充小程序包含内容的丰富程度。简单来说，功能多，就失去了加载快等特性，而且小程序本身框架的设计也并非容器是实现多样化的功能(暂时个人的看法)。而功能少，却不足以拥有留住用户的基础。并且，添加到桌面这个功能，可能相当大一部分用户并不会使用到，那么从小程序的入口进入，又相对比较麻烦。 最后，小程序具有出色的用户体验。确实，小程序的设计理念决定了它做出来后界面简洁，功能专一，加载迅速。相对来说，广告较少，比较纯净。但是大多时候我们需要提供给用户的却往往不止这些简单的小功能，而小程序封闭的框架又限制了某些功能的提供(个人现在的看法)。所以，最终还是要靠原生APP或者webApp去实现。小程序也只是能够起到一个锦上添花的作用而已。 现在的小程序，只是一个玩具而已。 用户体验谈谈用户体验。 看过一句话，说网络的三大生产力是--性，免费和无聊。 我现在要提出一个观点，用户体验应该针对的点是：美，懒，快和无脑。 美和快不必多说。别的这里解释一下。 懒，用户特别懒。 我们可能会经常看各种新闻，网站，论坛之类的，我想大多时候我们只是在看，很少去点赞或者评论。 究其原因就是，我们懒。我们没有要去做那些操作的理由或者想法。而一些诱导分享的内容却往往得以迅速的传播，再究其原因，那就是能够给用户带来的利益。 人本身就是无利不早起的。那么我们如果想让小程序更好的发展，首先它要能提供一些相比原生APP更加优质的服务。比如--无广告(国内好多公司应该好好去做)。 想起一个说法就是你装个APP，提供商恨不得把他爹都给塞进去。问题是那些功能，我们是否真的可以用到，当然不是。而且有的甚至还会误操作多，体验真的很不好。 那么，现在有一个纯净版的小程序，我们可以添加至手机桌面，点开就用，那么无疑是可以吸引到用户的。 再说无脑，用户可能不知道可以添加小程序到桌面， 那么，从手机桌面进入原生APP需要点击一次，而从小程序进入，要先打开微信，再切换到发现栏，再点击小程序，再点击要打开的小程序。这用户体验，根本不需要比较。 当然小程序提供了添加桌面的功能，前提是用户发现它，使用小程序的人并不多，那么用户在第一次使用小程序的时候，怎么发现这个功能呢。嗯，需要开发去做提醒。 永远记住，避免让用户思考和发现。 让用户去选择，比让用户去输入要好。规范用户的输入，比用户犯错之后提示会更好。 开发体验关于如何开发微信小程序，官方文档介绍的很详细，这里我就不Copy那些API了，并没有什么意义。 这里我来谈一下，我个人在尝试开发小程序时候的感受。 因为整个开发和学习的时间就是今天的下午，大概几个小时而已，实现的功能也非常简单，只是做了几个简单的数据查询展现的页面，所以可能有些在我认为有点坑的地方只是我对API不够熟悉而已。 但我想，这也可能是别的初学小程序开发者可能会遇到的问题。 首先，注册小程序，需要绑定一个没有绑定过邮箱，我有点搞不清楚这里没有绑定过的定义，不过应该是指没有绑定过微信号吧。 我有5个邮箱，三个试过后已经绑定过了，gmail则是根本无法绑定。我觉得这比较麻烦，大多人的常用邮箱应该在2个左右。但是可能会去绑定的小程序就不止一个。 其次，微信小程序开发者工具。这个工具，我真的感受不到什么优越性，确实提供了一些开发中的便利，比如对数据的监控，实时保存编译，自动生成页面文件等等。但它也将小程序的开发环境限制了。 我个人倾向于小程序能够做一个像Vue-DevTools那样的chrome插件，加上小程序专有的cli再加上各种插件。这样也能让我在自己常用的编辑器加上自己的习惯配置下工作。 毕竟，习惯是很可怕的一件事情。 再说说小程序提供的常用组件。 布局组件view 文本组件text 链接组件navigator 图片轮播组件swiper 图片组件image … 我只能说太有限了。当然这也是它设计理念的一部分。但是总感觉比如文本全是一个text组件，再去各种写样式去控制文本的展现，真的有点不方便的。 再说说小程序的目录结构 小程序项目的根目录下面包含3个文件，app.js, app.json, app.wxss。分别功能是js生成应用App实例，json进行全配置包括页面，主窗口，底部导航和网络超时设置，wxss进行全局样式设置。 而在每个pages下面的页面中，我们又要定义4个同名的不同格式文件foo.wxml, foo.js, foo.wxss, foo.json。分别是页面布局，样式，行为，数据和配置。 因为微信小程序的应用都是在移动端，而且是内建于程序内的，所以可以放心使用各种CSS3属性，flex布局和ES6语法、 而有关小程序提供的API方面。小程序的页面js提供有各个阶段的生命周期函数，自动监听页面的加载阶段，以方便执行不同的行为。小程序还提供了一套wx.apiName()的API来实现微信上常见的小功能。例如wx.showToast()，wx.request()，wx.navitateTo()。这些内置API都可以简单的进行配置，来实现多样化的效果。 小程序使用了模板语法，和组件上的自定义指令。这一点和例如vue之类的现代MVVM框架十分类似。语法上有很大的相同点。相信像我一样学习vue的同学学习起小程序开发应该可以快速上手。 但是小程序不能引入外部的样式和脚本文件又决定了这是一个比较封闭的生态。 总之，小程序有其优点，但是我个人并不看好。开发难度，我目前做点小功能，还尚可。不过我相信如果需要较高程度的自动化就会有不小的坑。 踩坑记录踩坑是一种乐趣。 项目目录选择 微信小程序开发工具初始化一个项目需要从一个已经存在的文件夹开始。而不是在初始化的时候去创建一个文件夹。 所以如果你想做个小程序项目，那么就从先给你的小程序起个名字，建立一个文件夹开始。 页面跳转失效 今天在开发的时候做页面跳转，我先再元素上绑定了bindTap属性，然后在js里写了对应的方法，然后问题来了，点击事件触发后，页面根本无法跳转。 经过搜索后才发现，原来在app.json里的tabBar分页导航设置的页面是无法通过wx.navigateTo跳转的。 解决方法将页面从tabBar中去掉，或者提醒用户点击tabBar替换页面，建议前者。 获取用户表单输入 方式一、 讲表单至于form组件中，再在form的bindSubmit事件中使用e.detail.value获取表单的所有值组成的对象。格式·name: value·。 方式二、 让input的输入与js的Data属性中的某个字段双向绑定，触发事件的时候重新读取这个数据。 页面间传值的方式 通过url的search段参数来实现类似动态的路由效果，那么我们就需要页面间的传值。 传值很简单，通过name=value的格式来组成，再将其拼接在url的search段后。 那么如何去接收这个值呢？ 我们可以在onLoad生命周期函数中传入一个对象，再通过这对象下面的key来获取对应的value。 12345Page (&#123; onLoad (opts) &#123; let val = opts.key &#125;&#125;) 格式化字符串再模板输出 这是我今天在做的小项目里的一个需求，服务器返回的时间格式需要修改。 在vue中我们有fiter的功能，甚至可以自定义fiter。 然而在微信小程序中，我尝试了在模板语法支持的表达式中来格式化时间。失败了。 在js的生命周期里，用map方法修改数据的时间属性，仍然失败。 目前还没想到优雅的解决方案。 其余小坑 在wx.apiName()中记住这里调用的是wx实例的方法，而当我们要进行一些操作时候，需要再全局韩静下使用。所以我们可以在这些函数前声明let that = this。再通过that来操作。 要使用data字段的数据 需要这样来操作this.data.dataName。 要修改某个数据的值，使用this.setData()比较好。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用的JavaScript开发技巧]]></title>
    <url>%2Fjavascript-tricks%2F</url>
    <content type="text"><![CDATA[乐在其中，是最好的学习方式。 判断是否为移动端12// 利用是否拥有移动端事件来判断 得到一个布尔值'ontouchend' in document 判断对象是否为空1234567// 如果可以进行for-in循环 那么对象就不为空const isEmptyObject = (obj) =&gt; &#123; for(let attr in obj) &#123; return false; &#125; return true;&#125; 禁止复制网页内容123456&lt;script type="text/javascript"&gt; // oncontextmenu 事件在元素中用户右击鼠标时触发并打开上下文菜单 document.oncontextmenu=new Function("event.returnValue=false"); // onselectstart几乎可以用于所有对象，其触发时间为目标对象被开始选中时（即选中动作刚开始，尚未实质性被选中） document.onselectstart=new Function("event.returnValue=false");&lt;/script&gt; 过滤HTML标签1str.replace(/&lt;\w+&gt;(.+?)&lt;\/\w+&gt;/g, function(match,$0)&#123;return $0&#125;); 切换页面更改标题123456789101112131415(function (d) &#123; let pageTitle = ''; d.addEventListener('visibilitychange', () =&gt; &#123; if (d.visibilityState === 'hidden') &#123; pageTitle = d.title; d.title = 'O(∩_∩)O哈哈~'; &#125; else &#123; d.title = pageTitle; &#125; &#125;, !1);&#125;)(document); 复制大量文字版权附加123456789101112131415161718192021222324252627282930313233343536373839$('body').on('copy', function (e) &#123; if (typeof window.getSelection == 'undefined') &#123; return; &#125; var body_element = document.body, selection = window.getSelection(); if (('' + selection).length &lt; 30) &#123; return; &#125; var newdiv = document.createElement('div'); newdiv.style.position = 'absolute'; newdiv.style.left = '-99999px'; body_element.appendChild(newdiv); newdiv.appendChild(selection.getRangeAt(0).cloneContents()); if (selection.getRangeAt(0).commonAncestorContainer.nodeName == 'PRE') &#123; newdiv.innerHTML = '&lt;pre&gt;' + newdiv.innerHTML + '&lt;/pre&gt;'; &#125;; newdiv.innerHTML += '&lt;br /&gt;著作权归作者所有。&lt;br /&gt;商业转载请联系作者获得授权,非商业转载请注明出处。&lt;br /&gt;原文: &lt;a href="' + location.href + '"&gt;' + location.href + '&lt;/a&gt; © ntnyq.com'; selection.selectAllChildren(newdiv); window.setTimeout(function () &#123; body_element.removeChild(newdiv); &#125;, 200);&#125;); 创建可下载文件123456789101112function createFileDownload (filename, content) &#123; var aLink = document.createElement('a'), blob = new Blob([content], &#123; type: 'url' &#125;), event = new Event('click'); aLink.download = filename; aLink.href = URL.createObjectURL(blob); aLink.click(); URL.revokeObjectURL(blob); // 回收内存&#125; 创建从0开始自然数的数组1[...Array(n).keys()]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS小技巧]]></title>
    <url>%2Fcss-tricks-usefull%2F</url>
    <content type="text"><![CDATA[日常常用css效果收集，持续更新。方便自己查阅。 单行多行文本溢出隐藏123456789101112131415// 仅支持PC端webkit内核浏览器和移动端// less mixin写法 需要给出宽度.ellipsis-x ()&#123; white-space:nowrap; text-overflow:ellipsis; overflow:hidden;&#125;.ellipsis-y () &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden;&#125; 滚动条美化123456789101112131415/* 常用属性 前3个 webkit内核 *//* 全局修改所有的滚动条样式 也可以写在选择器后局部修改 */ ::-webkit-scrollbar /* 滚动条整体 */::-webkit-scrollbar-thumb /* 滑块样式 */::-webkit-scrollbar-track /* 轨道样式 */::-webkit-scrollbar-button /* 轨道两端 */::-webkit-scrollbar-track-piece /* 轨道内层 */::-webkit-scrollbar-corner /* 滚动条交汇处 */::-webkit-resizer /* 交汇处 控制元素尺寸控件 *//* IE or Edge */-ms-overflow-style: none; /* 隐藏滚动条 */scrollbar-face-color: blue; /* 修改滑块与箭头样式 *//* FF 无法隐藏滚动条 */ placeholder样式修改12345678910111213141516171819/* 兼容 修改 placeholder默认颜色 */::-webkit-input-placeholder &#123; /* WebKit browsers */ color: #666;&#125;:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ color: #666; opacity: 1;&#125;::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ color: #666; opacity: 1;&#125;:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ color: #666;&#125; 多行文本末行自定义对齐方式 做类似互发消息的需求时候可以用的到的属性。因为有消息的发送者和接受者，如果发送消息特别短，那么就应该是两端对齐的，而如果发送多行消息。末行就会向两端对齐，不符合人的阅读规律，可以使用此属性来修复。 12345678910text-align-last // 设置或检索一个块内的最后一行的对齐方式可选值auto：无特殊对齐方式。left：内容左对齐。center：内容居中对齐。right：内容右对齐。justify：内容两端对齐。start：内容对齐开始边界。end：内容对齐结束边界。 IE浏览器下，要使用此属性，要先设置text-align: justify; 巧用定位定义出获取剩余高度的区域假如我们需要页面有60像素的页头，60像素的页脚。然后主体占所有的页面剩余高度，但是总高度不允许超过页面高度的100%。 解决这个问题有以下方法： 123456789101112131415161718192021222324252627282930313233343536373839404142// 公共样式html,body &#123; width: 100%; height: 100%; overflow: hidden;&#125;// flex布局法body &#123; display: flex; flex-direction: column;&#125;.header,.footer &#123; flex: 0 0 60px;&#125;.content &#123; flex: 1;&#125;// css3的calc函数法.header,.footer &#123; height: 60px;&#125;.content &#123; height: calc(100% - 120px);&#125;// 绝对定位法 避免api的浏览器兼容性问题.header,.footer &#123; height: 60px;&#125;.content &#123; position: absolute; left: 0; top: 60px; bottom: 60px;&#125; 移动端元素横向排列溢出滚动今天工作中遇到的一个问题，在SF上找到的解决方案，据说苹果官网移动端有类似效果。 1234567891011&lt;div class="nav"&gt; &lt;div class="list"&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;a class="item"&gt;Lorem ipsum.&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425.nav &#123; width: 100%; height: 55px; padding-bottom: 20px; white-space: nowrap; // 关键属性 overflow: hidden; overflow-x: scroll; // 关键属性 text-align: justify; -webkit-overflow-scrolling: touch; // 优化属性 -webkit-perspective: 1000; -webkit-backface-visibility: hidden;&#125;.nav::-webkit-scrollbar &#123; // 优化显示 display: none; width: 10px;&#125;.item &#123; display: inline-block; height: 50px; line-height: 50px; font-size: 30px; padding: 10px 30px; border: 1px solid red; text-align: center;&#125; 利用伪元素添加计数索引假设我们要给一个列表(ul)上的每一个li加一个索引，那么可以使用如下的方法： 12345678ul &#123; counter-reset: flag;&#125;ul li:before &#123; content: counter(flag); counter-increment: flag;&#125; flag为索引名称]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码高亮插件highlight.js]]></title>
    <url>%2Fhighlight-js-abc%2F</url>
    <content type="text"><![CDATA[简单学习如何使用代码高亮插件highlight.js。 代码高亮对文章中插入的代码进行代码高亮可以有效避免文章和代码混在一起，使阅读一目了然，更加方便。 highlight.jshighlight.js是一款简单易用的代码高亮插件。 优点 支持几乎所有编程语言的代码高亮 支持自动进行语法类型检测 渲染出标准的&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;页面结构 支持多种高亮色彩主题的配置，可以随心替换，也可简单自定义。 缺点不支持显示行号。 为什么我们需要标准的&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;HTML结构。相信对于markdown大家应该不会陌生。github官方推荐的文档编写语法。同时也是程序员日常快速生成文档的法宝。而一些个人博客、技术网站也都支持markdown格式进行编辑。它渲染成html的结构局势标准的&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;结构。 使用方法下载点击highlight.js插件官方下载插件。 github仓库下载 官方支持语言自定义选择的插件下载，你可以选择你要高亮的编程语言，然后下载。 解压解压后获取的文件我们要用到的是highlight.pack.js和styles文件夹中的高亮主题。 使用写html的适合使用&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;结构，将代码放入。 在&lt;/head&gt;之前引入选择的样式文件。 在&lt;/body&gt;之前引入highlight.pack.js文件和在其后使用&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;来使用插件。 如果不想高亮某段代码，可以给它加nohighlight类。 推荐配色主题推荐 monokai-sublime sublime用户看习惯了的配色 Dracula 灰色主题 Atom One Dark Atom编辑器深色主题 自定义主题 自己喜欢的才是最好的 字体推荐 Roboto Consolas Source Code Pro]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>代码高亮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究图标库的使用]]></title>
    <url>%2Ficons-lib-guidence%2F</url>
    <content type="text"><![CDATA[图标表达的含义比文字更加直观，能够丰富页面的内容，在交互方面也更加友好，是现代页面设计不可缺少的一部分。 现有的图标库内容丰富，设计统一，在我们做一些缺少设计的项目时候，使用图标库是个很好的选择。 常用的图标库 Glyphicons Bootstrap的下载包内包含 250个左右 Font-awesome Bootstrap友好图标 比较丰富 可定制大小颜色阴影等CSS样式 Iconfont 阿里矢量图标 Material Design Icons 点击即可下载svg或者png格式 等等 Iconfont使用用户可以在Iconfont官网下载多种格式自定义颜色大小的Icon。 平台也支持创建项目，上传SVG图标，生成对应的字体文件和CSS文件。 单个使用单个图标用户可以自行选择下载不同的格式使用，包括png,ai,svg格式。 适合用在图标引用特别少，以后也不需要特别维护的场景。 优点: 按需引入，无需为使用少量小图标而大量引入文件。 使用环境丰富，比如用来做ppt，当图标使用即可。 项目使用unicode使用在图标库内选择需要的图标加入到购物车里，使用微博或者Github授权登录后下载。 下载后得到如下图所示文件。 附带所有需要的文件和使用demo。 特点: 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 使用步骤: 第一步：拷贝项目下面生成的font-face 12345678@font-face &#123; font-family: "iconfont"; src: url('iconfont.eot'); /* IE9*/ src: url('iconfont.eot#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('iconfont.woff') format('woff'), /* chrome, firefox */ url('iconfont.ttf') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */&#125; 第二步：定义使用iconfont的样式 12345678.iconfont &#123; font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 第三步：挑选相应图标并获取字体编码，应用于页面 1&lt;i class="icon iconfont"&gt;&amp;#xe600;&lt;/i&gt; Symbol使用第一步：引入下载项目生成的js文件 1&lt;script src="./iconfont.js"&gt;&lt;/script&gt; 第二步：加入通用css代码（引入一次就行） 1234567891011.icon &#123; /* 通过设置 font-size 来改变图标大小 */ width: 1em; height: 1em; /* 图标和文字相邻时，垂直对齐 */ vertical-align: -0.15em; /* 通过设置 color 来改变 SVG 的颜色/fill */ fill: currentColor; /* path 和 stroke 溢出 viewBox 部分在 IE 下会显示 normalize.css 中也包含这行 */ overflow: hidden;&#125; 第三步：挑选相应图标并获取类名，应用于页面： 123&lt;svg class="icon" aria-hidden="true"&gt; &lt;use xlink:href="#icon-kefuyouxian"&gt;&lt;/use&gt;&lt;/svg&gt; font-class引用推荐的使用方式 优点： 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易地通过类名分辨这个icon是什么。 要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 第一步：引入项目下面生成的fontclass代码： 1&lt;link rel="stylesheet" type="text/css" href="./iconfont.css"&gt; 第二步：挑选相应图标并获取类名，应用于页面： 1&lt;i class="iconfont icon-xxx"&gt;&lt;/i&gt; “iconfont”是你项目下的font-family。可以通过编辑项目查看和自定义修改，默认是”iconfont”。 font-awesome使用用法： 第一步： 引入CSS文件： 1&lt;link href=&quot;your-file-path/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 第二步： 在html文件中这样使用 1&lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt; 可以通过如fa-lg，fa-2x，fa-3x等来调整图标大小。 可以通过css设置样式，比如颜色等。 别的图标库 使用方式类似。 这里不再赘述，最建议使用Iconfont，因为可以由设计师来将设计好的Icon导出SVG再上传。 缺点： 不支持图标部分透明。 不支持颜色渐变。 对于上述需求，仍然可以通过PNG Spirits的形式来使用。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>图标</tag>
        <tag>icons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特征之JavaScript版]]></title>
    <url>%2Foop-features-in-javascript%2F</url>
    <content type="text"><![CDATA[最近在看《JavaScript设计模式》这本书，学习如何用最佳实践去组织代码。这本书的第二章简单讲了一下面向对象的实现，所以再深入学习一下，本文主要讲述面向对象的三大特性在JavaScript中的实现。 三大特性面向对象编程(OOP)有着三大特性，分别是继承、封装和多态。 继承继承指的是一个类可以拥有另一个类的属性和方法，并且可以对其方法进行重写。这样的类的关系在传统的面向对象语言中，我们称其为父类和子类。而JavaScript在ES6以前并没有严格的类的定义，不过我们可以通过JS语法的特点模拟出继承的特性，而且更加灵活。 类式继承类式继承的方法是将父类的实例赋值给子类的原型。 12345678910111213141516171819202122232425262728293031// 父类function SuperClass () &#123; this.superValue = true&#125;// 添加方法SuperClass.prototype.getSuperValue = function () &#123; return this.superValue&#125;// 子类function SubClass () &#123; this.subValue = false&#125;// 继承父类SubClass.prototype = new SuperClass()// 为子类添加方法SubClass.prototype.getSubValue = function () &#123; return this.subValue&#125;// 用子类实例化对象let s = new SubClass()// 调用父类方法console.log(s.getSuperValue())// 调用子类方法console.log(s.getSubValue())// 检查实例console.log(s instanceof SuperClass) // trueconsole.log(s instanceof SubClass) // trueconsole.log(SubClass instanceof SuperClass) // false // 只检验是否实例 不检验继承关系console.log(SubClass.prototype instanceof SuperClass) // trueconsole.log(s instanceof Object) // true Object是所有对象的祖先 缺点： 若父类的共有属性中有引用类型，那么此属性会在类的所有实例中共用。一个实例更改了此引用类型后会影响别的实例的此属性。 因为类式继承依靠的是子类的原型指向实例化的父类对象，但是在实例化的过程是无法传递参数的，因此也就无法对父类的属性进行初始化。 12345678910111213141516// 父类function SuperClass () &#123; this.books = [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;]&#125;// 子类function SubClass () &#123;&#125;// 继承父类SubClass.prototype = new SuperClass()let s1 = new SubClass()let s2 = new SubClass()console.log(s2.books) // [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;]s1.books.push(&apos;vue&apos;)console.log(s1.books) // [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;, &apos;vue&apos;]console.log(s2.books) // [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;, &apos;vue&apos;] 构造函数继承构造函数继承解决了上面的引用类型属性共用问题。 SuperClass.call(this, id)这句代码把子类中的变量在父类中执行了一遍，而且将属性方法绑定在了this上。 因为这种继承方法并没有涉及原型，所以父类原型上的方法不会被子类继承。 而如果想要被子类继承，就需要把这个方法放在父类的构造函数里，但是这样创建出来的实例会每个都有单独的此方法不能共用，违背了代码的复用原则。 1234567891011121314151617181920212223242526// 父类function SuperClass (id) &#123; this.books = [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;] this.id = id&#125;// 父类原型方法SuperClass.prototype.showBooks = function () &#123; console.log(this.books)&#125;// 子类function SubClass (id) &#123; // 继承父类 SuperClass.call(this, id)&#125;let s1 = new SubClass(10)let s2 = new SubClass(11)console.log(s2.books) // [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;]console.log(s1.id) // 10console.log(s2.id) // 11s1.books.push(&apos;vue&apos;)console.log(s1.books) // [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;, &apos;vue&apos;]console.log(s2.books) // [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;]// 不能继承父类原型上的方法s1.showBooks() // s1.showBooks is not a function 组合继承组合继承结合了类式继承和构造函数继承2者的优点，又解决了2者的问题。 12345678910111213141516171819202122232425262728293031// 父类function SuperClass (name) &#123; this.books = [&apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;] this.name = name&#125;SuperClass.prototype.getName = function () &#123; console.log(this.name)&#125;// 子类function SubClass (name, time) &#123; // 继承父类 SuperClass.call(this, name) this.time = time&#125;// 类式继承 子类原型继承父类原型SubClass.prototype = new SuperClass()SubClass.prototype.getTime = function () &#123; console.log(this.time)&#125;let s1 = new SubClass(&apos;ng&apos;, 2015)let s2 = new SubClass(&apos;react&apos;, 2016)s1.books.push(&apos;node&apos;)console.log(s1.books) // [ &apos;js&apos;, &apos;jq&apos;, &apos;bs&apos;, &apos;node&apos; ]s1.getName() // &apos;ng&apos;s1.getTime() // 2015console.log(s2.books) // [ &apos;js&apos;, &apos;jq&apos;, &apos;bs&apos; ]s2.getName() // &apos;react&apos;s2.getTime() // 2016 小缺点：使用构造函数继承父类时候执行了一遍父类函数，实现子类原型式继承的时候又执行了一次父类函数。 原型式继承原型式继承是对类式继承的一个封装，其中的过渡对象相当于类式继承里的子类，不过它的目的是为了创建将要返回的新的实例化对象。 但是它创建的继承关系仍然存在着类式继承的缺点。后期类似地发展为了Object.create()方法。 123456789101112131415161718// 原型式继承function inheritObject (o) &#123; // 声明一个过渡函数对象 function F () &#123;&#125; // 过渡对象的原型继承父对象 F.prototype = o // 返回一个过渡对象的实例，该实例的原型继承了父对象 return new F()&#125;// 使用方式var book = &#123; name: &apos;js&apos;, alikeBook: [&apos;html&apos;, &apos;css&apos;]&#125;var o = inheritObject(book)console.log(o.name) // &apos;js&apos;console.log(o.alikeBook) // [&apos;html&apos;, &apos;css&apos;] 寄生式继承封装封装指的是类对其拥有的属性或者方法的暴露和隐藏。通过封装可以实现类的属性或者方法的私有化，避免被访问或者修改。 在JavaScript中，作用域是由函数来分割的，声明在函数内部的变量和方法在函数外部是无法访问到的。我们可以通过这一语言特性来创建类的私有方法和私有属性。 在函数的内部，通过this创建的变量和函数，在类创建对象的时候，每个对象都会自动生成一份并且可以在外部访问和修改。因此通过this创建的方法和属性可以看做是对象的公有方法和公有属性。 并且通过this创建的方法，不仅可以访问this创建的公有属性和公有方法，还能访问到类创建时或者对象自身的私有属性和私有方法。由于这些方法的权力较大，我们讲其称为特权方法 在对象创建的过程中，通过使用这些方法，我们可以实例化对象的一些属性。因此，这些在创建对象时候调用的方法还可以看做是类的构造器。 在类的外面通过点语法创建的属性和方法可以通过类来使用，它们被称为是类的静态共有属性和静态共有方法。 通过prototype创建的属性和方法在类实例的对象中是可以通过this来访问到的。它们被称为是共有属性和共有方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let Book = function (id, name, price) &#123; // 私有属性 let num = 17 // 私有方法 let checkId = () =&gt; &#123; console.log(&apos;checkId&apos;) &#125; // 特权方法 this.getName = () =&gt; &#123;&#125; this.getPrice = () =&gt; &#123;&#125; this.setName = () =&gt; &#123;&#125; this.setPrice = () =&gt; &#123;&#125; // 公有属性 this.id = id // 对象公有方法 this.copy = () =&gt; &#123;&#125; // 构造器调用 this.setName(name) this.setPrice(price)&#125;// 类静态公有属性(对象无法访问)Book.isChinese = true// 类静态公有方法(对象无法访问)Book.resetTime = () =&gt; &#123; console.log(&apos;New Time!&apos;)&#125;// 公有属性和公有方法Book.prototype = &#123; isJSBook: false, display: () =&gt; &#123; console.log(&apos;Display!&apos;) &#125;&#125;;// 创建对象let book = new Book(123, &apos;JavaScript设计模式&apos;, 50)// 私有属性和方法console.log(book.num) // undefiedbook.checkId() // book.checkId is not a function// 原型上的属性和方法console.log(book.isJSBook) // falsebook.display() // &apos;Display!&apos;// 类的对象公有属性console.log(book.id) // 123// 类静态公有属性和方法console.log(book.isChinese) // undefiedconsole.log(Book.isChinese) // trueBook.resetTime() // &apos;New Time!&apos; 总结 我们通过类创建对象： 类里面新声明的属性和方法是对象无法访问的(私有属性和方法) 挂载在this上方法可以访问私有属性和方法，还可以访问原型上的属性和方法(特权方法) 原型上的方法，不可以调用类里面的方法，因为要遵循原型链的规定。 类自身上还可以挂载其他的方法和属性，但是必须通过类名去访问。(静态属性和方法) 闭包实现封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 创建闭包let Book = (function (newId, newName, newPrice) &#123; // 静态私有变量 let bookNum = 0 // 静态私有方法 let checkBook = (name) =&gt; &#123;&#125; // 创建类 function _book (newId, newName, newPrice) &#123; // 私有变量和方法 var name, price function checkId () &#123;&#125; // 特权方法 this.setName = (n) =&gt; &#123; name = n &#125; this.setPrice = (p) =&gt; &#123; price = p &#125; // 读取私有变量 this.getName = () =&gt; &#123; console.log(name) &#125; this.getPrice = () =&gt; &#123; console.log(price) &#125; // 公有属性 this.id = newId // 公有方法 this.copy = () =&gt; &#123;&#125; bookNum++ if (bookNum &gt; 100) &#123; throw new Error(&apos;我们仅出版100本书&apos;) &#125; // 构造器 // 设置私有变量 this.setName(newName) this.setPrice(newPrice) &#125; // 构建原型 _book.prototype = &#123; // 静态公有属性 isJSBook: false, // 静态公有方法 display: ()=&gt; &#123;&#125; &#125; return _book // 返回对象&#125;)() // 闭包结束// 实例化对象let book = new Book(123, &apos;ntnyq的博客&apos;, 232)// 通过特权方法成功读取了私有变量book.getName() // &apos;ntnyq的博客&apos;book.getPrice() // 232 闭包实现的封装里的思想是，通过new来将实例化的对象的this指向了闭包返回的对象。而闭包返回的是一个函数，这个函数通过自执行创建内部实例化的对象。函数内部因为作用域链的关系，还可以访问类的属性和方法。 多态]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象之对象创建]]></title>
    <url>%2Foop-create-object%2F</url>
    <content type="text"><![CDATA[实例代码使用了ECMAScript2015语法。因为学习ES6很有必要，所以平时应该多抓住机会练习。本文主要整理一下JavaScript中类的创建的相关知识。 面向对象面向对象(Object-Oriented)是一种抽象编程的模式。 其核心思想是将一切事物都可以抽象地看做是类(JavaScript在ES6前并没有类，但是我们可以通过代码模拟出类的功能)，对象是由类创建出来的实例，然后对象可以拥有创建它的类的构造函数定义的的属性和方法，在代码编写中也就是变量和函数。 面向对象的编程方式可以有效地提高系统的灵活性，代码的复用性和软件的可扩展性。可以使程序更加便于分析、设计和理解。 本文我们将会从对象的创建来开始学习面向对象的编程方式在JavaScript中的实现。 创建方式以下是几种常见的JavaScript中创建对象的方式。 简单工厂模式简单工厂模式的解决方案是创建一个工厂函数，在函数里创建一个Object对象的实例，然后将此工厂函数所有的参数都赋值给创建的对象，最后再将这个对象返回。 1234567891011121314151617181920// 工厂函数let Person = (name, job, age) =&gt; &#123; let o = new Object() o.name = name o.job = job o.age = age o.intro = () =&gt; &#123; console.log(`My name is $&#123;name&#125;, my job is a $&#123;job&#125;, and my age is $&#123;age&#125; years old.`) &#125; return o&#125;// 创建对象let p1 = Person(&apos;ntnyq&apos;, &apos;fe&apos;, 25)// 属性查看console.log(p1.name) // &apos;ntnyq&apos;console.log(p1.job) // &apos;fe&apos;console.log(p1.age) // 25// 方法调用p1.intro() // &apos;My name is ntnyq, my job is a fe, and my age is 25 years old&apos; 构造函数模式使用构造函数创建对象是这样的，先使用new操作符创建出一个对象foo，并且使foo.proto = Foo.prototype，再调用Foo.apply(foo, arguments)。 123456789101112131415161718192021222324// 构造函数let Person = function (name, job, age) &#123; this.name = name this.job = job this.age = age this.intro = () =&gt; &#123; console.log(`My name is $&#123;name&#125;, my job is a $&#123;job&#125;, and my age is $&#123;age&#125; years old.`) &#125;&#125;// 创建对象let p1 = new Person(&apos;ntnyq&apos;, &apos;fe&apos;, 25)// 属性查看console.log(p1.name) // &apos;ntnyq&apos;console.log(p1.job) // &apos;fe&apos;console.log(p1.age) // 25// 方法调用p1.intro() // &apos;My name is ntnyq, my job is a fe, and my age is 25 years old&apos;// 另外创建一个对象let p2 = new Person(&apos;emmet&apos;, &apos;rd&apos;, 23)// 比较2个对象的方法console.log(p1.intro === p2.intro) // false 后面暴露出一个问题，就是我们在创建不同的对象的时候，构造函数会给每个对象都生成它各自的方法，这些方法是不同的。这是很耗费性能的。下面的原型模式可以帮助我们解决。 ES6的箭头函数有着this指向不变的特点，但是在构造函数中要改变this的指向，所以是不能通过箭头函数来定义构造函数的，也不能通过箭头函数来扩展对象的原型方法 原型模式原型模式上面可以定义创建出的对象所共用的方法，避免同样的方法被多次创建，浪费内存。理解原型模式，需要深刻理解JavaScript中原型链的相关知识。 1234567891011121314151617181920212223242526272829// 定义构造函数let Person = function () &#123;&#125;// 在原型上写方法Person.prototype = &#123; constructor: Person, name: &apos;ntnyq&apos;, job: &apos;fe&apos;, age: 25, intro () &#123; console.log(`My name is $&#123;this.name&#125;, my job is a $&#123;this.job&#125;, and my age is $&#123;this.age&#125; years old.`) &#125;&#125;// 创建对象let p1 = new Person()// 属性查看console.log(p1.name) // &apos;ntnyq&apos;console.log(p1.job) // &apos;fe&apos;console.log(p1.age) // 25// 方法调用p1.intro() // &apos;My name is ntnyq, my job is a fe, and my age is 25 years old&apos;// 另外创建一个对象let p2 = new Person()// 比较2个对象的方法console.log(p1.intro === p2.intro) // true 混合模式事实上我们在开发过程中使用的最多的还是混合模式，我们在构造函数内定义实例的属性，在原型上定义公有的属性的方法。这样可以实现每个实例有自己的特征，又大限度的节省了内存。而且这种模式中，还可以向构造函数传递参数来创建实例。 123456789101112131415161718192021222324252627282930// 构造函数let Person = function (name, job, age) &#123; this.name = name this.job = job this.age = age&#125;// 原型Person.prototype = &#123; constructor: Person, intro () &#123; console.log(`My name is $&#123;this.name&#125;, my job is a $&#123;this.job&#125;, and my age is $&#123;this.age&#125; years old.`) &#125;&#125;// 通过传入参数创建2个实例let p1 = new Person(&apos;ntnyq&apos;, &apos;fe&apos;, 25)let p2 = new Person(&apos;emmet&apos;, &apos;rd&apos;, 24)// 属性查看console.log(p1.name) // &apos;ntnyq&apos;console.log(p1.job) // &apos;fe&apos;console.log(p1.age) // 25console.log(p2.name) // &apos;emmet&apos;console.log(p2.job) // &apos;rd&apos;console.log(p2.age) // 24// 方法调用p1.intro() // &apos;My name is ntnyq, my job is a fe, and my age is 25 years old&apos;p2.intro() // &apos;My name is emmet, my job is a rd, and my age is 24 years old&apos;console.log(p2.intro === p1.intro) // true 安全构造函数我们都知道，用构造函数创建一个实例需要使用new关键字，而在实际的生产中，我们可能会因为一时疏忽忘记写new了，而这样的小bug甚至可能会让我们花大工夫去寻找。 1234567891011121314151617let Person = function (name, job, age) &#123; this.name = name this.job = job this.age = age&#125;let p1 = Person(&apos;ntnyq&apos;, &apos;fe&apos;, 25)// 此种情况 函数会在全局环境中执行 属性会被挂载到全局对象上// 浏览器中为window node中为globalconsole.log(p1.name) // undefinedconsole.log(p1.job) // undefinedconsole.log(p1.age) // undefinedconsole.log(window.name) // &apos;ntnyq&apos;console.log(window.job) // &apos;fe&apos;console.log(window.age) // 25 事实上我们可以通过使用安全构造函数来解决这个粗心导致的毛病。当然我们的编码是很严肃的，该有new关键字的地方还是得使用。 123456789101112131415let Person = function (name, job, age) &#123; if (this instanceof Person) &#123; // 检查this指向是否是构造函数的实例 this.name = name this.job = job this.age = age &#125; else &#123; // 若不是则调用构造函数 return new Person(name, job, age) &#125;&#125;let p1 = Person(&apos;ntnyq&apos;, &apos;fe&apos;, 25) // 没有new关键字console.log(p1.name) // &apos;ntnyq&apos;console.log(p1.job) // &apos;fe&apos;console.log(p1.age) // 25 参考资料JavaScript设计模式——张容铭 著第二章]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件开发学习及简单实例]]></title>
    <url>%2Fdialog-widget%2F</url>
    <content type="text"><![CDATA[组件开发是分组协作开发的实现方式，同时也实现了代码的复用。对前端的优化大有裨益，同时也是面向对象编程的实现，符合开放封闭原则，对代码的重构维护都有极大的优点。 实现步骤第一步 基础先用假数据做好布局等以及确立好需要创建的元素 第二步 构架将代码放入到如下结构中 防止变量的全局污染 123;(function(win, doc) &#123; 'use strict'; // 此句可以不加&#125;)(window, document); 第三步 构造函数使用以下两种方式创建构造函数 12345678// 1function Foo(xx, xx) &#123;&#125;// 2var Bar = function (xx, xx)&#123;&#125; 第四步 构造函数的原型方法使用如下方法给构造函数的原型添加方法 1234567891011121314151617181920// 1Foo.prototype.method1 = function () &#123;&#125;;Foo.prototype.method2 = function () &#123;&#125;;// 2Bar.prototype = &#123; // constructor: Bar, method1: function () &#123; &#125;, method2: function () &#123; &#125;&#125;;// 构造函数原型里 可以通过this对象来引用构造函数的变量 第五步 创建实例对象可以通过最后调用函数来创建 也可以通过事件来创建 或者将对象创建的过程 写在init的函数调用中 注意要传递所有的参数 参数是可选的。 第六步 将构造函数挂载到全局对象1win.Foo = Foo; 注意 因为好多元素可能是动态创建的， 所以动态创建的元素要用到事件委托来添加相关的方法给原型绑定事件的时候，因为事件不是发生在原型上 所以要把原型对象存入变量 123456var _this = this; xxx.onsomething = function (e) &#123; _this.method(); &#125;; 组件开发简单实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// js部分;(function (win, doc) &#123; // dom元素 var $ = function (id) &#123; return typeof id === 'string' ? document.getElementById(id) : id; &#125;; // 构造函数 var Dialog = function (id, str) &#123; this.id = id; this.str = str; this.open = false; &#125;; // 原型方法 Dialog.prototype = &#123; // 初始化 init: function () &#123; this.bindEvent(); &#125;, // 展现 create: function () &#123; if (!this.open) &#123; var dialog = document.createElement('div'), span = document.createElement('span'), mask = document.createElement('div'); span.innerHTML = this.str; dialog.id = this.id; mask.id = 'mask'; dialog.appendChild(span); document.body.appendChild(dialog); document.body.appendChild(mask); setTimeout(function () &#123; dialog.classList.add('show'); &#125;, 0); this.open = true; &#125; &#125;, // 删除 delete: function () &#123; if (this.open) &#123; var dialog = $(this.id), mask = $('mask'); setTimeout(function () &#123; dialog.classList.remove('show'); &#125;, 200); document.body.removeChild(dialog); document.body.removeChild(mask); this.open = false; &#125; &#125;, // 事件绑定 bindEvent: function () &#123; var _this = this; $('open').onclick = function (e) &#123; _this.create(); &#125;; document.addEventListener('click', function (e) &#123; if (e.target &amp;&amp; e.target.id === 'mask') &#123; _this.delete(); &#125; &#125;, false); &#125; &#125;; // 创建实例 // var createInstance = function () &#123; // var instance; // return instance || new Dialog('dialog', '我是弹窗！'); // &#125;; // 操作方法 // var operate = &#123; // setDialog: null, // open: function () &#123; // this.setDialog = createInstance(); // this.setDialog.create(); // &#125;, // close: function () &#123; // this.setDialog ? this.setDialog.delete() : ''; // &#125; // &#125;; // 绑定事件 // $('open').onclick = function (e) &#123; // operate.open(); // e.stopPropagation(); // &#125;; // document.body.onclick = function () &#123; // operate.close(); // &#125;; win.Dialog = Dialog;&#125;)(window, document); 1234567891011121314151617// html部分&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;title&gt;对话框组件&lt;/title&gt; &lt;link rel="stylesheet" href="src/css/style.css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="btn-group"&gt; &lt;button id="open" class="btn btn-primary"&gt;弹出&lt;/button&gt; &lt;/div&gt; &lt;script src="src/js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// css部分html,body,div,span,button &#123; margin: 0; padding: 0;&#125;body &#123; font-family: "Times New Roman", Times, Baskerville, Georgia, serif; font-size: 24px;&#125;.btn-group &#123; position: absolute; bottom: 15%; width: 100%; text-align: center;&#125;.btn &#123; display: inline-block; padding: 6px 100px; border: 1px solid transparent; border-radius: 4px; line-height: 1.4; text-align: center; font-weight: 400; vertical-align: middle; cursor: pointer;&#125;.btn-primary &#123; background-color: #337ab7; border-color: #2e6da4; color: #fff;&#125;#dialog &#123; position: absolute; left: 50%; top: 10%; z-index: 100; margin-left: -200px; width: 360px; height: 260px; padding: 20px; border: 2px solid #3997ff; background-color: #fff; box-shadow: 0 5px 15px #999; line-height: 1.42; text-align: center; color: #666; transition: all 0.2s ease-in; transform: scale(1, 0); opacity: 0; -webkit-user-select: none; cursor: pointer;&#125;#dialog.show &#123; transform: scale(1); opacity: 1;&#125;#mask &#123; position: fixed; z-index: 66; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6对象扩展方法学习。]]></title>
    <url>%2Fes6-object%2F</url>
    <content type="text"><![CDATA[ES6是当前web前端开发的一种趋势，虽然仍然存在有兼容性问题，但我们可以通过工具将其编译成ES5来使用，而ES6带来的开发效率提升是显著的。 本文是对阮一峰老师的ECMAScript 6入门中对象扩展一章的学习笔记。 ES6对象扩展属性的简洁写法ES6规定了以字面量的形式创建对象时的简洁写法。 直接写入一个变量，后面加逗号，则会以变量名做为对象的属性名，以变量值做为对应的属性值。 直接写一个变量做为方法名，后面跟括号写入方法参数，接着在大括号里写上函数的内容。 12345678910111213141516171819let name = 'ntnyq';let user = &#123; name, sayName () &#123; console.log(`My name is $&#123;this.name&#125;!`); &#125;&#125;;console.log(user.name) // ntnyquser.sayName() // My name is ntnyq!// 传统写法var user = &#123; name: name, sayName: function () &#123; console.log('My name is' + this.name + '!'); &#125;&#125;; Object.is()Object.is()方法用于进行同值相等的比较，为了解决传统的===操作符下，NaN与NaN不相等的情况。 使用方式就是直接传入2个要比较的字面量或者值，然后得到一个布尔值。 它的运算规则，与===的效果基本相同。 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 // trueNaN === NaN // falseObject.is(+0, -0); // falseObject.is(NaN, NaN); // true Object.assign()Object.assign()方法，用于将至少1个对象的可枚举属性合并到目标对象上。 语法 123Object.assign(target, source1, source2, ...);Object.assign(&#123;a: 1&#125;, &#123;b: 2&#125;, &#123;c: 3&#125;); // &#123;a: 1, b: 2, c: 3&#125; 若目标对象与源对象有同名属性，则后面的属性会覆盖前面的 如果参数只有一个对象，那么会直接返回这个对象 如果参数不是对象，则会将其转为对象，再返回。 undefined与null无法被转换成对象，所以会报错。 如果非对象参数没有出现在源对象的位置，这时候如果无法转换为对象，则会跳过这个属性。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性。 Object.assign的拷贝是进行的浅拷贝，数组与对象得到的将会是它们的引用，并且无法拷贝继承得到的属性。 用途： 为对象添加属性 为对象添加方法 克隆对象 合并多个对象 设置默认属性 Object.keys()ES5引入了Object.keys()方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 ES6引入了Object.values()与Object.entries()来返回对象的键值和名与值组成的数组。 123456789101112131415let &#123;keys, values, entries&#125; = Object // 对象的结构赋值let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // ['a', 'b', 'c']&#125;for (let key of values(obj)) &#123; console.log(values); // [1, 2, 3]&#125;for (let key of entries(obj)) &#123; console.log(entries); // [['a', 1], ['b', 2], ['c', 3]]&#125; 解构赋值对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 解构赋值要求等号两边都必须为对象，所以右边如果是undefined或者null会报错。 解构赋值的spread操作符和其后的变量必须处在最后一位，否则会报错。 解构赋值是浅拷贝 1234567let obj = &#123; a: 1, b: 2, c: 3, d: 4&#125;;let &#123; a, b, ...c &#125; = objconsole.log(a) // 1console.log(b) // 2console.log(c) // &#123; c: 3, d: 4&#125; 用法克隆一个对象 12345let obj = &#123; name: 'foo', age: 18, say (str) &#123; console.log(`Hello, $&#123;str&#125;`) &#125;&#125;;let newObj = &#123;...obj&#125;;// 这样的克隆对象是深拷贝 Object.create()返回一个新创建的对象。 根据一个对象的属性和方法来创建一个新的对象，可以以类似原型链的方式获取原对象的属性和方法，却不继承原对象的原型。 使用方法如下： 1234var obj = Object.create(&#123; name: 'ntnyq', age: 25 &#125;);console.log(obj.name) // =&gt; 'ntnyq'console.log(obj.prototype) // =&gt; undefined]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-zhihudaily项目踩坑总结]]></title>
    <url>%2Fvue-zhihudaily-project%2F</url>
    <content type="text"><![CDATA[学习vue框架中，一边学一边做的一个小项目，记录一下踩的一些坑，并且贴一下寻到的解决方案。 项目介绍利用vue系列全家桶仿照知乎日报做的小项目，利用了知乎日报的API。 模块/工具 作用/功能 vue-cli 脚手架搭建项目结构 vuex 状态管理 vue-resource 请求后端数据 vue-router 路由信息管理 webpack 自动化构建 vue-devtools 调试代码 查看状态 知乎API 提供数据 API介绍 开发过程保存了一部分json假数据用于开发过程中使用，整个项目耗时三天。因为先前做了个没有框架的知乎日报移动端版本，所以这个里面没有去过多纠结移动端适配的问题。直接使用了bootstrap进行布局。对页面结构只做了简单的响应式处理，未做太多的移动端的优化。 因为对于vue也是个初学者，所以整个开发期间，基本闲暇时间或者遇到问题就会去查看官方的docs，然后再进行尝试，或者在segmentfault上寻求答案。 因为vue的MVVM模式是以数据为核心，而非传统的以DOM为核心的模式，所以在开发过程中的原则就是避免直接以传统模式操作DOM。 然后就这样磕磕绊绊的，总算是做了点东西出来了。 开发中的坑 情景: 仍然和上个移动端版本的坑一样，页面间传值的问题。因为是做的一个新闻展示的应用，首页都是简单的新闻摘要，要通过点击摘要进入到相应的新闻详情页，这里主要是提供了一个新闻的ID。然后再进入详情页后，通过新闻详情的API请求对应的文件。不过区别的是另个版本的是页面间传值，vue的是组件间传值。 原因: 因为先前做的DEMO结构都比较简单，传值是父子组件间的传值，是通过在父组件内给子组件绑定属性(v-bind)，再在子组件中通过props来接收的方法来实现 12345678910111213141516171819202122232425262728293031323334父组件 Parent.vue&lt;template&gt; &lt;child :id=&quot;id&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Parent&apos;, data () &#123; return &#123; id: &apos;&apos; &#125; &#125; &#125;&lt;/script&gt;子组件 Child.vue&lt;template&gt; &lt;h1&gt;&#123;&#123; id &#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Child&apos;, props: &#123; id: &#123; type: String, required: true &#125; &#125; &#125;&lt;/script&gt; 解决方案: 这个方案是直接在官方API里面看到的，那就是vue-router的动态路由匹配。通过给匹配的路由加上一个参数来匹配多个路由。 1234567891011// 匹配/xx/aa, /xx/bb 等等const routes = &#123; [ path: &apos;/xx/:xx&apos;, name: &apos;xx&apos;, component: Xxx ]&#125;// 在路由跳转的时候如此设置参数:to=&quot;&#123;name: &apos;xx&apos;, params: &#123;xx: &apos;xxx&apos;&#125;&quot; // 注意to前面的冒号 别的解决方案: 通过路由的query参数传递 通过vuex来传递 情景: 过渡效果的实现。传统的以DOM为核心的模式，直接操作DOM来附加动画效果。那么在数据核心中如何实现呢。比如我要做的一个效果侧边栏x方向移动-100%，只有在点击后才渲染它，也就是未点击的时候，这个侧边栏本身是不存在的。还有就是点赞显示的动态效果。 简单的想象中的解决方案。设置display为none，通过点击后绑定切换display属性，来让其显示。 不过在学些了官方文档后，发现有针对这种问题提供的方案，transition,使用官方的过渡控制，可以方便地使用第三方的CSS或者JS动画库，而且可以与vue的生命周期函数有很好的契合。 适用于 条件渲染（使用 v-if） 条件展示（使用 v-show） 动态组件 组件根节点 情景: 路由跳转问题，如何在函数内让页面渲染跳转到某个指定的路由，要做一个点击后路由回退的效果---点击分享后回退到文章详情页 记得先前有看过vue-router是有这个API的，叫$route.go()或者$route.push()，然后当我尝试后，发现提示不存在这个方法。 后来却segmentfault查询后才知道，是有2种路由对象的。一个是$route表示当前vue实例的路由，另一个是$router来控制全局的路由跳转。 官方文档介绍 情景: 实现页面的无限加载，类似单列瀑布流的效果。 因为貌似vue没有scroll事件的API。(在官方DOCS未找到，vue-router有滚动行为的API控制跳转后页面滚动) 在segmentfault上有人提供了的方案是用DOM监听页面滚动事件，然后挂载到vue的生命周期钩子上。 在github上发现了一个vue-scroll的插件，不过下载了后看了一下，还是封装的原生JavascriptDOM处理。 所以最终的解决方案还是去用DOM监听了。 情景：使用使用的知乎API，知乎提供的新闻详情页面的内容是html格式的，但是用v-html指令渲染到页面后，设置了style标签的scoped属性后，设置的样式无法影响到动态的内容 暂时的解决方案是 不加scoped属性 情景：侧边栏的内容过多，超过了100%高度，PC端会出现滚动条，特别丑。 解决方案： 1.尽量不要让其超过100%高度 2. 滚动条美化(渐进增强的方案) 1234567891011121314::-webkit-scrollbar &#123; // 设置滚动条宽度 width:0; /* or */ display:none;&#125;::-webkit-scrollbar-thumb &#123; // 设置滑块颜色 background-color: #33a877 !important;&#125;::-webkit-scrollbar-button &#123; // 滑轨两端的样式控制 background-color: #33a877;&#125; 开发结束后的坑 布局混乱 有个页面设置了width: 100%和height: 100% 然后里面的元素是用百分比定位的，在竖屏查看时候效果很好，切换到横屏后就出现上下部分内容重合了 解决方案：去掉height: 100%属性 让其自动变化 移动端浏览器下查看因为有地址栏，在侧边栏和主页面都可以向上滑动的情况下，侧边栏先于主页面滑动到顶部会导致无限加载的功能无效，而且侧边栏全部上滑后会带动主页面上面地址栏消息，让100%高度固定定位侧边栏布局混乱，会向上移动地址栏的高度。 使用一个DOM的解决方案，不过并没有很好的解决问题。 可使用方案。浏览器强制全屏，隐藏掉地址栏，不过只有部分浏览器提供这样的元信息设置(meta)。 1234// UC浏览器&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;// QQ浏览器&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot; /&gt; 想象中的方案： 在检测到侧边栏的滑动后，同时让主页面上滑，隐藏地址栏，这样再滑动侧边栏应该就不会定位布局混乱了。 在侧边栏滑动的时候，禁止主页面的滑动，让其固定。 固定定位的布局，在移动端虚拟键盘弹出后，定位元素会被顶地上移。查询得知这种问题主要出现在android平台上。 解决方案 转场输入，预留出虚拟键盘的弹出空间 在输入框获得焦点后虚拟键盘弹出后，不再使用定位来布局，通过js来控制元素的位置，或者重新定位布局。 无限加载效果，在移动端有时候不起作用，比如路由跳转以后，再跳转回来。即是监听路由变化，重新绑定滚动监听事件仍然无法起作用。 因为对vue的事件绑定取消机制不熟悉，这个问题还有待研究。 在路由跳转后，刷新页面会显示页面不存在。 vuex数据消失 原因：vuex数据在页面刷新后被清除了，没有数据自然也就没有页面的展现了。 解决方案1，利用localstorage对数据进行缓存。 解决方法2, 将数据放在根组件app.vue中，子页面通过this.$root.data获取。 页面404 原因：vue-router配置了mode:’history’，history模式配置需要后台配合，否则刷新后页面不存在 解决办法 使用hash模式 总结踩坑多多，学习多多，双向数据绑定真的很方便，官方DOCS必须要熟悉。数据核心的模式感觉蛮锻炼逻辑的，组件开发很好很强大。比如样式都可以设置成范围的，那么最终其实主要就是各个组件实现的是对约定好的vuex的数据里的操作，然后在暴露给别人自己应该提高的数据。命名什么的并不存在多大的冲突问题。而且组件可复用性很好。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FormData对象上传图片到php服务器]]></title>
    <url>%2Fupload-pic-to-php-server%2F</url>
    <content type="text"><![CDATA[前两天项目里要用到图片上传服务器的功能，我倒是以前看过这方面的资料，然后就写了一下只前端的代码，然后后台的哥们儿来问我应该怎么接收图片参数，嗯，我也懵了。 反思所以说，没有调查就没有发言权，没有实践怎么能随便把代码给别人。 然后只能去网上搜了两篇上传图片的教程发给他，然后自己看了一下，ajax方法的参数自己的都少写了几个。 哎，我的锅啊。 所以周末休息，就自己找找方法测试一下。 还有，以后不能这样啊！！！ 代码直接上代码就是了, 用的jquery写的，注释足以解释了。 123&lt;input id="file" type="file" accept="images/*" multiple="true" /&gt;&lt;button id="upload" type="button"&gt;上传&lt;/button&gt;&lt;div id="preview"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839$(function () &#123; var $file = $('#file'), $upload = $('#upload'), $preview = $('#preview'); // 预览 var fd = new FormData(); // 创建formdata对象 // 监听表单控件change事件 $file.change(function(e) &#123; var img = $(this).get(0).files[0]; var str = ''; if (img.type.match('image.*')) &#123; // 检测选择文件类型 var url = window.URL.createObjectURL(img), // blob对象创建图片路径 name = img.name, size = img.size; str = `&lt;div&gt;&lt;img src="$&#123;url&#125;" alt="预览图片"&gt; &lt;p class="title" title="$&#123;name&#125;"&gt;$&#123;name&#125;&lt;/p&gt; &lt;p class="size"&gt;($&#123;size&#125; KB)&lt;/p&gt;&lt;/div&gt;`; fd.append('file', img); // 将图片加至FormData对象 &#125; $preview.html(str); // 添加预览 &#125;); // 点击上传图片 $upload.click(function(e) &#123; $.ajax(&#123; url: 'recieve.php', type: 'POST', processData: false, contentType: false, data: fd &#125;) .done(function(res) &#123; console.log(res); &#125;) .fail(function(err) &#123; console.log(err); &#125;); &#125;);&#125;); 12345678910111213141516171819&lt;?php$file = $_FILES['file']; // 获取传输数据$name = $file['name']; // 获取文件名$type = strtolower(substr($name,strrpos($name,'.')+1)); // 文件类型$allow_type = array('jpg','jpeg','gif','png');if(!in_array($type, $allow_type))&#123; // 类型判断 return ;&#125;if(!is_uploaded_file($file['tmp_name']))&#123; // 是否post上传 return ;&#125;$upload_path = "upload/"; // 指定存放路径if(move_uploaded_file($file['tmp_name'],$upload_path.$file['name']))&#123; echo "成功上传图片" . $name . "! \n"; echo "它保存在/" . $upload_path . $name;&#125;else&#123; echo "Oops, 上传失败!";&#125;?&gt; 目录结构12345678|-- js|--|-- jquery.min.js|--|-- main.js|-- upload| |-- a.jpg| |-- b.png|-- index.html|-- receive.php]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传预览]]></title>
    <url>%2Fupload-image%2F</url>
    <content type="text"><![CDATA[公司正在进行的项目，今天开始在踩图片上传预览的坑。这里整理一下搜索到的资料。 万恶之源早期因为浏览器对H5的支持度不够，而且input的file控件也只能选择单图上传。所以更多的文件上传采用的是flash，比如swfupload.js的实现。 而现在随着XMLHTTPRequest2.0的到来，以及更多新的比如Blob对象，FileReader对象，二进制上传等API的实现，H5的图片上传注定要成为以后的主流。 首先我们当然需要一个图片选择控件啦。控件作用，创建一个Fileupload对象。 1&lt;input type=&quot;file&quot; /&gt; input的Fileupload对象属性请参考(http://www.w3school.com.cn/jsref/dom_obj_fileupload.asp)[w3cschool] 注意：该元素的value值保存了用户选择文件的文件名，但是如果提交时候，发送给服务器的内容就又不仅仅是文件名。 上传方式 注意input对象下面的files属性是一个数组 如果只选择了一个文件，也要用files[0]来取得它。在这个files[0]对象下，有图片的name, size, type等属性。 原生上传要想使用浏览器原生的文件上传功能的话，注意给父级的form元素加上enctype=”multipart/form-data”，决定编码方式。默认的表单编码方式是application/x-www-form-urlencoded。 Blob对象 兼容性IE10+ Blob对象可以看做是存放二进制数据的容器，此外还可以通过Blob设置二进制数据的MIME类型。 文件下载window.URL对象可以为Blob对象生成一个网络地址，结合a标签的download属性，可以实现点击url下载文件。 12345678910createDownload(&quot;download.txt&quot;,&quot;download file&quot;);function createDownload(fileName, content)&#123; var blob = new Blob([content]); var link = document.createElement(&quot;a&quot;); link.innerHTML = fileName; link.download = fileName; link.href = URL.createObjectURL(blob); document.getElementsByTagName(&quot;body&quot;)[0].appendChild(link);&#125; 显示图片img的src属性及background的url属性，都可以通过接收图片的网络地址或base64来显示图片，同样的，我们也可以把图片转化为Blob对象，生成URL（URL.createObjectURL(blob)），来显示图片。 123456789101112// 兼容创建图片的url_self.getObjectURL = function(file) &#123; var url = null; if (window.createObjectURL != undefined) &#123; url = window.createObjectURL(file); &#125; else if (window.URL != undefined) &#123; url = window.URL.createObjectURL(file); &#125; else if (window.webkitURL != undefined) &#123; url = window.webkitURL.createObjectURL(file); &#125; return url;&#125; FormData上传 兼容性IE10+部分 123var formData = new FormData();formData.append(filename, files[n]);// 再用ajax发送formData内容 FileReader 对象 兼容性IE11+部分兼容 1234567891011// 读取到的是base64编码结果var fr = new FileReader();fr.readAsDataUrl(files[n])fr.onload = function (e) &#123; if(e.total/1024/1023 &gt;= 2) &#123; alert(&apos;文件大于2M&apos;) return; &#125; var img = new Image(); img.src = this.result;&#125; 优化控件外观原生的控件外观实在是太丑啦。那么如何改变呢？ 我最近用的方式是把控件设置成透明的，在下面放个模拟按钮的元素。这样点击的时候其实是点击了浮在上面的文件控件。 缺点：要使用定位 下边按钮的比如hover效果等不能触发 在看了张鑫旭的博文后，发现了这种更好的优化方式： 用label元素与file控件关联，优点： 点击自定义的漂亮按钮就是点击我们file控件 没有尺寸控制不精确的问题 没有不能响应hover态active态的问题 漂亮按钮可以与form表单元素解耦。 文件类型可以指定弹出选择窗口时允许选择的文件类型。比如 1234// 所以图片类型accept=&quot;image/*// 或用逗号隔开accept=&quot;image/png, image/jpeg, image/gif, image/jpg&quot; 我不玩啦如何清空选择呢 调用form对象的reset()方法即可。 参考资料张鑫旭：关于input表单的那些事儿 兼容性资料来自于Can I Use?]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>踩坑</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端事件汇总学习]]></title>
    <url>%2Fmobile-device-events%2F</url>
    <content type="text"><![CDATA[处在这个时代里，身为一个前端工程师是必须要学习移动端开发的。而事件则是开发的基础。 触摸事件touchtouch事件分类touchstart手指放在屏幕上触发 touchmove手指在屏幕上移动时候，连续触发 touchend手指离开屏幕触发 touchcancel当系统停止跟踪时候触发 当更高级事件发生会触发 比如来电话 发生时候会暂停游戏 存档等操作 移动端事件会触发浏览器默认行为，所以调用事件要阻止默认行为 12345678910111213document.addEventListener(&apos;touchstart&apos;,function(ev)&#123; ev.preventDefault();&#125;);var box=document.getElementById(&quot;box&quot;);box.addEventListener(&apos;touchstart&apos;,function()&#123; this.innerHTML=&apos;手指按下了&apos;;&#125;);box.addEventListener(&apos;touchmove&apos;,function()&#123; this.innerHTML=&apos;手指移动了&apos;;&#125;);box.addEventListener(&apos;touchend&apos;,function()&#123; this.innerHTML=&apos;手指离开了&apos;;&#125;); touch事件对象ev.touches 当前屏幕上的手指列表ev.targetTouches 当前元素上的手指列表ev.changedTouches 触发当前事件的手指列表 每个touch对象都包含以下几个属性 clientX //触摸目标在视口中的X坐标。 clientY //触摸目标在视口中的Y坐标。 Identifier //标示触摸的唯一ID。 pageX //触摸目标在页面中的X坐标。 pageY //触摸目标在页面中的Y坐标。 screenX//触摸目标在屏幕中的X坐标。 screenY //触摸目标在屏幕中的Y坐标。 target // 触摸的DOM节点目标。 123456var box=document.getElementById(&quot;box&quot;);//相当于mousedownbox.addEventListener(&apos;touchstart&apos;,function(ev)&#123; //console.log(ev.touches); this.innerHTML=ev.touches.length;//按下手指数&#125;); 设备加速事件 devicemotiondevicemotion 封装了运动传感器数据的事件 可以获取手机运动的状态 其中加速度的数据包含以下三个方向： 横向贯穿手机屏幕 x 纵向贯穿手机屏幕 y 垂直手机屏幕 z 鉴于有些设备没有排除重力的影响，所以该事件会返回2个属性 accelerationIncludingGravity(含重力的加速度) acceleration(排除重力的加速度) 这个事件只能放在window对象上 1234window.addEventListener(&apos;devicemotion&apos;,function(ev)&#123; var motion=ev.accelerationIncludingGravity; box.innerHTML=&apos;x:&apos;+motion.x+&apos;&lt;br/&gt;&apos;+&apos;y:&apos;+motion.y+&apos;&lt;br/&gt;&apos;+&apos;z:&apos;+motion.z;&#125;); // 显示重力加速度 12345window.addEventListener(&apos;devicemotion&apos;,function(ev)&#123; var motion=ev.accelerationIncludingGravity; var x=parseFloat(getComputedStyle(box).left);//box目前的left值 box.style.left=x+motion.x+&apos;px&apos;;&#125;); // 方块跟着重力左右移动 12345678910111213141516171819202122var box=document.getElementById(&apos;box&apos;);var lastRange=0; //上一次摇晃的幅度var isShake=false; //决定用户到底有没有大幅度摇晃window.addEventListener(&apos;devicemotion&apos;,function(ev)&#123; var motion=ev.accelerationIncludingGravity; var x=Math.abs(motion.x); var y=Math.abs(motion.y); var z=Math.abs(motion.z); var range=x+y+z; //当前摇晃的幅度 if(range-lastRange&gt;100)&#123; //这个条件成立说明用户现在已经在大幅度摇晃 isShake=true; &#125; if(isShake &amp;&amp; range&lt;50)&#123; //这个条件成立，说明用户摇晃的幅度很小了就要停了 box.innerHTML=&apos;摇晃了&apos;; isShake=false; &#125;&#125;); // 摇一摇应用原理 设备方向事件 deviceorientation这个事件封装了方向传感器数据的事件，可以获取手机静止状态下的方向数据（手机所处的角度，朝向等）ev.beta 表示在x轴上旋转的角度 范围为-180-180 描述的是设备由前向后旋转的情况ev.gamma 表示设备在y轴上的旋转角度 范围是-90-90 藐视的是由左向右旋转的情况ev.alpha 表示设备沿z轴 的旋转角度 范围是0-360 此事件只发生在window对象上 123window.addEventListener(&apos;deviceorientation&apos;,function(ev)&#123; box.innerHTML=&apos;x轴倾斜:&apos;+ev.beta.toFixed(1)+&apos;&lt;/br&gt;y轴倾斜:&apos;+ev.gamma.toFixed(1)+&apos;&lt;/br&gt;z轴倾斜:&apos;+ev.alpha.toFixed(1);&#125;); 手势事件 gestureIOS的safari引入了一组手势事件 当两个手指触摸屏幕就会产生手势 手势通常会改变显示项的大小，或者旋转显示项，有三个手势事件 gesturestart 当一个手指已经按在屏幕上 另个手指又触摸时候触发 gesturechange 当触摸屏幕的任何一个手指发生改变的时候触发 gestureend 当任何一个手指从屏幕上移开时候触发 ev.rotation 表示手指引起旋转角度 负值表示逆时针 正表示顺 从0开始ev.scale 表示两个手指之间的距离情况 向内收缩会缩短距离 目前只有ios2.0以上支持 安卓不支持一定要阻止浏览器默认行为 12345678910111213141516171819var startDeg=0; //上次旋转后的角度//两个或者两个以上手指按下box.addEventListener(&apos;gesturestart&apos;,function()&#123; this.style.background=&apos;blue&apos;; //rotate(90deg) if(this.style.transform)&#123; startDeg=parseFloat(this.style.transform.split(&apos;(&apos;)[1]); &#125;&#125;);//两个或者两个以上手指变换box.addEventListener(&apos;gesturechange&apos;,function(ev)&#123; /*this.style.background=&apos;black&apos;; this.innerHTML=ev.rotation;*/ this.style.transform=&apos;rotate(&apos;+(ev.rotation+startDeg)+&apos;deg)&apos;;&#125;);//两个或者两个以上手指抬起box.addEventListener(&apos;gestureend&apos;,function()&#123; this.style.background=&apos;green&apos;;&#125;); // 多指旋转 1234567891011121314151617181920212223242526272829document.addEventListener(&apos;touchstart&apos;,function(ev)&#123; ev.preventDefault();&#125;);document.addEventListener(&apos;touchmove&apos;,function(ev)&#123; ev.preventDefault();&#125;);var box=document.getElementById(&quot;box&quot;);var startScale=1; //上次缩放后的角度//两个或者两个以上手指按下box.addEventListener(&apos;gesturestart&apos;,function()&#123; this.style.background=&apos;blue&apos;; //rotate(90deg) if(this.style.transform)&#123; startScale=parseFloat(this.style.transform.split(&apos;(&apos;)[1]); &#125;&#125;);//两个或者两个以上手指变换box.addEventListener(&apos;gesturechange&apos;,function(ev)&#123; /*this.style.background=&apos;black&apos;; this.innerHTML=ev.rotation;*/ var sc=ev.scale*startScale; sc=sc&lt;0.5?0.5:sc;//设置最小缩放到0.5 this.style.transform=&apos;scale(&apos;+sc+&apos;)&apos;;&#125;);//两个或者两个以上手指抬起box.addEventListener(&apos;gestureend&apos;,function()&#123; this.style.background=&apos;green&apos;;&#125;); // 多指缩放 本文参考了qdfuns社区的笔记，是对其笔记的再学习，并非完全原创，不过链接没找到]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5项目常见问题汇总及解决方案]]></title>
    <url>%2Fh5-project-solution%2F</url>
    <content type="text"><![CDATA[H5项目常见问题汇总及解决方案。本篇文章来源于QDFUNS文章–H5项目常见问题汇总及解决方案。因为这个平台收藏别人的文章后，如果文章被删除了，就找不到了。所以留个存档。 H5项目常见问题及注意事项meta基础知识H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 1234567891011121314151617181920212223//一、HTML页面结构&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;// width 设置viewport宽度，为一个正整数，或字符串‘device-width’// height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例，为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放//二、JS动态判断 比如flexible.jsvar phoneWidth = parseInt(window.screen.width);var phoneScale = phoneWidth/640;var ua = navigator.userAgent;if (/Android (\d+\.\d+)/.test(ua))&#123; var version = parseFloat(RegExp.$1); if(version&gt;2.3)&#123; document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &apos;+phoneScale+&apos;, maximum-scale = &apos;+phoneScale+&apos;, target-densitydpi=device-dpi&quot;&gt;&apos;); &#125;else&#123; document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&apos;); &#125;&#125; else &#123; document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&apos;);&#125; 空白页基本meta标签12345678&lt;!-- 设置缩放 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt; 其他meta标签12345678910111213141516171819202122&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; font-family设置123456789101112131415161718@ --------------------------------------中文字体的英文名称@ 宋体 SimSun@ 黑体 SimHei@ 微信雅黑 Microsoft Yahei@ 微软正黑体 Microsoft JhengHei@ 新宋体 NSimSun@ 新细明体 MingLiU@ 细明体 MingLiU@ 标楷体 DFKai-SB@ 仿宋 FangSong@ 楷体 KaiTi@ 仿宋_GB2312 FangSong_GB2312@ 楷体_GB2312 KaiTi_GB2312@@ 说明：中文字体多数使用宋体、雅黑，英文用Helveticabody &#123; font-family: Microsoft Yahei, SimSun, Helvetica; &#125;// 可以只设置font-family: Helvetica; 电话短信邮件1234567891011121314151617181920212223242526// 一、打电话&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;// 二、发短信，winphone系统无效&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;// 三、写邮件//注：在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头//1.普通邮件&lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//5.包含主题，用?subject=&lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行&lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;//7.内容包含链接，含http(s)://等的文本自动转化为链接&lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;//8.内容包含图片（PC不支持）&lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;//9.完整示例&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt; 移动端touch事件123456789101112131415161718192021222324/* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */// 以下支持webkittouchstart——当手指触碰屏幕时候发生。不管当前有多少只手指touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动touchend——当手指离开屏幕时触发touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用//TouchEvent说明：touches：屏幕上所有手指的信息targetTouches：手指在目标区域的手指信息changedTouches：最近一次触发该事件的手指信息touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息//参数信息(changedTouches[0])clientX、clientY在显示区的坐标target：当前元素//事件响应顺序ontouchstart &gt; ontouchmove &gt; ontouchend &gt; onclick// 以下支持winphone 8MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html&#123;-ms-touch-action: none;&#125;可以阻止默认情况的发生：阻止页面滚动MSPointerUp——当手指离开屏幕时触发 点击延时响应123456789101112说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。以下是历史原因，来源一个公司内一个同事的分享：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。//解决方案：fastclick可以解决在手机上点击事件的300ms延迟zepto的touch模块，tap事件也是为了解决在click的延迟问题 Rentina显示屏说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 123456789101112//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;//其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px.css&#123;font-size:20px&#125;//image-set设计Rentina背景图image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。.css &#123; background: url(images/bg.jpg) no-repeat center; background: -webkit-image-set( url(images/bg.jpg) 1x, //支持image-set普通屏 url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan 图片链接高亮样式123456789101112/ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；//android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；//winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;去掉；//特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签a,button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符&#125;// 也可以* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;//winphone下&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; 美化表单元素123456789101112131415//一、使用appearance改变webkit浏览器的默认外观input,select &#123; -webkit-appearance:none; appearance: none; &#125;//二、winphone下，使用伪元素改变表单元素默认外观//1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰select::-ms-expand &#123; display:none; &#125;//2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display:none; &#125;//3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear &#123; display:none; &#125; 字体大小选择123456// 如需适配多种移动设备，建议使用rem。以下为参考值：html &#123; font-size: 62.5%; &#125; //10*16 = 62.5%//设置12px字体 这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级body &#123; font-size:12px; font-size:1.2rem; &#125;// 再通过media query或者js动态设置html的font-size值 移动端CSS样式123456789101112131415161718192021222324252627282930313233//去掉webkit的滚动条——display: none;//其他参数::-webkit-scrollba //滚动条整体部分::-webkit-scrollbar-thumb //滚动条内的小方块::-webkit-scrollbar-track //滚动条轨道::-webkit-scrollbar-button //滚动条轨道两端按钮::-webkit-scrollbar-track-piece //滚动条中间部分，内置轨道::-webkit-scrollbar-corner //边角，两个滚动条交汇处::-webkit-resizer //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件// 禁止长按链接与图片弹出菜单a,img &#123; -webkit-touch-callout: none &#125;// 禁止ios和android用户选中文字html,body &#123;-webkit-user-select:none; user-select: none; &#125;// 改变输入框placeholder的颜色值::-webkit-input-placeholder &#123; /* WebKit browsers */color: #999; &#125;:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */color: #999; &#125;::-moz-placeholder &#123; /* Mozilla Firefox 19+ */color: #999; &#125;:-ms-input-placeholder &#123; /* Internet Explorer 10+ */color: #999; &#125;input:focus::-webkit-input-placeholder&#123; color:#999; &#125;// android上去掉语音输入按钮input::-webkit-input-speech-button &#123;display: none&#125;// 阻止windows Phone的默认触摸事件/*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/html &#123; -ms-touch-action:none; &#125; //禁止winphone默认触摸事件 取消IOS设置input的英文首字母输入大写1&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt; 手机拍照和上传图片123//IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持&lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt; 屏幕旋转的事件和样式1234567891011121314151617181920//JS处理function orientInit()&#123; var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight?&apos;landscape&apos;:&apos;portrait&apos;; if(orientChk ==&apos;lapdscape&apos;)&#123; //这里是横屏下需要执行的事件 &#125;else&#123; //这里是竖屏下需要执行的事件 &#125;&#125;orientInit();window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function()&#123; setTimeout(orientInit, 100);&#125;,false)//CSS处理//竖屏时样式@media all and (orientation:portrait)&#123; &#125;//横屏时样式@media all and (orientation:landscape)&#123; &#125; audio元素和video元素在ios和andriod中无法自动播放1234567891011121314151617181920212223//音频，写法一&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt;//音频，写法二&lt;audio controls=&quot;controls&quot;&gt; &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt; &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt; 优先播放音乐bg.ogg，不支持在播放bg.mp3&lt;/audio&gt;//JS绑定自动播放（操作window时，播放音乐）$(window).one(&apos;touchstart&apos;, function()&#123; music.play();&#125;)//微信下兼容处理document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; music.play();&#125;, false);//小结//1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常//2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间 重力感应事件123456789101112131415161718192021222324// 运用HTML5的deviceMotion，调用重力感应事件if(window.DeviceMotionEvent)&#123; document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)&#125;var speed = 30;var x = y = z = lastX = lastY = lastZ = 0;function deviceMotionHandler(eventData)&#123; var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed )&#123; //这里是摇动后要执行的方法 yaoAfter(); &#125; lastX = x; lastY = y; lastZ = z;&#125;function yaoAfter()&#123; //do something&#125; 微信浏览器页面字体调整修复123456789101112131415161718192021//以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理if (typeof(WeixinJSBridge) == &quot;undefined&quot;) &#123; document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) &#123; setTimeout(function()&#123; WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123; alert(JSON.stringify(res)); &#125;) &#125;, 0) &#125;);&#125;else&#123; setTimeout(function()&#123; WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123; alert(JSON.stringify(res)); &#125;) &#125;, 0)&#125;//IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小body &#123; -webkit-text-size-adjust:100%!important; &#125;//最好的解决方案：最好使用rem或百分比布局 定位问题12345678910111213141516171819202122232425262728293031//fixed定位//1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位//2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位//3.ios4下不支持position:fixed//解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如：&lt;div id=&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ..... &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;iscroll.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var myscroll; function loaded()&#123; myscroll=new iScroll(&quot;wrapper&quot;); &#125; window.addEventListener(&quot;DOMContentLoaded&quot;,loaded,false);&lt;/script&gt;//position定位//Android下弹出软键盘弹出时，影响absolute元素定位//解决方案:var ua = navigator.userAgent.indexOf(&apos;Android&apos;);if(ua&gt;-1)&#123; $(&apos;.ipt&apos;).on(&apos;focus&apos;, function()&#123; $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;hidden&apos;&#125;) &#125;).on(&apos;blur&apos;, function()&#123; $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;visible&apos;&#125;) &#125;)&#125; 播放视频不全屏12345678&lt;!--1.ios7+支持自动播放2.支持Airplay的设备（如：音箱、Apple TV)播放x-webkit-airplay=&quot;true&quot;3.播放视频不全屏webkit-playsinline=&quot;true&quot;--&gt;&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt; JS判断设备12345678910111213function deviceType()&#123; var ua = navigator.userAgent; var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; for(var i=0; i&lt;len,len = agent.length; i++)&#123; if(ua.indexOf(agent[i])&gt;0)&#123; break; &#125; &#125;&#125;deviceType();window.addEventListener(&apos;resize&apos;, function()&#123; deviceType();&#125;) JS判断微信浏览器12345678function isWeixin()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;)&#123; return true; &#125;else&#123; return false; &#125;&#125; 安卓BUGandroid 2.3 bug @-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 after和before伪类无法使用动画animation border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值 translate百分比的写法和scale在一起会导致失效，例如： -webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio 消除transition闪屏12345.css &#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000;&#125; 开启硬件加速1234567//目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。.css &#123; -webkit-transform: translate3d(0,0,0); -moz-transform: translate3d(0,0,0); -ms-transform: translate3d(0,0,0); transform: translate3d(0,0,0);&#125; 渲染优化 禁止使用iframe（阻塞父文档onload事件） 禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能） 使用CSS3代码代替JS动画； 开启GPU加速； 使用base64位编码图片(不小图而言，大图不建议使用) 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于： 减少HTTP请求； 避免文件跨域； 修改及时生效；]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>H5</tag>
      </tags>
  </entry>
</search>
